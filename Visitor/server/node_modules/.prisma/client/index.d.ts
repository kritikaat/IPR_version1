
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Ratings
 * 
 */
export type Ratings = $Result.DefaultSelection<Prisma.$RatingsPayload>
/**
 * Model feedbackForm
 * 
 */
export type feedbackForm = $Result.DefaultSelection<Prisma.$feedbackFormPayload>
/**
 * Model Visitor
 * 
 */
export type Visitor = $Result.DefaultSelection<Prisma.$VisitorPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model AccompanyingTeacher
 * 
 */
export type AccompanyingTeacher = $Result.DefaultSelection<Prisma.$AccompanyingTeacherPayload>
/**
 * Model Competition
 * 
 */
export type Competition = $Result.DefaultSelection<Prisma.$CompetitionPayload>
/**
 * Model StudentModel1
 * 
 */
export type StudentModel1 = $Result.DefaultSelection<Prisma.$StudentModel1Payload>
/**
 * Model StudentModel2
 * 
 */
export type StudentModel2 = $Result.DefaultSelection<Prisma.$StudentModel2Payload>
/**
 * Model EloquenceEnglish
 * 
 */
export type EloquenceEnglish = $Result.DefaultSelection<Prisma.$EloquenceEnglishPayload>
/**
 * Model EloquenceHindi
 * 
 */
export type EloquenceHindi = $Result.DefaultSelection<Prisma.$EloquenceHindiPayload>
/**
 * Model EloquenceGujarati
 * 
 */
export type EloquenceGujarati = $Result.DefaultSelection<Prisma.$EloquenceGujaratiPayload>
/**
 * Model EssayEnglish
 * 
 */
export type EssayEnglish = $Result.DefaultSelection<Prisma.$EssayEnglishPayload>
/**
 * Model EssayHindi
 * 
 */
export type EssayHindi = $Result.DefaultSelection<Prisma.$EssayHindiPayload>
/**
 * Model EssayGujarati
 * 
 */
export type EssayGujarati = $Result.DefaultSelection<Prisma.$EssayGujaratiPayload>
/**
 * Model Poster
 * 
 */
export type Poster = $Result.DefaultSelection<Prisma.$PosterPayload>
/**
 * Model Skit
 * 
 */
export type Skit = $Result.DefaultSelection<Prisma.$SkitPayload>
/**
 * Model TeacherModel
 * 
 */
export type TeacherModel = $Result.DefaultSelection<Prisma.$TeacherModelPayload>
/**
 * Model IPRExhibitionForm
 * 
 */
export type IPRExhibitionForm = $Result.DefaultSelection<Prisma.$IPRExhibitionFormPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Ratings
 * const ratings = await prisma.ratings.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Ratings
   * const ratings = await prisma.ratings.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.ratings`: Exposes CRUD operations for the **Ratings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.ratings.findMany()
    * ```
    */
  get ratings(): Prisma.RatingsDelegate<ExtArgs>;

  /**
   * `prisma.feedbackForm`: Exposes CRUD operations for the **feedbackForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedbackForms
    * const feedbackForms = await prisma.feedbackForm.findMany()
    * ```
    */
  get feedbackForm(): Prisma.feedbackFormDelegate<ExtArgs>;

  /**
   * `prisma.visitor`: Exposes CRUD operations for the **Visitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitors
    * const visitors = await prisma.visitor.findMany()
    * ```
    */
  get visitor(): Prisma.VisitorDelegate<ExtArgs>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs>;

  /**
   * `prisma.accompanyingTeacher`: Exposes CRUD operations for the **AccompanyingTeacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccompanyingTeachers
    * const accompanyingTeachers = await prisma.accompanyingTeacher.findMany()
    * ```
    */
  get accompanyingTeacher(): Prisma.AccompanyingTeacherDelegate<ExtArgs>;

  /**
   * `prisma.competition`: Exposes CRUD operations for the **Competition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Competitions
    * const competitions = await prisma.competition.findMany()
    * ```
    */
  get competition(): Prisma.CompetitionDelegate<ExtArgs>;

  /**
   * `prisma.studentModel1`: Exposes CRUD operations for the **StudentModel1** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentModel1s
    * const studentModel1s = await prisma.studentModel1.findMany()
    * ```
    */
  get studentModel1(): Prisma.StudentModel1Delegate<ExtArgs>;

  /**
   * `prisma.studentModel2`: Exposes CRUD operations for the **StudentModel2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentModel2s
    * const studentModel2s = await prisma.studentModel2.findMany()
    * ```
    */
  get studentModel2(): Prisma.StudentModel2Delegate<ExtArgs>;

  /**
   * `prisma.eloquenceEnglish`: Exposes CRUD operations for the **EloquenceEnglish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EloquenceEnglishes
    * const eloquenceEnglishes = await prisma.eloquenceEnglish.findMany()
    * ```
    */
  get eloquenceEnglish(): Prisma.EloquenceEnglishDelegate<ExtArgs>;

  /**
   * `prisma.eloquenceHindi`: Exposes CRUD operations for the **EloquenceHindi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EloquenceHindis
    * const eloquenceHindis = await prisma.eloquenceHindi.findMany()
    * ```
    */
  get eloquenceHindi(): Prisma.EloquenceHindiDelegate<ExtArgs>;

  /**
   * `prisma.eloquenceGujarati`: Exposes CRUD operations for the **EloquenceGujarati** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EloquenceGujaratis
    * const eloquenceGujaratis = await prisma.eloquenceGujarati.findMany()
    * ```
    */
  get eloquenceGujarati(): Prisma.EloquenceGujaratiDelegate<ExtArgs>;

  /**
   * `prisma.essayEnglish`: Exposes CRUD operations for the **EssayEnglish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EssayEnglishes
    * const essayEnglishes = await prisma.essayEnglish.findMany()
    * ```
    */
  get essayEnglish(): Prisma.EssayEnglishDelegate<ExtArgs>;

  /**
   * `prisma.essayHindi`: Exposes CRUD operations for the **EssayHindi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EssayHindis
    * const essayHindis = await prisma.essayHindi.findMany()
    * ```
    */
  get essayHindi(): Prisma.EssayHindiDelegate<ExtArgs>;

  /**
   * `prisma.essayGujarati`: Exposes CRUD operations for the **EssayGujarati** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EssayGujaratis
    * const essayGujaratis = await prisma.essayGujarati.findMany()
    * ```
    */
  get essayGujarati(): Prisma.EssayGujaratiDelegate<ExtArgs>;

  /**
   * `prisma.poster`: Exposes CRUD operations for the **Poster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posters
    * const posters = await prisma.poster.findMany()
    * ```
    */
  get poster(): Prisma.PosterDelegate<ExtArgs>;

  /**
   * `prisma.skit`: Exposes CRUD operations for the **Skit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skits
    * const skits = await prisma.skit.findMany()
    * ```
    */
  get skit(): Prisma.SkitDelegate<ExtArgs>;

  /**
   * `prisma.teacherModel`: Exposes CRUD operations for the **TeacherModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherModels
    * const teacherModels = await prisma.teacherModel.findMany()
    * ```
    */
  get teacherModel(): Prisma.TeacherModelDelegate<ExtArgs>;

  /**
   * `prisma.iPRExhibitionForm`: Exposes CRUD operations for the **IPRExhibitionForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IPRExhibitionForms
    * const iPRExhibitionForms = await prisma.iPRExhibitionForm.findMany()
    * ```
    */
  get iPRExhibitionForm(): Prisma.IPRExhibitionFormDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Ratings: 'Ratings',
    feedbackForm: 'feedbackForm',
    Visitor: 'Visitor',
    School: 'School',
    AccompanyingTeacher: 'AccompanyingTeacher',
    Competition: 'Competition',
    StudentModel1: 'StudentModel1',
    StudentModel2: 'StudentModel2',
    EloquenceEnglish: 'EloquenceEnglish',
    EloquenceHindi: 'EloquenceHindi',
    EloquenceGujarati: 'EloquenceGujarati',
    EssayEnglish: 'EssayEnglish',
    EssayHindi: 'EssayHindi',
    EssayGujarati: 'EssayGujarati',
    Poster: 'Poster',
    Skit: 'Skit',
    TeacherModel: 'TeacherModel',
    IPRExhibitionForm: 'IPRExhibitionForm'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "ratings" | "feedbackForm" | "visitor" | "school" | "accompanyingTeacher" | "competition" | "studentModel1" | "studentModel2" | "eloquenceEnglish" | "eloquenceHindi" | "eloquenceGujarati" | "essayEnglish" | "essayHindi" | "essayGujarati" | "poster" | "skit" | "teacherModel" | "iPRExhibitionForm"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Ratings: {
        payload: Prisma.$RatingsPayload<ExtArgs>
        fields: Prisma.RatingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingsPayload>
          }
          findFirst: {
            args: Prisma.RatingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingsPayload>
          }
          findMany: {
            args: Prisma.RatingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingsPayload>[]
          }
          create: {
            args: Prisma.RatingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingsPayload>
          }
          createMany: {
            args: Prisma.RatingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RatingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingsPayload>[]
          }
          delete: {
            args: Prisma.RatingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingsPayload>
          }
          update: {
            args: Prisma.RatingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingsPayload>
          }
          deleteMany: {
            args: Prisma.RatingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RatingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RatingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingsPayload>
          }
          aggregate: {
            args: Prisma.RatingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRatings>
          }
          groupBy: {
            args: Prisma.RatingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatingsCountArgs<ExtArgs>
            result: $Utils.Optional<RatingsCountAggregateOutputType> | number
          }
        }
      }
      feedbackForm: {
        payload: Prisma.$feedbackFormPayload<ExtArgs>
        fields: Prisma.feedbackFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.feedbackFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.feedbackFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackFormPayload>
          }
          findFirst: {
            args: Prisma.feedbackFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.feedbackFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackFormPayload>
          }
          findMany: {
            args: Prisma.feedbackFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackFormPayload>[]
          }
          create: {
            args: Prisma.feedbackFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackFormPayload>
          }
          createMany: {
            args: Prisma.feedbackFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.feedbackFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackFormPayload>[]
          }
          delete: {
            args: Prisma.feedbackFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackFormPayload>
          }
          update: {
            args: Prisma.feedbackFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackFormPayload>
          }
          deleteMany: {
            args: Prisma.feedbackFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.feedbackFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.feedbackFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackFormPayload>
          }
          aggregate: {
            args: Prisma.FeedbackFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedbackForm>
          }
          groupBy: {
            args: Prisma.feedbackFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.feedbackFormCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackFormCountAggregateOutputType> | number
          }
        }
      }
      Visitor: {
        payload: Prisma.$VisitorPayload<ExtArgs>
        fields: Prisma.VisitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findFirst: {
            args: Prisma.VisitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findMany: {
            args: Prisma.VisitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          create: {
            args: Prisma.VisitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          createMany: {
            args: Prisma.VisitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          delete: {
            args: Prisma.VisitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          update: {
            args: Prisma.VisitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          deleteMany: {
            args: Prisma.VisitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          aggregate: {
            args: Prisma.VisitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitor>
          }
          groupBy: {
            args: Prisma.VisitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitorCountArgs<ExtArgs>
            result: $Utils.Optional<VisitorCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      AccompanyingTeacher: {
        payload: Prisma.$AccompanyingTeacherPayload<ExtArgs>
        fields: Prisma.AccompanyingTeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccompanyingTeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanyingTeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccompanyingTeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanyingTeacherPayload>
          }
          findFirst: {
            args: Prisma.AccompanyingTeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanyingTeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccompanyingTeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanyingTeacherPayload>
          }
          findMany: {
            args: Prisma.AccompanyingTeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanyingTeacherPayload>[]
          }
          create: {
            args: Prisma.AccompanyingTeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanyingTeacherPayload>
          }
          createMany: {
            args: Prisma.AccompanyingTeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccompanyingTeacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanyingTeacherPayload>[]
          }
          delete: {
            args: Prisma.AccompanyingTeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanyingTeacherPayload>
          }
          update: {
            args: Prisma.AccompanyingTeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanyingTeacherPayload>
          }
          deleteMany: {
            args: Prisma.AccompanyingTeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccompanyingTeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccompanyingTeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanyingTeacherPayload>
          }
          aggregate: {
            args: Prisma.AccompanyingTeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccompanyingTeacher>
          }
          groupBy: {
            args: Prisma.AccompanyingTeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccompanyingTeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccompanyingTeacherCountArgs<ExtArgs>
            result: $Utils.Optional<AccompanyingTeacherCountAggregateOutputType> | number
          }
        }
      }
      Competition: {
        payload: Prisma.$CompetitionPayload<ExtArgs>
        fields: Prisma.CompetitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompetitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompetitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitionPayload>
          }
          findFirst: {
            args: Prisma.CompetitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompetitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitionPayload>
          }
          findMany: {
            args: Prisma.CompetitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitionPayload>[]
          }
          create: {
            args: Prisma.CompetitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitionPayload>
          }
          createMany: {
            args: Prisma.CompetitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompetitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitionPayload>[]
          }
          delete: {
            args: Prisma.CompetitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitionPayload>
          }
          update: {
            args: Prisma.CompetitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitionPayload>
          }
          deleteMany: {
            args: Prisma.CompetitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompetitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompetitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitionPayload>
          }
          aggregate: {
            args: Prisma.CompetitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompetition>
          }
          groupBy: {
            args: Prisma.CompetitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompetitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompetitionCountArgs<ExtArgs>
            result: $Utils.Optional<CompetitionCountAggregateOutputType> | number
          }
        }
      }
      StudentModel1: {
        payload: Prisma.$StudentModel1Payload<ExtArgs>
        fields: Prisma.StudentModel1FieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentModel1FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel1Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentModel1FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel1Payload>
          }
          findFirst: {
            args: Prisma.StudentModel1FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel1Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentModel1FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel1Payload>
          }
          findMany: {
            args: Prisma.StudentModel1FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel1Payload>[]
          }
          create: {
            args: Prisma.StudentModel1CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel1Payload>
          }
          createMany: {
            args: Prisma.StudentModel1CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentModel1CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel1Payload>[]
          }
          delete: {
            args: Prisma.StudentModel1DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel1Payload>
          }
          update: {
            args: Prisma.StudentModel1UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel1Payload>
          }
          deleteMany: {
            args: Prisma.StudentModel1DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentModel1UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentModel1UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel1Payload>
          }
          aggregate: {
            args: Prisma.StudentModel1AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentModel1>
          }
          groupBy: {
            args: Prisma.StudentModel1GroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentModel1GroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentModel1CountArgs<ExtArgs>
            result: $Utils.Optional<StudentModel1CountAggregateOutputType> | number
          }
        }
      }
      StudentModel2: {
        payload: Prisma.$StudentModel2Payload<ExtArgs>
        fields: Prisma.StudentModel2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentModel2FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentModel2FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel2Payload>
          }
          findFirst: {
            args: Prisma.StudentModel2FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentModel2FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel2Payload>
          }
          findMany: {
            args: Prisma.StudentModel2FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel2Payload>[]
          }
          create: {
            args: Prisma.StudentModel2CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel2Payload>
          }
          createMany: {
            args: Prisma.StudentModel2CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentModel2CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel2Payload>[]
          }
          delete: {
            args: Prisma.StudentModel2DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel2Payload>
          }
          update: {
            args: Prisma.StudentModel2UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel2Payload>
          }
          deleteMany: {
            args: Prisma.StudentModel2DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentModel2UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentModel2UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentModel2Payload>
          }
          aggregate: {
            args: Prisma.StudentModel2AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentModel2>
          }
          groupBy: {
            args: Prisma.StudentModel2GroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentModel2GroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentModel2CountArgs<ExtArgs>
            result: $Utils.Optional<StudentModel2CountAggregateOutputType> | number
          }
        }
      }
      EloquenceEnglish: {
        payload: Prisma.$EloquenceEnglishPayload<ExtArgs>
        fields: Prisma.EloquenceEnglishFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EloquenceEnglishFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceEnglishPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EloquenceEnglishFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceEnglishPayload>
          }
          findFirst: {
            args: Prisma.EloquenceEnglishFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceEnglishPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EloquenceEnglishFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceEnglishPayload>
          }
          findMany: {
            args: Prisma.EloquenceEnglishFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceEnglishPayload>[]
          }
          create: {
            args: Prisma.EloquenceEnglishCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceEnglishPayload>
          }
          createMany: {
            args: Prisma.EloquenceEnglishCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EloquenceEnglishCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceEnglishPayload>[]
          }
          delete: {
            args: Prisma.EloquenceEnglishDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceEnglishPayload>
          }
          update: {
            args: Prisma.EloquenceEnglishUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceEnglishPayload>
          }
          deleteMany: {
            args: Prisma.EloquenceEnglishDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EloquenceEnglishUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EloquenceEnglishUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceEnglishPayload>
          }
          aggregate: {
            args: Prisma.EloquenceEnglishAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEloquenceEnglish>
          }
          groupBy: {
            args: Prisma.EloquenceEnglishGroupByArgs<ExtArgs>
            result: $Utils.Optional<EloquenceEnglishGroupByOutputType>[]
          }
          count: {
            args: Prisma.EloquenceEnglishCountArgs<ExtArgs>
            result: $Utils.Optional<EloquenceEnglishCountAggregateOutputType> | number
          }
        }
      }
      EloquenceHindi: {
        payload: Prisma.$EloquenceHindiPayload<ExtArgs>
        fields: Prisma.EloquenceHindiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EloquenceHindiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceHindiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EloquenceHindiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceHindiPayload>
          }
          findFirst: {
            args: Prisma.EloquenceHindiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceHindiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EloquenceHindiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceHindiPayload>
          }
          findMany: {
            args: Prisma.EloquenceHindiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceHindiPayload>[]
          }
          create: {
            args: Prisma.EloquenceHindiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceHindiPayload>
          }
          createMany: {
            args: Prisma.EloquenceHindiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EloquenceHindiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceHindiPayload>[]
          }
          delete: {
            args: Prisma.EloquenceHindiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceHindiPayload>
          }
          update: {
            args: Prisma.EloquenceHindiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceHindiPayload>
          }
          deleteMany: {
            args: Prisma.EloquenceHindiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EloquenceHindiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EloquenceHindiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceHindiPayload>
          }
          aggregate: {
            args: Prisma.EloquenceHindiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEloquenceHindi>
          }
          groupBy: {
            args: Prisma.EloquenceHindiGroupByArgs<ExtArgs>
            result: $Utils.Optional<EloquenceHindiGroupByOutputType>[]
          }
          count: {
            args: Prisma.EloquenceHindiCountArgs<ExtArgs>
            result: $Utils.Optional<EloquenceHindiCountAggregateOutputType> | number
          }
        }
      }
      EloquenceGujarati: {
        payload: Prisma.$EloquenceGujaratiPayload<ExtArgs>
        fields: Prisma.EloquenceGujaratiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EloquenceGujaratiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceGujaratiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EloquenceGujaratiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceGujaratiPayload>
          }
          findFirst: {
            args: Prisma.EloquenceGujaratiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceGujaratiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EloquenceGujaratiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceGujaratiPayload>
          }
          findMany: {
            args: Prisma.EloquenceGujaratiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceGujaratiPayload>[]
          }
          create: {
            args: Prisma.EloquenceGujaratiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceGujaratiPayload>
          }
          createMany: {
            args: Prisma.EloquenceGujaratiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EloquenceGujaratiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceGujaratiPayload>[]
          }
          delete: {
            args: Prisma.EloquenceGujaratiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceGujaratiPayload>
          }
          update: {
            args: Prisma.EloquenceGujaratiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceGujaratiPayload>
          }
          deleteMany: {
            args: Prisma.EloquenceGujaratiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EloquenceGujaratiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EloquenceGujaratiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EloquenceGujaratiPayload>
          }
          aggregate: {
            args: Prisma.EloquenceGujaratiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEloquenceGujarati>
          }
          groupBy: {
            args: Prisma.EloquenceGujaratiGroupByArgs<ExtArgs>
            result: $Utils.Optional<EloquenceGujaratiGroupByOutputType>[]
          }
          count: {
            args: Prisma.EloquenceGujaratiCountArgs<ExtArgs>
            result: $Utils.Optional<EloquenceGujaratiCountAggregateOutputType> | number
          }
        }
      }
      EssayEnglish: {
        payload: Prisma.$EssayEnglishPayload<ExtArgs>
        fields: Prisma.EssayEnglishFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EssayEnglishFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayEnglishPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EssayEnglishFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayEnglishPayload>
          }
          findFirst: {
            args: Prisma.EssayEnglishFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayEnglishPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EssayEnglishFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayEnglishPayload>
          }
          findMany: {
            args: Prisma.EssayEnglishFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayEnglishPayload>[]
          }
          create: {
            args: Prisma.EssayEnglishCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayEnglishPayload>
          }
          createMany: {
            args: Prisma.EssayEnglishCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EssayEnglishCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayEnglishPayload>[]
          }
          delete: {
            args: Prisma.EssayEnglishDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayEnglishPayload>
          }
          update: {
            args: Prisma.EssayEnglishUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayEnglishPayload>
          }
          deleteMany: {
            args: Prisma.EssayEnglishDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EssayEnglishUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EssayEnglishUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayEnglishPayload>
          }
          aggregate: {
            args: Prisma.EssayEnglishAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEssayEnglish>
          }
          groupBy: {
            args: Prisma.EssayEnglishGroupByArgs<ExtArgs>
            result: $Utils.Optional<EssayEnglishGroupByOutputType>[]
          }
          count: {
            args: Prisma.EssayEnglishCountArgs<ExtArgs>
            result: $Utils.Optional<EssayEnglishCountAggregateOutputType> | number
          }
        }
      }
      EssayHindi: {
        payload: Prisma.$EssayHindiPayload<ExtArgs>
        fields: Prisma.EssayHindiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EssayHindiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayHindiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EssayHindiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayHindiPayload>
          }
          findFirst: {
            args: Prisma.EssayHindiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayHindiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EssayHindiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayHindiPayload>
          }
          findMany: {
            args: Prisma.EssayHindiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayHindiPayload>[]
          }
          create: {
            args: Prisma.EssayHindiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayHindiPayload>
          }
          createMany: {
            args: Prisma.EssayHindiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EssayHindiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayHindiPayload>[]
          }
          delete: {
            args: Prisma.EssayHindiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayHindiPayload>
          }
          update: {
            args: Prisma.EssayHindiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayHindiPayload>
          }
          deleteMany: {
            args: Prisma.EssayHindiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EssayHindiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EssayHindiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayHindiPayload>
          }
          aggregate: {
            args: Prisma.EssayHindiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEssayHindi>
          }
          groupBy: {
            args: Prisma.EssayHindiGroupByArgs<ExtArgs>
            result: $Utils.Optional<EssayHindiGroupByOutputType>[]
          }
          count: {
            args: Prisma.EssayHindiCountArgs<ExtArgs>
            result: $Utils.Optional<EssayHindiCountAggregateOutputType> | number
          }
        }
      }
      EssayGujarati: {
        payload: Prisma.$EssayGujaratiPayload<ExtArgs>
        fields: Prisma.EssayGujaratiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EssayGujaratiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayGujaratiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EssayGujaratiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayGujaratiPayload>
          }
          findFirst: {
            args: Prisma.EssayGujaratiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayGujaratiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EssayGujaratiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayGujaratiPayload>
          }
          findMany: {
            args: Prisma.EssayGujaratiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayGujaratiPayload>[]
          }
          create: {
            args: Prisma.EssayGujaratiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayGujaratiPayload>
          }
          createMany: {
            args: Prisma.EssayGujaratiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EssayGujaratiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayGujaratiPayload>[]
          }
          delete: {
            args: Prisma.EssayGujaratiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayGujaratiPayload>
          }
          update: {
            args: Prisma.EssayGujaratiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayGujaratiPayload>
          }
          deleteMany: {
            args: Prisma.EssayGujaratiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EssayGujaratiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EssayGujaratiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EssayGujaratiPayload>
          }
          aggregate: {
            args: Prisma.EssayGujaratiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEssayGujarati>
          }
          groupBy: {
            args: Prisma.EssayGujaratiGroupByArgs<ExtArgs>
            result: $Utils.Optional<EssayGujaratiGroupByOutputType>[]
          }
          count: {
            args: Prisma.EssayGujaratiCountArgs<ExtArgs>
            result: $Utils.Optional<EssayGujaratiCountAggregateOutputType> | number
          }
        }
      }
      Poster: {
        payload: Prisma.$PosterPayload<ExtArgs>
        fields: Prisma.PosterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosterPayload>
          }
          findFirst: {
            args: Prisma.PosterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosterPayload>
          }
          findMany: {
            args: Prisma.PosterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosterPayload>[]
          }
          create: {
            args: Prisma.PosterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosterPayload>
          }
          createMany: {
            args: Prisma.PosterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosterPayload>[]
          }
          delete: {
            args: Prisma.PosterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosterPayload>
          }
          update: {
            args: Prisma.PosterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosterPayload>
          }
          deleteMany: {
            args: Prisma.PosterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PosterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosterPayload>
          }
          aggregate: {
            args: Prisma.PosterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoster>
          }
          groupBy: {
            args: Prisma.PosterGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosterGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosterCountArgs<ExtArgs>
            result: $Utils.Optional<PosterCountAggregateOutputType> | number
          }
        }
      }
      Skit: {
        payload: Prisma.$SkitPayload<ExtArgs>
        fields: Prisma.SkitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkitPayload>
          }
          findFirst: {
            args: Prisma.SkitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkitPayload>
          }
          findMany: {
            args: Prisma.SkitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkitPayload>[]
          }
          create: {
            args: Prisma.SkitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkitPayload>
          }
          createMany: {
            args: Prisma.SkitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkitPayload>[]
          }
          delete: {
            args: Prisma.SkitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkitPayload>
          }
          update: {
            args: Prisma.SkitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkitPayload>
          }
          deleteMany: {
            args: Prisma.SkitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkitPayload>
          }
          aggregate: {
            args: Prisma.SkitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkit>
          }
          groupBy: {
            args: Prisma.SkitGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkitGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkitCountArgs<ExtArgs>
            result: $Utils.Optional<SkitCountAggregateOutputType> | number
          }
        }
      }
      TeacherModel: {
        payload: Prisma.$TeacherModelPayload<ExtArgs>
        fields: Prisma.TeacherModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherModelPayload>
          }
          findFirst: {
            args: Prisma.TeacherModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherModelPayload>
          }
          findMany: {
            args: Prisma.TeacherModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherModelPayload>[]
          }
          create: {
            args: Prisma.TeacherModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherModelPayload>
          }
          createMany: {
            args: Prisma.TeacherModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherModelPayload>[]
          }
          delete: {
            args: Prisma.TeacherModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherModelPayload>
          }
          update: {
            args: Prisma.TeacherModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherModelPayload>
          }
          deleteMany: {
            args: Prisma.TeacherModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherModelPayload>
          }
          aggregate: {
            args: Prisma.TeacherModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherModel>
          }
          groupBy: {
            args: Prisma.TeacherModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherModelCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherModelCountAggregateOutputType> | number
          }
        }
      }
      IPRExhibitionForm: {
        payload: Prisma.$IPRExhibitionFormPayload<ExtArgs>
        fields: Prisma.IPRExhibitionFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IPRExhibitionFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPRExhibitionFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IPRExhibitionFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPRExhibitionFormPayload>
          }
          findFirst: {
            args: Prisma.IPRExhibitionFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPRExhibitionFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IPRExhibitionFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPRExhibitionFormPayload>
          }
          findMany: {
            args: Prisma.IPRExhibitionFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPRExhibitionFormPayload>[]
          }
          create: {
            args: Prisma.IPRExhibitionFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPRExhibitionFormPayload>
          }
          createMany: {
            args: Prisma.IPRExhibitionFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IPRExhibitionFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPRExhibitionFormPayload>[]
          }
          delete: {
            args: Prisma.IPRExhibitionFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPRExhibitionFormPayload>
          }
          update: {
            args: Prisma.IPRExhibitionFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPRExhibitionFormPayload>
          }
          deleteMany: {
            args: Prisma.IPRExhibitionFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IPRExhibitionFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IPRExhibitionFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPRExhibitionFormPayload>
          }
          aggregate: {
            args: Prisma.IPRExhibitionFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIPRExhibitionForm>
          }
          groupBy: {
            args: Prisma.IPRExhibitionFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<IPRExhibitionFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.IPRExhibitionFormCountArgs<ExtArgs>
            result: $Utils.Optional<IPRExhibitionFormCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    accompanyingTeachers: number
    competitions: number
    StudentModel1: number
    StudentModel2: number
    EloquenceEnglish: number
    EloquenceHindi: number
    EloquenceGujarati: number
    EssayEnglish: number
    EssayHindi: number
    EssayGujarati: number
    Poster: number
    Skit: number
    TeacherModel: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompanyingTeachers?: boolean | SchoolCountOutputTypeCountAccompanyingTeachersArgs
    competitions?: boolean | SchoolCountOutputTypeCountCompetitionsArgs
    StudentModel1?: boolean | SchoolCountOutputTypeCountStudentModel1Args
    StudentModel2?: boolean | SchoolCountOutputTypeCountStudentModel2Args
    EloquenceEnglish?: boolean | SchoolCountOutputTypeCountEloquenceEnglishArgs
    EloquenceHindi?: boolean | SchoolCountOutputTypeCountEloquenceHindiArgs
    EloquenceGujarati?: boolean | SchoolCountOutputTypeCountEloquenceGujaratiArgs
    EssayEnglish?: boolean | SchoolCountOutputTypeCountEssayEnglishArgs
    EssayHindi?: boolean | SchoolCountOutputTypeCountEssayHindiArgs
    EssayGujarati?: boolean | SchoolCountOutputTypeCountEssayGujaratiArgs
    Poster?: boolean | SchoolCountOutputTypeCountPosterArgs
    Skit?: boolean | SchoolCountOutputTypeCountSkitArgs
    TeacherModel?: boolean | SchoolCountOutputTypeCountTeacherModelArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountAccompanyingTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccompanyingTeacherWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountCompetitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetitionWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountStudentModel1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentModel1WhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountStudentModel2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentModel2WhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountEloquenceEnglishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EloquenceEnglishWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountEloquenceHindiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EloquenceHindiWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountEloquenceGujaratiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EloquenceGujaratiWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountEssayEnglishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EssayEnglishWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountEssayHindiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EssayHindiWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountEssayGujaratiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EssayGujaratiWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountPosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosterWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountSkitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkitWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountTeacherModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherModelWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Ratings
   */

  export type AggregateRatings = {
    _count: RatingsCountAggregateOutputType | null
    _avg: RatingsAvgAggregateOutputType | null
    _sum: RatingsSumAggregateOutputType | null
    _min: RatingsMinAggregateOutputType | null
    _max: RatingsMaxAggregateOutputType | null
  }

  export type RatingsAvgAggregateOutputType = {
    id: number | null
    iprRating: number | null
    fciptRating: number | null
    knowledge: number | null
    explanationsIPR: number | null
    explanationsFCIPT: number | null
    knowledgeBefore: number | null
    knowledgeAfter: number | null
    technicalContents: number | null
    easeOfUnderstanding: number | null
    feedbackFormId: number | null
  }

  export type RatingsSumAggregateOutputType = {
    id: number | null
    iprRating: number | null
    fciptRating: number | null
    knowledge: number | null
    explanationsIPR: number | null
    explanationsFCIPT: number | null
    knowledgeBefore: number | null
    knowledgeAfter: number | null
    technicalContents: number | null
    easeOfUnderstanding: number | null
    feedbackFormId: number | null
  }

  export type RatingsMinAggregateOutputType = {
    id: number | null
    iprRating: number | null
    fciptRating: number | null
    knowledge: number | null
    explanationsIPR: number | null
    explanationsFCIPT: number | null
    knowledgeBefore: number | null
    knowledgeAfter: number | null
    technicalContents: number | null
    easeOfUnderstanding: number | null
    feedbackFormId: number | null
  }

  export type RatingsMaxAggregateOutputType = {
    id: number | null
    iprRating: number | null
    fciptRating: number | null
    knowledge: number | null
    explanationsIPR: number | null
    explanationsFCIPT: number | null
    knowledgeBefore: number | null
    knowledgeAfter: number | null
    technicalContents: number | null
    easeOfUnderstanding: number | null
    feedbackFormId: number | null
  }

  export type RatingsCountAggregateOutputType = {
    id: number
    iprRating: number
    fciptRating: number
    knowledge: number
    explanationsIPR: number
    explanationsFCIPT: number
    knowledgeBefore: number
    knowledgeAfter: number
    technicalContents: number
    easeOfUnderstanding: number
    feedbackFormId: number
    _all: number
  }


  export type RatingsAvgAggregateInputType = {
    id?: true
    iprRating?: true
    fciptRating?: true
    knowledge?: true
    explanationsIPR?: true
    explanationsFCIPT?: true
    knowledgeBefore?: true
    knowledgeAfter?: true
    technicalContents?: true
    easeOfUnderstanding?: true
    feedbackFormId?: true
  }

  export type RatingsSumAggregateInputType = {
    id?: true
    iprRating?: true
    fciptRating?: true
    knowledge?: true
    explanationsIPR?: true
    explanationsFCIPT?: true
    knowledgeBefore?: true
    knowledgeAfter?: true
    technicalContents?: true
    easeOfUnderstanding?: true
    feedbackFormId?: true
  }

  export type RatingsMinAggregateInputType = {
    id?: true
    iprRating?: true
    fciptRating?: true
    knowledge?: true
    explanationsIPR?: true
    explanationsFCIPT?: true
    knowledgeBefore?: true
    knowledgeAfter?: true
    technicalContents?: true
    easeOfUnderstanding?: true
    feedbackFormId?: true
  }

  export type RatingsMaxAggregateInputType = {
    id?: true
    iprRating?: true
    fciptRating?: true
    knowledge?: true
    explanationsIPR?: true
    explanationsFCIPT?: true
    knowledgeBefore?: true
    knowledgeAfter?: true
    technicalContents?: true
    easeOfUnderstanding?: true
    feedbackFormId?: true
  }

  export type RatingsCountAggregateInputType = {
    id?: true
    iprRating?: true
    fciptRating?: true
    knowledge?: true
    explanationsIPR?: true
    explanationsFCIPT?: true
    knowledgeBefore?: true
    knowledgeAfter?: true
    technicalContents?: true
    easeOfUnderstanding?: true
    feedbackFormId?: true
    _all?: true
  }

  export type RatingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to aggregate.
     */
    where?: RatingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingsOrderByWithRelationInput | RatingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    _count?: true | RatingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingsMaxAggregateInputType
  }

  export type GetRatingsAggregateType<T extends RatingsAggregateArgs> = {
        [P in keyof T & keyof AggregateRatings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRatings[P]>
      : GetScalarType<T[P], AggregateRatings[P]>
  }




  export type RatingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingsWhereInput
    orderBy?: RatingsOrderByWithAggregationInput | RatingsOrderByWithAggregationInput[]
    by: RatingsScalarFieldEnum[] | RatingsScalarFieldEnum
    having?: RatingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingsCountAggregateInputType | true
    _avg?: RatingsAvgAggregateInputType
    _sum?: RatingsSumAggregateInputType
    _min?: RatingsMinAggregateInputType
    _max?: RatingsMaxAggregateInputType
  }

  export type RatingsGroupByOutputType = {
    id: number
    iprRating: number
    fciptRating: number
    knowledge: number
    explanationsIPR: number
    explanationsFCIPT: number
    knowledgeBefore: number
    knowledgeAfter: number
    technicalContents: number
    easeOfUnderstanding: number
    feedbackFormId: number
    _count: RatingsCountAggregateOutputType | null
    _avg: RatingsAvgAggregateOutputType | null
    _sum: RatingsSumAggregateOutputType | null
    _min: RatingsMinAggregateOutputType | null
    _max: RatingsMaxAggregateOutputType | null
  }

  type GetRatingsGroupByPayload<T extends RatingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingsGroupByOutputType[P]>
            : GetScalarType<T[P], RatingsGroupByOutputType[P]>
        }
      >
    >


  export type RatingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    iprRating?: boolean
    fciptRating?: boolean
    knowledge?: boolean
    explanationsIPR?: boolean
    explanationsFCIPT?: boolean
    knowledgeBefore?: boolean
    knowledgeAfter?: boolean
    technicalContents?: boolean
    easeOfUnderstanding?: boolean
    feedbackFormId?: boolean
    feedbackForm?: boolean | feedbackFormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ratings"]>

  export type RatingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    iprRating?: boolean
    fciptRating?: boolean
    knowledge?: boolean
    explanationsIPR?: boolean
    explanationsFCIPT?: boolean
    knowledgeBefore?: boolean
    knowledgeAfter?: boolean
    technicalContents?: boolean
    easeOfUnderstanding?: boolean
    feedbackFormId?: boolean
    feedbackForm?: boolean | feedbackFormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ratings"]>

  export type RatingsSelectScalar = {
    id?: boolean
    iprRating?: boolean
    fciptRating?: boolean
    knowledge?: boolean
    explanationsIPR?: boolean
    explanationsFCIPT?: boolean
    knowledgeBefore?: boolean
    knowledgeAfter?: boolean
    technicalContents?: boolean
    easeOfUnderstanding?: boolean
    feedbackFormId?: boolean
  }

  export type RatingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedbackForm?: boolean | feedbackFormDefaultArgs<ExtArgs>
  }
  export type RatingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedbackForm?: boolean | feedbackFormDefaultArgs<ExtArgs>
  }

  export type $RatingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ratings"
    objects: {
      feedbackForm: Prisma.$feedbackFormPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      iprRating: number
      fciptRating: number
      knowledge: number
      explanationsIPR: number
      explanationsFCIPT: number
      knowledgeBefore: number
      knowledgeAfter: number
      technicalContents: number
      easeOfUnderstanding: number
      feedbackFormId: number
    }, ExtArgs["result"]["ratings"]>
    composites: {}
  }

  type RatingsGetPayload<S extends boolean | null | undefined | RatingsDefaultArgs> = $Result.GetResult<Prisma.$RatingsPayload, S>

  type RatingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RatingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RatingsCountAggregateInputType | true
    }

  export interface RatingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ratings'], meta: { name: 'Ratings' } }
    /**
     * Find zero or one Ratings that matches the filter.
     * @param {RatingsFindUniqueArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RatingsFindUniqueArgs>(args: SelectSubset<T, RatingsFindUniqueArgs<ExtArgs>>): Prisma__RatingsClient<$Result.GetResult<Prisma.$RatingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ratings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RatingsFindUniqueOrThrowArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RatingsFindUniqueOrThrowArgs>(args: SelectSubset<T, RatingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RatingsClient<$Result.GetResult<Prisma.$RatingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingsFindFirstArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RatingsFindFirstArgs>(args?: SelectSubset<T, RatingsFindFirstArgs<ExtArgs>>): Prisma__RatingsClient<$Result.GetResult<Prisma.$RatingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ratings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingsFindFirstOrThrowArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RatingsFindFirstOrThrowArgs>(args?: SelectSubset<T, RatingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RatingsClient<$Result.GetResult<Prisma.$RatingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.ratings.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.ratings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingsWithIdOnly = await prisma.ratings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RatingsFindManyArgs>(args?: SelectSubset<T, RatingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ratings.
     * @param {RatingsCreateArgs} args - Arguments to create a Ratings.
     * @example
     * // Create one Ratings
     * const Ratings = await prisma.ratings.create({
     *   data: {
     *     // ... data to create a Ratings
     *   }
     * })
     * 
     */
    create<T extends RatingsCreateArgs>(args: SelectSubset<T, RatingsCreateArgs<ExtArgs>>): Prisma__RatingsClient<$Result.GetResult<Prisma.$RatingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ratings.
     * @param {RatingsCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const ratings = await prisma.ratings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RatingsCreateManyArgs>(args?: SelectSubset<T, RatingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ratings and returns the data saved in the database.
     * @param {RatingsCreateManyAndReturnArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const ratings = await prisma.ratings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ratings and only return the `id`
     * const ratingsWithIdOnly = await prisma.ratings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RatingsCreateManyAndReturnArgs>(args?: SelectSubset<T, RatingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ratings.
     * @param {RatingsDeleteArgs} args - Arguments to delete one Ratings.
     * @example
     * // Delete one Ratings
     * const Ratings = await prisma.ratings.delete({
     *   where: {
     *     // ... filter to delete one Ratings
     *   }
     * })
     * 
     */
    delete<T extends RatingsDeleteArgs>(args: SelectSubset<T, RatingsDeleteArgs<ExtArgs>>): Prisma__RatingsClient<$Result.GetResult<Prisma.$RatingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ratings.
     * @param {RatingsUpdateArgs} args - Arguments to update one Ratings.
     * @example
     * // Update one Ratings
     * const ratings = await prisma.ratings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RatingsUpdateArgs>(args: SelectSubset<T, RatingsUpdateArgs<ExtArgs>>): Prisma__RatingsClient<$Result.GetResult<Prisma.$RatingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ratings.
     * @param {RatingsDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.ratings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RatingsDeleteManyArgs>(args?: SelectSubset<T, RatingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const ratings = await prisma.ratings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RatingsUpdateManyArgs>(args: SelectSubset<T, RatingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ratings.
     * @param {RatingsUpsertArgs} args - Arguments to update or create a Ratings.
     * @example
     * // Update or create a Ratings
     * const ratings = await prisma.ratings.upsert({
     *   create: {
     *     // ... data to create a Ratings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ratings we want to update
     *   }
     * })
     */
    upsert<T extends RatingsUpsertArgs>(args: SelectSubset<T, RatingsUpsertArgs<ExtArgs>>): Prisma__RatingsClient<$Result.GetResult<Prisma.$RatingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingsCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.ratings.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingsCountArgs>(
      args?: Subset<T, RatingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingsAggregateArgs>(args: Subset<T, RatingsAggregateArgs>): Prisma.PrismaPromise<GetRatingsAggregateType<T>>

    /**
     * Group by Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingsGroupByArgs['orderBy'] }
        : { orderBy?: RatingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ratings model
   */
  readonly fields: RatingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ratings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feedbackForm<T extends feedbackFormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, feedbackFormDefaultArgs<ExtArgs>>): Prisma__feedbackFormClient<$Result.GetResult<Prisma.$feedbackFormPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ratings model
   */ 
  interface RatingsFieldRefs {
    readonly id: FieldRef<"Ratings", 'Int'>
    readonly iprRating: FieldRef<"Ratings", 'Int'>
    readonly fciptRating: FieldRef<"Ratings", 'Int'>
    readonly knowledge: FieldRef<"Ratings", 'Int'>
    readonly explanationsIPR: FieldRef<"Ratings", 'Int'>
    readonly explanationsFCIPT: FieldRef<"Ratings", 'Int'>
    readonly knowledgeBefore: FieldRef<"Ratings", 'Int'>
    readonly knowledgeAfter: FieldRef<"Ratings", 'Int'>
    readonly technicalContents: FieldRef<"Ratings", 'Int'>
    readonly easeOfUnderstanding: FieldRef<"Ratings", 'Int'>
    readonly feedbackFormId: FieldRef<"Ratings", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Ratings findUnique
   */
  export type RatingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where: RatingsWhereUniqueInput
  }

  /**
   * Ratings findUniqueOrThrow
   */
  export type RatingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where: RatingsWhereUniqueInput
  }

  /**
   * Ratings findFirst
   */
  export type RatingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingsOrderByWithRelationInput | RatingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * Ratings findFirstOrThrow
   */
  export type RatingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingsOrderByWithRelationInput | RatingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * Ratings findMany
   */
  export type RatingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingsOrderByWithRelationInput | RatingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
     */
    cursor?: RatingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * Ratings create
   */
  export type RatingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsInclude<ExtArgs> | null
    /**
     * The data needed to create a Ratings.
     */
    data: XOR<RatingsCreateInput, RatingsUncheckedCreateInput>
  }

  /**
   * Ratings createMany
   */
  export type RatingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ratings.
     */
    data: RatingsCreateManyInput | RatingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ratings createManyAndReturn
   */
  export type RatingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ratings.
     */
    data: RatingsCreateManyInput | RatingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ratings update
   */
  export type RatingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsInclude<ExtArgs> | null
    /**
     * The data needed to update a Ratings.
     */
    data: XOR<RatingsUpdateInput, RatingsUncheckedUpdateInput>
    /**
     * Choose, which Ratings to update.
     */
    where: RatingsWhereUniqueInput
  }

  /**
   * Ratings updateMany
   */
  export type RatingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingsUpdateManyMutationInput, RatingsUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingsWhereInput
  }

  /**
   * Ratings upsert
   */
  export type RatingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsInclude<ExtArgs> | null
    /**
     * The filter to search for the Ratings to update in case it exists.
     */
    where: RatingsWhereUniqueInput
    /**
     * In case the Ratings found by the `where` argument doesn't exist, create a new Ratings with this data.
     */
    create: XOR<RatingsCreateInput, RatingsUncheckedCreateInput>
    /**
     * In case the Ratings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatingsUpdateInput, RatingsUncheckedUpdateInput>
  }

  /**
   * Ratings delete
   */
  export type RatingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsInclude<ExtArgs> | null
    /**
     * Filter which Ratings to delete.
     */
    where: RatingsWhereUniqueInput
  }

  /**
   * Ratings deleteMany
   */
  export type RatingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to delete
     */
    where?: RatingsWhereInput
  }

  /**
   * Ratings without action
   */
  export type RatingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsInclude<ExtArgs> | null
  }


  /**
   * Model feedbackForm
   */

  export type AggregateFeedbackForm = {
    _count: FeedbackFormCountAggregateOutputType | null
    _avg: FeedbackFormAvgAggregateOutputType | null
    _sum: FeedbackFormSumAggregateOutputType | null
    _min: FeedbackFormMinAggregateOutputType | null
    _max: FeedbackFormMaxAggregateOutputType | null
  }

  export type FeedbackFormAvgAggregateOutputType = {
    id: number | null
    totalStudents: number | null
    accompanyingStaff: number | null
  }

  export type FeedbackFormSumAggregateOutputType = {
    id: number | null
    totalStudents: number | null
    accompanyingStaff: number | null
  }

  export type FeedbackFormMinAggregateOutputType = {
    id: number | null
    institutionName: string | null
    website: string | null
    visitDate: Date | null
    staffName: string | null
    staffEmail: string | null
    staffMobile: string | null
    totalStudents: number | null
    accompanyingStaff: number | null
    best: string | null
    worst: string | null
    suggestions: string | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackFormMaxAggregateOutputType = {
    id: number | null
    institutionName: string | null
    website: string | null
    visitDate: Date | null
    staffName: string | null
    staffEmail: string | null
    staffMobile: string | null
    totalStudents: number | null
    accompanyingStaff: number | null
    best: string | null
    worst: string | null
    suggestions: string | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackFormCountAggregateOutputType = {
    id: number
    institutionName: number
    website: number
    visitDate: number
    staffName: number
    staffEmail: number
    staffMobile: number
    totalStudents: number
    accompanyingStaff: number
    sources: number
    campuses: number
    best: number
    worst: number
    suggestions: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedbackFormAvgAggregateInputType = {
    id?: true
    totalStudents?: true
    accompanyingStaff?: true
  }

  export type FeedbackFormSumAggregateInputType = {
    id?: true
    totalStudents?: true
    accompanyingStaff?: true
  }

  export type FeedbackFormMinAggregateInputType = {
    id?: true
    institutionName?: true
    website?: true
    visitDate?: true
    staffName?: true
    staffEmail?: true
    staffMobile?: true
    totalStudents?: true
    accompanyingStaff?: true
    best?: true
    worst?: true
    suggestions?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackFormMaxAggregateInputType = {
    id?: true
    institutionName?: true
    website?: true
    visitDate?: true
    staffName?: true
    staffEmail?: true
    staffMobile?: true
    totalStudents?: true
    accompanyingStaff?: true
    best?: true
    worst?: true
    suggestions?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackFormCountAggregateInputType = {
    id?: true
    institutionName?: true
    website?: true
    visitDate?: true
    staffName?: true
    staffEmail?: true
    staffMobile?: true
    totalStudents?: true
    accompanyingStaff?: true
    sources?: true
    campuses?: true
    best?: true
    worst?: true
    suggestions?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedbackFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feedbackForm to aggregate.
     */
    where?: feedbackFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbackForms to fetch.
     */
    orderBy?: feedbackFormOrderByWithRelationInput | feedbackFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: feedbackFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbackForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbackForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feedbackForms
    **/
    _count?: true | FeedbackFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackFormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackFormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackFormMaxAggregateInputType
  }

  export type GetFeedbackFormAggregateType<T extends FeedbackFormAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbackForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbackForm[P]>
      : GetScalarType<T[P], AggregateFeedbackForm[P]>
  }




  export type feedbackFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feedbackFormWhereInput
    orderBy?: feedbackFormOrderByWithAggregationInput | feedbackFormOrderByWithAggregationInput[]
    by: FeedbackFormScalarFieldEnum[] | FeedbackFormScalarFieldEnum
    having?: feedbackFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackFormCountAggregateInputType | true
    _avg?: FeedbackFormAvgAggregateInputType
    _sum?: FeedbackFormSumAggregateInputType
    _min?: FeedbackFormMinAggregateInputType
    _max?: FeedbackFormMaxAggregateInputType
  }

  export type FeedbackFormGroupByOutputType = {
    id: number
    institutionName: string
    website: string
    visitDate: Date
    staffName: string
    staffEmail: string
    staffMobile: string
    totalStudents: number
    accompanyingStaff: number
    sources: string[]
    campuses: string[]
    best: string | null
    worst: string | null
    suggestions: string | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: FeedbackFormCountAggregateOutputType | null
    _avg: FeedbackFormAvgAggregateOutputType | null
    _sum: FeedbackFormSumAggregateOutputType | null
    _min: FeedbackFormMinAggregateOutputType | null
    _max: FeedbackFormMaxAggregateOutputType | null
  }

  type GetFeedbackFormGroupByPayload<T extends feedbackFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackFormGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackFormGroupByOutputType[P]>
        }
      >
    >


  export type feedbackFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionName?: boolean
    website?: boolean
    visitDate?: boolean
    staffName?: boolean
    staffEmail?: boolean
    staffMobile?: boolean
    totalStudents?: boolean
    accompanyingStaff?: boolean
    sources?: boolean
    campuses?: boolean
    best?: boolean
    worst?: boolean
    suggestions?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ratings?: boolean | feedbackForm$ratingsArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackForm"]>

  export type feedbackFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionName?: boolean
    website?: boolean
    visitDate?: boolean
    staffName?: boolean
    staffEmail?: boolean
    staffMobile?: boolean
    totalStudents?: boolean
    accompanyingStaff?: boolean
    sources?: boolean
    campuses?: boolean
    best?: boolean
    worst?: boolean
    suggestions?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feedbackForm"]>

  export type feedbackFormSelectScalar = {
    id?: boolean
    institutionName?: boolean
    website?: boolean
    visitDate?: boolean
    staffName?: boolean
    staffEmail?: boolean
    staffMobile?: boolean
    totalStudents?: boolean
    accompanyingStaff?: boolean
    sources?: boolean
    campuses?: boolean
    best?: boolean
    worst?: boolean
    suggestions?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type feedbackFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ratings?: boolean | feedbackForm$ratingsArgs<ExtArgs>
  }
  export type feedbackFormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $feedbackFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "feedbackForm"
    objects: {
      ratings: Prisma.$RatingsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      institutionName: string
      website: string
      visitDate: Date
      staffName: string
      staffEmail: string
      staffMobile: string
      totalStudents: number
      accompanyingStaff: number
      sources: string[]
      campuses: string[]
      best: string | null
      worst: string | null
      suggestions: string | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedbackForm"]>
    composites: {}
  }

  type feedbackFormGetPayload<S extends boolean | null | undefined | feedbackFormDefaultArgs> = $Result.GetResult<Prisma.$feedbackFormPayload, S>

  type feedbackFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<feedbackFormFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedbackFormCountAggregateInputType | true
    }

  export interface feedbackFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['feedbackForm'], meta: { name: 'feedbackForm' } }
    /**
     * Find zero or one FeedbackForm that matches the filter.
     * @param {feedbackFormFindUniqueArgs} args - Arguments to find a FeedbackForm
     * @example
     * // Get one FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends feedbackFormFindUniqueArgs>(args: SelectSubset<T, feedbackFormFindUniqueArgs<ExtArgs>>): Prisma__feedbackFormClient<$Result.GetResult<Prisma.$feedbackFormPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeedbackForm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {feedbackFormFindUniqueOrThrowArgs} args - Arguments to find a FeedbackForm
     * @example
     * // Get one FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends feedbackFormFindUniqueOrThrowArgs>(args: SelectSubset<T, feedbackFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__feedbackFormClient<$Result.GetResult<Prisma.$feedbackFormPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeedbackForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFormFindFirstArgs} args - Arguments to find a FeedbackForm
     * @example
     * // Get one FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends feedbackFormFindFirstArgs>(args?: SelectSubset<T, feedbackFormFindFirstArgs<ExtArgs>>): Prisma__feedbackFormClient<$Result.GetResult<Prisma.$feedbackFormPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeedbackForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFormFindFirstOrThrowArgs} args - Arguments to find a FeedbackForm
     * @example
     * // Get one FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends feedbackFormFindFirstOrThrowArgs>(args?: SelectSubset<T, feedbackFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__feedbackFormClient<$Result.GetResult<Prisma.$feedbackFormPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeedbackForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedbackForms
     * const feedbackForms = await prisma.feedbackForm.findMany()
     * 
     * // Get first 10 FeedbackForms
     * const feedbackForms = await prisma.feedbackForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackFormWithIdOnly = await prisma.feedbackForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends feedbackFormFindManyArgs>(args?: SelectSubset<T, feedbackFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbackFormPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeedbackForm.
     * @param {feedbackFormCreateArgs} args - Arguments to create a FeedbackForm.
     * @example
     * // Create one FeedbackForm
     * const FeedbackForm = await prisma.feedbackForm.create({
     *   data: {
     *     // ... data to create a FeedbackForm
     *   }
     * })
     * 
     */
    create<T extends feedbackFormCreateArgs>(args: SelectSubset<T, feedbackFormCreateArgs<ExtArgs>>): Prisma__feedbackFormClient<$Result.GetResult<Prisma.$feedbackFormPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeedbackForms.
     * @param {feedbackFormCreateManyArgs} args - Arguments to create many FeedbackForms.
     * @example
     * // Create many FeedbackForms
     * const feedbackForm = await prisma.feedbackForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends feedbackFormCreateManyArgs>(args?: SelectSubset<T, feedbackFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedbackForms and returns the data saved in the database.
     * @param {feedbackFormCreateManyAndReturnArgs} args - Arguments to create many FeedbackForms.
     * @example
     * // Create many FeedbackForms
     * const feedbackForm = await prisma.feedbackForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedbackForms and only return the `id`
     * const feedbackFormWithIdOnly = await prisma.feedbackForm.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends feedbackFormCreateManyAndReturnArgs>(args?: SelectSubset<T, feedbackFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbackFormPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeedbackForm.
     * @param {feedbackFormDeleteArgs} args - Arguments to delete one FeedbackForm.
     * @example
     * // Delete one FeedbackForm
     * const FeedbackForm = await prisma.feedbackForm.delete({
     *   where: {
     *     // ... filter to delete one FeedbackForm
     *   }
     * })
     * 
     */
    delete<T extends feedbackFormDeleteArgs>(args: SelectSubset<T, feedbackFormDeleteArgs<ExtArgs>>): Prisma__feedbackFormClient<$Result.GetResult<Prisma.$feedbackFormPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeedbackForm.
     * @param {feedbackFormUpdateArgs} args - Arguments to update one FeedbackForm.
     * @example
     * // Update one FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends feedbackFormUpdateArgs>(args: SelectSubset<T, feedbackFormUpdateArgs<ExtArgs>>): Prisma__feedbackFormClient<$Result.GetResult<Prisma.$feedbackFormPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeedbackForms.
     * @param {feedbackFormDeleteManyArgs} args - Arguments to filter FeedbackForms to delete.
     * @example
     * // Delete a few FeedbackForms
     * const { count } = await prisma.feedbackForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends feedbackFormDeleteManyArgs>(args?: SelectSubset<T, feedbackFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedbackForms
     * const feedbackForm = await prisma.feedbackForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends feedbackFormUpdateManyArgs>(args: SelectSubset<T, feedbackFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedbackForm.
     * @param {feedbackFormUpsertArgs} args - Arguments to update or create a FeedbackForm.
     * @example
     * // Update or create a FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.upsert({
     *   create: {
     *     // ... data to create a FeedbackForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedbackForm we want to update
     *   }
     * })
     */
    upsert<T extends feedbackFormUpsertArgs>(args: SelectSubset<T, feedbackFormUpsertArgs<ExtArgs>>): Prisma__feedbackFormClient<$Result.GetResult<Prisma.$feedbackFormPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeedbackForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFormCountArgs} args - Arguments to filter FeedbackForms to count.
     * @example
     * // Count the number of FeedbackForms
     * const count = await prisma.feedbackForm.count({
     *   where: {
     *     // ... the filter for the FeedbackForms we want to count
     *   }
     * })
    **/
    count<T extends feedbackFormCountArgs>(
      args?: Subset<T, feedbackFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedbackForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackFormAggregateArgs>(args: Subset<T, FeedbackFormAggregateArgs>): Prisma.PrismaPromise<GetFeedbackFormAggregateType<T>>

    /**
     * Group by FeedbackForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends feedbackFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: feedbackFormGroupByArgs['orderBy'] }
        : { orderBy?: feedbackFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, feedbackFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the feedbackForm model
   */
  readonly fields: feedbackFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for feedbackForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__feedbackFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ratings<T extends feedbackForm$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, feedbackForm$ratingsArgs<ExtArgs>>): Prisma__RatingsClient<$Result.GetResult<Prisma.$RatingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the feedbackForm model
   */ 
  interface feedbackFormFieldRefs {
    readonly id: FieldRef<"feedbackForm", 'Int'>
    readonly institutionName: FieldRef<"feedbackForm", 'String'>
    readonly website: FieldRef<"feedbackForm", 'String'>
    readonly visitDate: FieldRef<"feedbackForm", 'DateTime'>
    readonly staffName: FieldRef<"feedbackForm", 'String'>
    readonly staffEmail: FieldRef<"feedbackForm", 'String'>
    readonly staffMobile: FieldRef<"feedbackForm", 'String'>
    readonly totalStudents: FieldRef<"feedbackForm", 'Int'>
    readonly accompanyingStaff: FieldRef<"feedbackForm", 'Int'>
    readonly sources: FieldRef<"feedbackForm", 'String[]'>
    readonly campuses: FieldRef<"feedbackForm", 'String[]'>
    readonly best: FieldRef<"feedbackForm", 'String'>
    readonly worst: FieldRef<"feedbackForm", 'String'>
    readonly suggestions: FieldRef<"feedbackForm", 'String'>
    readonly comments: FieldRef<"feedbackForm", 'String'>
    readonly createdAt: FieldRef<"feedbackForm", 'DateTime'>
    readonly updatedAt: FieldRef<"feedbackForm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * feedbackForm findUnique
   */
  export type feedbackFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbackForm
     */
    select?: feedbackFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackFormInclude<ExtArgs> | null
    /**
     * Filter, which feedbackForm to fetch.
     */
    where: feedbackFormWhereUniqueInput
  }

  /**
   * feedbackForm findUniqueOrThrow
   */
  export type feedbackFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbackForm
     */
    select?: feedbackFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackFormInclude<ExtArgs> | null
    /**
     * Filter, which feedbackForm to fetch.
     */
    where: feedbackFormWhereUniqueInput
  }

  /**
   * feedbackForm findFirst
   */
  export type feedbackFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbackForm
     */
    select?: feedbackFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackFormInclude<ExtArgs> | null
    /**
     * Filter, which feedbackForm to fetch.
     */
    where?: feedbackFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbackForms to fetch.
     */
    orderBy?: feedbackFormOrderByWithRelationInput | feedbackFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feedbackForms.
     */
    cursor?: feedbackFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbackForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbackForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feedbackForms.
     */
    distinct?: FeedbackFormScalarFieldEnum | FeedbackFormScalarFieldEnum[]
  }

  /**
   * feedbackForm findFirstOrThrow
   */
  export type feedbackFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbackForm
     */
    select?: feedbackFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackFormInclude<ExtArgs> | null
    /**
     * Filter, which feedbackForm to fetch.
     */
    where?: feedbackFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbackForms to fetch.
     */
    orderBy?: feedbackFormOrderByWithRelationInput | feedbackFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feedbackForms.
     */
    cursor?: feedbackFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbackForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbackForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feedbackForms.
     */
    distinct?: FeedbackFormScalarFieldEnum | FeedbackFormScalarFieldEnum[]
  }

  /**
   * feedbackForm findMany
   */
  export type feedbackFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbackForm
     */
    select?: feedbackFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackFormInclude<ExtArgs> | null
    /**
     * Filter, which feedbackForms to fetch.
     */
    where?: feedbackFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbackForms to fetch.
     */
    orderBy?: feedbackFormOrderByWithRelationInput | feedbackFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feedbackForms.
     */
    cursor?: feedbackFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbackForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbackForms.
     */
    skip?: number
    distinct?: FeedbackFormScalarFieldEnum | FeedbackFormScalarFieldEnum[]
  }

  /**
   * feedbackForm create
   */
  export type feedbackFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbackForm
     */
    select?: feedbackFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackFormInclude<ExtArgs> | null
    /**
     * The data needed to create a feedbackForm.
     */
    data: XOR<feedbackFormCreateInput, feedbackFormUncheckedCreateInput>
  }

  /**
   * feedbackForm createMany
   */
  export type feedbackFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many feedbackForms.
     */
    data: feedbackFormCreateManyInput | feedbackFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * feedbackForm createManyAndReturn
   */
  export type feedbackFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbackForm
     */
    select?: feedbackFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many feedbackForms.
     */
    data: feedbackFormCreateManyInput | feedbackFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * feedbackForm update
   */
  export type feedbackFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbackForm
     */
    select?: feedbackFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackFormInclude<ExtArgs> | null
    /**
     * The data needed to update a feedbackForm.
     */
    data: XOR<feedbackFormUpdateInput, feedbackFormUncheckedUpdateInput>
    /**
     * Choose, which feedbackForm to update.
     */
    where: feedbackFormWhereUniqueInput
  }

  /**
   * feedbackForm updateMany
   */
  export type feedbackFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update feedbackForms.
     */
    data: XOR<feedbackFormUpdateManyMutationInput, feedbackFormUncheckedUpdateManyInput>
    /**
     * Filter which feedbackForms to update
     */
    where?: feedbackFormWhereInput
  }

  /**
   * feedbackForm upsert
   */
  export type feedbackFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbackForm
     */
    select?: feedbackFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackFormInclude<ExtArgs> | null
    /**
     * The filter to search for the feedbackForm to update in case it exists.
     */
    where: feedbackFormWhereUniqueInput
    /**
     * In case the feedbackForm found by the `where` argument doesn't exist, create a new feedbackForm with this data.
     */
    create: XOR<feedbackFormCreateInput, feedbackFormUncheckedCreateInput>
    /**
     * In case the feedbackForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<feedbackFormUpdateInput, feedbackFormUncheckedUpdateInput>
  }

  /**
   * feedbackForm delete
   */
  export type feedbackFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbackForm
     */
    select?: feedbackFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackFormInclude<ExtArgs> | null
    /**
     * Filter which feedbackForm to delete.
     */
    where: feedbackFormWhereUniqueInput
  }

  /**
   * feedbackForm deleteMany
   */
  export type feedbackFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feedbackForms to delete
     */
    where?: feedbackFormWhereInput
  }

  /**
   * feedbackForm.ratings
   */
  export type feedbackForm$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ratings
     */
    select?: RatingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingsInclude<ExtArgs> | null
    where?: RatingsWhereInput
  }

  /**
   * feedbackForm without action
   */
  export type feedbackFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbackForm
     */
    select?: feedbackFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackFormInclude<ExtArgs> | null
  }


  /**
   * Model Visitor
   */

  export type AggregateVisitor = {
    _count: VisitorCountAggregateOutputType | null
    _avg: VisitorAvgAggregateOutputType | null
    _sum: VisitorSumAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  export type VisitorAvgAggregateOutputType = {
    id: number | null
    studentSem: number | null
    numStudents: number | null
    numFaculty: number | null
  }

  export type VisitorSumAggregateOutputType = {
    id: number | null
    studentSem: number | null
    numStudents: number | null
    numFaculty: number | null
  }

  export type VisitorMinAggregateOutputType = {
    id: number | null
    institutionName: string | null
    studentBranch: string | null
    studentSem: number | null
    numStudents: number | null
    numFaculty: number | null
    name: string | null
    position: string | null
    email: string | null
    mobile: string | null
    ipr_time: string | null
    fcipt_time: string | null
    visit_date: Date | null
    visit_time: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitorMaxAggregateOutputType = {
    id: number | null
    institutionName: string | null
    studentBranch: string | null
    studentSem: number | null
    numStudents: number | null
    numFaculty: number | null
    name: string | null
    position: string | null
    email: string | null
    mobile: string | null
    ipr_time: string | null
    fcipt_time: string | null
    visit_date: Date | null
    visit_time: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitorCountAggregateOutputType = {
    id: number
    institutionName: number
    studentBranch: number
    studentSem: number
    numStudents: number
    numFaculty: number
    name: number
    position: number
    email: number
    mobile: number
    campus: number
    ipr_time: number
    fcipt_time: number
    visit_date: number
    visit_time: number
    materials: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitorAvgAggregateInputType = {
    id?: true
    studentSem?: true
    numStudents?: true
    numFaculty?: true
  }

  export type VisitorSumAggregateInputType = {
    id?: true
    studentSem?: true
    numStudents?: true
    numFaculty?: true
  }

  export type VisitorMinAggregateInputType = {
    id?: true
    institutionName?: true
    studentBranch?: true
    studentSem?: true
    numStudents?: true
    numFaculty?: true
    name?: true
    position?: true
    email?: true
    mobile?: true
    ipr_time?: true
    fcipt_time?: true
    visit_date?: true
    visit_time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitorMaxAggregateInputType = {
    id?: true
    institutionName?: true
    studentBranch?: true
    studentSem?: true
    numStudents?: true
    numFaculty?: true
    name?: true
    position?: true
    email?: true
    mobile?: true
    ipr_time?: true
    fcipt_time?: true
    visit_date?: true
    visit_time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitorCountAggregateInputType = {
    id?: true
    institutionName?: true
    studentBranch?: true
    studentSem?: true
    numStudents?: true
    numFaculty?: true
    name?: true
    position?: true
    email?: true
    mobile?: true
    campus?: true
    ipr_time?: true
    fcipt_time?: true
    visit_date?: true
    visit_time?: true
    materials?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitor to aggregate.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visitors
    **/
    _count?: true | VisitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitorMaxAggregateInputType
  }

  export type GetVisitorAggregateType<T extends VisitorAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitor[P]>
      : GetScalarType<T[P], AggregateVisitor[P]>
  }




  export type VisitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithAggregationInput | VisitorOrderByWithAggregationInput[]
    by: VisitorScalarFieldEnum[] | VisitorScalarFieldEnum
    having?: VisitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitorCountAggregateInputType | true
    _avg?: VisitorAvgAggregateInputType
    _sum?: VisitorSumAggregateInputType
    _min?: VisitorMinAggregateInputType
    _max?: VisitorMaxAggregateInputType
  }

  export type VisitorGroupByOutputType = {
    id: number
    institutionName: string
    studentBranch: string
    studentSem: number
    numStudents: number
    numFaculty: number
    name: string
    position: string
    email: string
    mobile: string
    campus: string[]
    ipr_time: string | null
    fcipt_time: string | null
    visit_date: Date
    visit_time: string
    materials: string[]
    createdAt: Date
    updatedAt: Date
    _count: VisitorCountAggregateOutputType | null
    _avg: VisitorAvgAggregateOutputType | null
    _sum: VisitorSumAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  type GetVisitorGroupByPayload<T extends VisitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitorGroupByOutputType[P]>
            : GetScalarType<T[P], VisitorGroupByOutputType[P]>
        }
      >
    >


  export type VisitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionName?: boolean
    studentBranch?: boolean
    studentSem?: boolean
    numStudents?: boolean
    numFaculty?: boolean
    name?: boolean
    position?: boolean
    email?: boolean
    mobile?: boolean
    campus?: boolean
    ipr_time?: boolean
    fcipt_time?: boolean
    visit_date?: boolean
    visit_time?: boolean
    materials?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["visitor"]>

  export type VisitorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionName?: boolean
    studentBranch?: boolean
    studentSem?: boolean
    numStudents?: boolean
    numFaculty?: boolean
    name?: boolean
    position?: boolean
    email?: boolean
    mobile?: boolean
    campus?: boolean
    ipr_time?: boolean
    fcipt_time?: boolean
    visit_date?: boolean
    visit_time?: boolean
    materials?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["visitor"]>

  export type VisitorSelectScalar = {
    id?: boolean
    institutionName?: boolean
    studentBranch?: boolean
    studentSem?: boolean
    numStudents?: boolean
    numFaculty?: boolean
    name?: boolean
    position?: boolean
    email?: boolean
    mobile?: boolean
    campus?: boolean
    ipr_time?: boolean
    fcipt_time?: boolean
    visit_date?: boolean
    visit_time?: boolean
    materials?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $VisitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visitor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      institutionName: string
      studentBranch: string
      studentSem: number
      numStudents: number
      numFaculty: number
      name: string
      position: string
      email: string
      mobile: string
      campus: string[]
      ipr_time: string | null
      fcipt_time: string | null
      visit_date: Date
      visit_time: string
      materials: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visitor"]>
    composites: {}
  }

  type VisitorGetPayload<S extends boolean | null | undefined | VisitorDefaultArgs> = $Result.GetResult<Prisma.$VisitorPayload, S>

  type VisitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitorCountAggregateInputType | true
    }

  export interface VisitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visitor'], meta: { name: 'Visitor' } }
    /**
     * Find zero or one Visitor that matches the filter.
     * @param {VisitorFindUniqueArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitorFindUniqueArgs>(args: SelectSubset<T, VisitorFindUniqueArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Visitor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitorFindUniqueOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitorFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Visitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitorFindFirstArgs>(args?: SelectSubset<T, VisitorFindFirstArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Visitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitorFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Visitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitors
     * const visitors = await prisma.visitor.findMany()
     * 
     * // Get first 10 Visitors
     * const visitors = await prisma.visitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitorWithIdOnly = await prisma.visitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitorFindManyArgs>(args?: SelectSubset<T, VisitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Visitor.
     * @param {VisitorCreateArgs} args - Arguments to create a Visitor.
     * @example
     * // Create one Visitor
     * const Visitor = await prisma.visitor.create({
     *   data: {
     *     // ... data to create a Visitor
     *   }
     * })
     * 
     */
    create<T extends VisitorCreateArgs>(args: SelectSubset<T, VisitorCreateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Visitors.
     * @param {VisitorCreateManyArgs} args - Arguments to create many Visitors.
     * @example
     * // Create many Visitors
     * const visitor = await prisma.visitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitorCreateManyArgs>(args?: SelectSubset<T, VisitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Visitors and returns the data saved in the database.
     * @param {VisitorCreateManyAndReturnArgs} args - Arguments to create many Visitors.
     * @example
     * // Create many Visitors
     * const visitor = await prisma.visitor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Visitors and only return the `id`
     * const visitorWithIdOnly = await prisma.visitor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitorCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Visitor.
     * @param {VisitorDeleteArgs} args - Arguments to delete one Visitor.
     * @example
     * // Delete one Visitor
     * const Visitor = await prisma.visitor.delete({
     *   where: {
     *     // ... filter to delete one Visitor
     *   }
     * })
     * 
     */
    delete<T extends VisitorDeleteArgs>(args: SelectSubset<T, VisitorDeleteArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Visitor.
     * @param {VisitorUpdateArgs} args - Arguments to update one Visitor.
     * @example
     * // Update one Visitor
     * const visitor = await prisma.visitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitorUpdateArgs>(args: SelectSubset<T, VisitorUpdateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Visitors.
     * @param {VisitorDeleteManyArgs} args - Arguments to filter Visitors to delete.
     * @example
     * // Delete a few Visitors
     * const { count } = await prisma.visitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitorDeleteManyArgs>(args?: SelectSubset<T, VisitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitors
     * const visitor = await prisma.visitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitorUpdateManyArgs>(args: SelectSubset<T, VisitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visitor.
     * @param {VisitorUpsertArgs} args - Arguments to update or create a Visitor.
     * @example
     * // Update or create a Visitor
     * const visitor = await prisma.visitor.upsert({
     *   create: {
     *     // ... data to create a Visitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitor we want to update
     *   }
     * })
     */
    upsert<T extends VisitorUpsertArgs>(args: SelectSubset<T, VisitorUpsertArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorCountArgs} args - Arguments to filter Visitors to count.
     * @example
     * // Count the number of Visitors
     * const count = await prisma.visitor.count({
     *   where: {
     *     // ... the filter for the Visitors we want to count
     *   }
     * })
    **/
    count<T extends VisitorCountArgs>(
      args?: Subset<T, VisitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitorAggregateArgs>(args: Subset<T, VisitorAggregateArgs>): Prisma.PrismaPromise<GetVisitorAggregateType<T>>

    /**
     * Group by Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitorGroupByArgs['orderBy'] }
        : { orderBy?: VisitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visitor model
   */
  readonly fields: VisitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visitor model
   */ 
  interface VisitorFieldRefs {
    readonly id: FieldRef<"Visitor", 'Int'>
    readonly institutionName: FieldRef<"Visitor", 'String'>
    readonly studentBranch: FieldRef<"Visitor", 'String'>
    readonly studentSem: FieldRef<"Visitor", 'Int'>
    readonly numStudents: FieldRef<"Visitor", 'Int'>
    readonly numFaculty: FieldRef<"Visitor", 'Int'>
    readonly name: FieldRef<"Visitor", 'String'>
    readonly position: FieldRef<"Visitor", 'String'>
    readonly email: FieldRef<"Visitor", 'String'>
    readonly mobile: FieldRef<"Visitor", 'String'>
    readonly campus: FieldRef<"Visitor", 'String[]'>
    readonly ipr_time: FieldRef<"Visitor", 'String'>
    readonly fcipt_time: FieldRef<"Visitor", 'String'>
    readonly visit_date: FieldRef<"Visitor", 'DateTime'>
    readonly visit_time: FieldRef<"Visitor", 'String'>
    readonly materials: FieldRef<"Visitor", 'String[]'>
    readonly createdAt: FieldRef<"Visitor", 'DateTime'>
    readonly updatedAt: FieldRef<"Visitor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Visitor findUnique
   */
  export type VisitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findUniqueOrThrow
   */
  export type VisitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findFirst
   */
  export type VisitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findFirstOrThrow
   */
  export type VisitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findMany
   */
  export type VisitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter, which Visitors to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor create
   */
  export type VisitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * The data needed to create a Visitor.
     */
    data: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
  }

  /**
   * Visitor createMany
   */
  export type VisitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visitors.
     */
    data: VisitorCreateManyInput | VisitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visitor createManyAndReturn
   */
  export type VisitorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Visitors.
     */
    data: VisitorCreateManyInput | VisitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visitor update
   */
  export type VisitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * The data needed to update a Visitor.
     */
    data: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
    /**
     * Choose, which Visitor to update.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor updateMany
   */
  export type VisitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visitors.
     */
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyInput>
    /**
     * Filter which Visitors to update
     */
    where?: VisitorWhereInput
  }

  /**
   * Visitor upsert
   */
  export type VisitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * The filter to search for the Visitor to update in case it exists.
     */
    where: VisitorWhereUniqueInput
    /**
     * In case the Visitor found by the `where` argument doesn't exist, create a new Visitor with this data.
     */
    create: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
    /**
     * In case the Visitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
  }

  /**
   * Visitor delete
   */
  export type VisitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Filter which Visitor to delete.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor deleteMany
   */
  export type VisitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitors to delete
     */
    where?: VisitorWhereInput
  }

  /**
   * Visitor without action
   */
  export type VisitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolAvgAggregateOutputType = {
    id: number | null
  }

  export type SchoolSumAggregateOutputType = {
    id: number | null
  }

  export type SchoolMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    city: string | null
    pincode: string | null
    affiliationNumber: string | null
    coordinatorTeacherName: string | null
    coordinatorTeacherMobile: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    city: string | null
    pincode: string | null
    affiliationNumber: string | null
    coordinatorTeacherName: string | null
    coordinatorTeacherMobile: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    pincode: number
    affiliationNumber: number
    coordinatorTeacherName: number
    coordinatorTeacherMobile: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolAvgAggregateInputType = {
    id?: true
  }

  export type SchoolSumAggregateInputType = {
    id?: true
  }

  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    pincode?: true
    affiliationNumber?: true
    coordinatorTeacherName?: true
    coordinatorTeacherMobile?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    pincode?: true
    affiliationNumber?: true
    coordinatorTeacherName?: true
    coordinatorTeacherMobile?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    pincode?: true
    affiliationNumber?: true
    coordinatorTeacherName?: true
    coordinatorTeacherMobile?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _avg?: SchoolAvgAggregateInputType
    _sum?: SchoolSumAggregateInputType
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    pincode?: boolean
    affiliationNumber?: boolean
    coordinatorTeacherName?: boolean
    coordinatorTeacherMobile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accompanyingTeachers?: boolean | School$accompanyingTeachersArgs<ExtArgs>
    competitions?: boolean | School$competitionsArgs<ExtArgs>
    StudentModel1?: boolean | School$StudentModel1Args<ExtArgs>
    StudentModel2?: boolean | School$StudentModel2Args<ExtArgs>
    EloquenceEnglish?: boolean | School$EloquenceEnglishArgs<ExtArgs>
    EloquenceHindi?: boolean | School$EloquenceHindiArgs<ExtArgs>
    EloquenceGujarati?: boolean | School$EloquenceGujaratiArgs<ExtArgs>
    EssayEnglish?: boolean | School$EssayEnglishArgs<ExtArgs>
    EssayHindi?: boolean | School$EssayHindiArgs<ExtArgs>
    EssayGujarati?: boolean | School$EssayGujaratiArgs<ExtArgs>
    Poster?: boolean | School$PosterArgs<ExtArgs>
    Skit?: boolean | School$SkitArgs<ExtArgs>
    TeacherModel?: boolean | School$TeacherModelArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    pincode?: boolean
    affiliationNumber?: boolean
    coordinatorTeacherName?: boolean
    coordinatorTeacherMobile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    pincode?: boolean
    affiliationNumber?: boolean
    coordinatorTeacherName?: boolean
    coordinatorTeacherMobile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompanyingTeachers?: boolean | School$accompanyingTeachersArgs<ExtArgs>
    competitions?: boolean | School$competitionsArgs<ExtArgs>
    StudentModel1?: boolean | School$StudentModel1Args<ExtArgs>
    StudentModel2?: boolean | School$StudentModel2Args<ExtArgs>
    EloquenceEnglish?: boolean | School$EloquenceEnglishArgs<ExtArgs>
    EloquenceHindi?: boolean | School$EloquenceHindiArgs<ExtArgs>
    EloquenceGujarati?: boolean | School$EloquenceGujaratiArgs<ExtArgs>
    EssayEnglish?: boolean | School$EssayEnglishArgs<ExtArgs>
    EssayHindi?: boolean | School$EssayHindiArgs<ExtArgs>
    EssayGujarati?: boolean | School$EssayGujaratiArgs<ExtArgs>
    Poster?: boolean | School$PosterArgs<ExtArgs>
    Skit?: boolean | School$SkitArgs<ExtArgs>
    TeacherModel?: boolean | School$TeacherModelArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      accompanyingTeachers: Prisma.$AccompanyingTeacherPayload<ExtArgs>[]
      competitions: Prisma.$CompetitionPayload<ExtArgs>[]
      StudentModel1: Prisma.$StudentModel1Payload<ExtArgs>[]
      StudentModel2: Prisma.$StudentModel2Payload<ExtArgs>[]
      EloquenceEnglish: Prisma.$EloquenceEnglishPayload<ExtArgs>[]
      EloquenceHindi: Prisma.$EloquenceHindiPayload<ExtArgs>[]
      EloquenceGujarati: Prisma.$EloquenceGujaratiPayload<ExtArgs>[]
      EssayEnglish: Prisma.$EssayEnglishPayload<ExtArgs>[]
      EssayHindi: Prisma.$EssayHindiPayload<ExtArgs>[]
      EssayGujarati: Prisma.$EssayGujaratiPayload<ExtArgs>[]
      Poster: Prisma.$PosterPayload<ExtArgs>[]
      Skit: Prisma.$SkitPayload<ExtArgs>[]
      TeacherModel: Prisma.$TeacherModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string
      city: string
      pincode: string
      affiliationNumber: string
      coordinatorTeacherName: string
      coordinatorTeacherMobile: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accompanyingTeachers<T extends School$accompanyingTeachersArgs<ExtArgs> = {}>(args?: Subset<T, School$accompanyingTeachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanyingTeacherPayload<ExtArgs>, T, "findMany"> | Null>
    competitions<T extends School$competitionsArgs<ExtArgs> = {}>(args?: Subset<T, School$competitionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetitionPayload<ExtArgs>, T, "findMany"> | Null>
    StudentModel1<T extends School$StudentModel1Args<ExtArgs> = {}>(args?: Subset<T, School$StudentModel1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentModel1Payload<ExtArgs>, T, "findMany"> | Null>
    StudentModel2<T extends School$StudentModel2Args<ExtArgs> = {}>(args?: Subset<T, School$StudentModel2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentModel2Payload<ExtArgs>, T, "findMany"> | Null>
    EloquenceEnglish<T extends School$EloquenceEnglishArgs<ExtArgs> = {}>(args?: Subset<T, School$EloquenceEnglishArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EloquenceEnglishPayload<ExtArgs>, T, "findMany"> | Null>
    EloquenceHindi<T extends School$EloquenceHindiArgs<ExtArgs> = {}>(args?: Subset<T, School$EloquenceHindiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EloquenceHindiPayload<ExtArgs>, T, "findMany"> | Null>
    EloquenceGujarati<T extends School$EloquenceGujaratiArgs<ExtArgs> = {}>(args?: Subset<T, School$EloquenceGujaratiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EloquenceGujaratiPayload<ExtArgs>, T, "findMany"> | Null>
    EssayEnglish<T extends School$EssayEnglishArgs<ExtArgs> = {}>(args?: Subset<T, School$EssayEnglishArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EssayEnglishPayload<ExtArgs>, T, "findMany"> | Null>
    EssayHindi<T extends School$EssayHindiArgs<ExtArgs> = {}>(args?: Subset<T, School$EssayHindiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EssayHindiPayload<ExtArgs>, T, "findMany"> | Null>
    EssayGujarati<T extends School$EssayGujaratiArgs<ExtArgs> = {}>(args?: Subset<T, School$EssayGujaratiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EssayGujaratiPayload<ExtArgs>, T, "findMany"> | Null>
    Poster<T extends School$PosterArgs<ExtArgs> = {}>(args?: Subset<T, School$PosterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosterPayload<ExtArgs>, T, "findMany"> | Null>
    Skit<T extends School$SkitArgs<ExtArgs> = {}>(args?: Subset<T, School$SkitArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkitPayload<ExtArgs>, T, "findMany"> | Null>
    TeacherModel<T extends School$TeacherModelArgs<ExtArgs> = {}>(args?: Subset<T, School$TeacherModelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherModelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */ 
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'Int'>
    readonly name: FieldRef<"School", 'String'>
    readonly address: FieldRef<"School", 'String'>
    readonly city: FieldRef<"School", 'String'>
    readonly pincode: FieldRef<"School", 'String'>
    readonly affiliationNumber: FieldRef<"School", 'String'>
    readonly coordinatorTeacherName: FieldRef<"School", 'String'>
    readonly coordinatorTeacherMobile: FieldRef<"School", 'String'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
  }

  /**
   * School.accompanyingTeachers
   */
  export type School$accompanyingTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherInclude<ExtArgs> | null
    where?: AccompanyingTeacherWhereInput
    orderBy?: AccompanyingTeacherOrderByWithRelationInput | AccompanyingTeacherOrderByWithRelationInput[]
    cursor?: AccompanyingTeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccompanyingTeacherScalarFieldEnum | AccompanyingTeacherScalarFieldEnum[]
  }

  /**
   * School.competitions
   */
  export type School$competitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionInclude<ExtArgs> | null
    where?: CompetitionWhereInput
    orderBy?: CompetitionOrderByWithRelationInput | CompetitionOrderByWithRelationInput[]
    cursor?: CompetitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompetitionScalarFieldEnum | CompetitionScalarFieldEnum[]
  }

  /**
   * School.StudentModel1
   */
  export type School$StudentModel1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1Include<ExtArgs> | null
    where?: StudentModel1WhereInput
    orderBy?: StudentModel1OrderByWithRelationInput | StudentModel1OrderByWithRelationInput[]
    cursor?: StudentModel1WhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentModel1ScalarFieldEnum | StudentModel1ScalarFieldEnum[]
  }

  /**
   * School.StudentModel2
   */
  export type School$StudentModel2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2Include<ExtArgs> | null
    where?: StudentModel2WhereInput
    orderBy?: StudentModel2OrderByWithRelationInput | StudentModel2OrderByWithRelationInput[]
    cursor?: StudentModel2WhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentModel2ScalarFieldEnum | StudentModel2ScalarFieldEnum[]
  }

  /**
   * School.EloquenceEnglish
   */
  export type School$EloquenceEnglishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishInclude<ExtArgs> | null
    where?: EloquenceEnglishWhereInput
    orderBy?: EloquenceEnglishOrderByWithRelationInput | EloquenceEnglishOrderByWithRelationInput[]
    cursor?: EloquenceEnglishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EloquenceEnglishScalarFieldEnum | EloquenceEnglishScalarFieldEnum[]
  }

  /**
   * School.EloquenceHindi
   */
  export type School$EloquenceHindiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiInclude<ExtArgs> | null
    where?: EloquenceHindiWhereInput
    orderBy?: EloquenceHindiOrderByWithRelationInput | EloquenceHindiOrderByWithRelationInput[]
    cursor?: EloquenceHindiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EloquenceHindiScalarFieldEnum | EloquenceHindiScalarFieldEnum[]
  }

  /**
   * School.EloquenceGujarati
   */
  export type School$EloquenceGujaratiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiInclude<ExtArgs> | null
    where?: EloquenceGujaratiWhereInput
    orderBy?: EloquenceGujaratiOrderByWithRelationInput | EloquenceGujaratiOrderByWithRelationInput[]
    cursor?: EloquenceGujaratiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EloquenceGujaratiScalarFieldEnum | EloquenceGujaratiScalarFieldEnum[]
  }

  /**
   * School.EssayEnglish
   */
  export type School$EssayEnglishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishInclude<ExtArgs> | null
    where?: EssayEnglishWhereInput
    orderBy?: EssayEnglishOrderByWithRelationInput | EssayEnglishOrderByWithRelationInput[]
    cursor?: EssayEnglishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EssayEnglishScalarFieldEnum | EssayEnglishScalarFieldEnum[]
  }

  /**
   * School.EssayHindi
   */
  export type School$EssayHindiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiInclude<ExtArgs> | null
    where?: EssayHindiWhereInput
    orderBy?: EssayHindiOrderByWithRelationInput | EssayHindiOrderByWithRelationInput[]
    cursor?: EssayHindiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EssayHindiScalarFieldEnum | EssayHindiScalarFieldEnum[]
  }

  /**
   * School.EssayGujarati
   */
  export type School$EssayGujaratiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiInclude<ExtArgs> | null
    where?: EssayGujaratiWhereInput
    orderBy?: EssayGujaratiOrderByWithRelationInput | EssayGujaratiOrderByWithRelationInput[]
    cursor?: EssayGujaratiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EssayGujaratiScalarFieldEnum | EssayGujaratiScalarFieldEnum[]
  }

  /**
   * School.Poster
   */
  export type School$PosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterInclude<ExtArgs> | null
    where?: PosterWhereInput
    orderBy?: PosterOrderByWithRelationInput | PosterOrderByWithRelationInput[]
    cursor?: PosterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosterScalarFieldEnum | PosterScalarFieldEnum[]
  }

  /**
   * School.Skit
   */
  export type School$SkitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitInclude<ExtArgs> | null
    where?: SkitWhereInput
    orderBy?: SkitOrderByWithRelationInput | SkitOrderByWithRelationInput[]
    cursor?: SkitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkitScalarFieldEnum | SkitScalarFieldEnum[]
  }

  /**
   * School.TeacherModel
   */
  export type School$TeacherModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelInclude<ExtArgs> | null
    where?: TeacherModelWhereInput
    orderBy?: TeacherModelOrderByWithRelationInput | TeacherModelOrderByWithRelationInput[]
    cursor?: TeacherModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherModelScalarFieldEnum | TeacherModelScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model AccompanyingTeacher
   */

  export type AggregateAccompanyingTeacher = {
    _count: AccompanyingTeacherCountAggregateOutputType | null
    _avg: AccompanyingTeacherAvgAggregateOutputType | null
    _sum: AccompanyingTeacherSumAggregateOutputType | null
    _min: AccompanyingTeacherMinAggregateOutputType | null
    _max: AccompanyingTeacherMaxAggregateOutputType | null
  }

  export type AccompanyingTeacherAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type AccompanyingTeacherSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type AccompanyingTeacherMinAggregateOutputType = {
    id: number | null
    name: string | null
    gender: string | null
    requiresAccommodation: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccompanyingTeacherMaxAggregateOutputType = {
    id: number | null
    name: string | null
    gender: string | null
    requiresAccommodation: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccompanyingTeacherCountAggregateOutputType = {
    id: number
    name: number
    gender: number
    requiresAccommodation: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccompanyingTeacherAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type AccompanyingTeacherSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type AccompanyingTeacherMinAggregateInputType = {
    id?: true
    name?: true
    gender?: true
    requiresAccommodation?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccompanyingTeacherMaxAggregateInputType = {
    id?: true
    name?: true
    gender?: true
    requiresAccommodation?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccompanyingTeacherCountAggregateInputType = {
    id?: true
    name?: true
    gender?: true
    requiresAccommodation?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccompanyingTeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccompanyingTeacher to aggregate.
     */
    where?: AccompanyingTeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccompanyingTeachers to fetch.
     */
    orderBy?: AccompanyingTeacherOrderByWithRelationInput | AccompanyingTeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccompanyingTeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccompanyingTeachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccompanyingTeachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccompanyingTeachers
    **/
    _count?: true | AccompanyingTeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccompanyingTeacherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccompanyingTeacherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccompanyingTeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccompanyingTeacherMaxAggregateInputType
  }

  export type GetAccompanyingTeacherAggregateType<T extends AccompanyingTeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateAccompanyingTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccompanyingTeacher[P]>
      : GetScalarType<T[P], AggregateAccompanyingTeacher[P]>
  }




  export type AccompanyingTeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccompanyingTeacherWhereInput
    orderBy?: AccompanyingTeacherOrderByWithAggregationInput | AccompanyingTeacherOrderByWithAggregationInput[]
    by: AccompanyingTeacherScalarFieldEnum[] | AccompanyingTeacherScalarFieldEnum
    having?: AccompanyingTeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccompanyingTeacherCountAggregateInputType | true
    _avg?: AccompanyingTeacherAvgAggregateInputType
    _sum?: AccompanyingTeacherSumAggregateInputType
    _min?: AccompanyingTeacherMinAggregateInputType
    _max?: AccompanyingTeacherMaxAggregateInputType
  }

  export type AccompanyingTeacherGroupByOutputType = {
    id: number
    name: string
    gender: string
    requiresAccommodation: boolean
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: AccompanyingTeacherCountAggregateOutputType | null
    _avg: AccompanyingTeacherAvgAggregateOutputType | null
    _sum: AccompanyingTeacherSumAggregateOutputType | null
    _min: AccompanyingTeacherMinAggregateOutputType | null
    _max: AccompanyingTeacherMaxAggregateOutputType | null
  }

  type GetAccompanyingTeacherGroupByPayload<T extends AccompanyingTeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccompanyingTeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccompanyingTeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccompanyingTeacherGroupByOutputType[P]>
            : GetScalarType<T[P], AccompanyingTeacherGroupByOutputType[P]>
        }
      >
    >


  export type AccompanyingTeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gender?: boolean
    requiresAccommodation?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accompanyingTeacher"]>

  export type AccompanyingTeacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gender?: boolean
    requiresAccommodation?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accompanyingTeacher"]>

  export type AccompanyingTeacherSelectScalar = {
    id?: boolean
    name?: boolean
    gender?: boolean
    requiresAccommodation?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccompanyingTeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type AccompanyingTeacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $AccompanyingTeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccompanyingTeacher"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      gender: string
      requiresAccommodation: boolean
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accompanyingTeacher"]>
    composites: {}
  }

  type AccompanyingTeacherGetPayload<S extends boolean | null | undefined | AccompanyingTeacherDefaultArgs> = $Result.GetResult<Prisma.$AccompanyingTeacherPayload, S>

  type AccompanyingTeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccompanyingTeacherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccompanyingTeacherCountAggregateInputType | true
    }

  export interface AccompanyingTeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccompanyingTeacher'], meta: { name: 'AccompanyingTeacher' } }
    /**
     * Find zero or one AccompanyingTeacher that matches the filter.
     * @param {AccompanyingTeacherFindUniqueArgs} args - Arguments to find a AccompanyingTeacher
     * @example
     * // Get one AccompanyingTeacher
     * const accompanyingTeacher = await prisma.accompanyingTeacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccompanyingTeacherFindUniqueArgs>(args: SelectSubset<T, AccompanyingTeacherFindUniqueArgs<ExtArgs>>): Prisma__AccompanyingTeacherClient<$Result.GetResult<Prisma.$AccompanyingTeacherPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccompanyingTeacher that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccompanyingTeacherFindUniqueOrThrowArgs} args - Arguments to find a AccompanyingTeacher
     * @example
     * // Get one AccompanyingTeacher
     * const accompanyingTeacher = await prisma.accompanyingTeacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccompanyingTeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, AccompanyingTeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccompanyingTeacherClient<$Result.GetResult<Prisma.$AccompanyingTeacherPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccompanyingTeacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanyingTeacherFindFirstArgs} args - Arguments to find a AccompanyingTeacher
     * @example
     * // Get one AccompanyingTeacher
     * const accompanyingTeacher = await prisma.accompanyingTeacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccompanyingTeacherFindFirstArgs>(args?: SelectSubset<T, AccompanyingTeacherFindFirstArgs<ExtArgs>>): Prisma__AccompanyingTeacherClient<$Result.GetResult<Prisma.$AccompanyingTeacherPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccompanyingTeacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanyingTeacherFindFirstOrThrowArgs} args - Arguments to find a AccompanyingTeacher
     * @example
     * // Get one AccompanyingTeacher
     * const accompanyingTeacher = await prisma.accompanyingTeacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccompanyingTeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, AccompanyingTeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccompanyingTeacherClient<$Result.GetResult<Prisma.$AccompanyingTeacherPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccompanyingTeachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanyingTeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccompanyingTeachers
     * const accompanyingTeachers = await prisma.accompanyingTeacher.findMany()
     * 
     * // Get first 10 AccompanyingTeachers
     * const accompanyingTeachers = await prisma.accompanyingTeacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accompanyingTeacherWithIdOnly = await prisma.accompanyingTeacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccompanyingTeacherFindManyArgs>(args?: SelectSubset<T, AccompanyingTeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanyingTeacherPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccompanyingTeacher.
     * @param {AccompanyingTeacherCreateArgs} args - Arguments to create a AccompanyingTeacher.
     * @example
     * // Create one AccompanyingTeacher
     * const AccompanyingTeacher = await prisma.accompanyingTeacher.create({
     *   data: {
     *     // ... data to create a AccompanyingTeacher
     *   }
     * })
     * 
     */
    create<T extends AccompanyingTeacherCreateArgs>(args: SelectSubset<T, AccompanyingTeacherCreateArgs<ExtArgs>>): Prisma__AccompanyingTeacherClient<$Result.GetResult<Prisma.$AccompanyingTeacherPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccompanyingTeachers.
     * @param {AccompanyingTeacherCreateManyArgs} args - Arguments to create many AccompanyingTeachers.
     * @example
     * // Create many AccompanyingTeachers
     * const accompanyingTeacher = await prisma.accompanyingTeacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccompanyingTeacherCreateManyArgs>(args?: SelectSubset<T, AccompanyingTeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccompanyingTeachers and returns the data saved in the database.
     * @param {AccompanyingTeacherCreateManyAndReturnArgs} args - Arguments to create many AccompanyingTeachers.
     * @example
     * // Create many AccompanyingTeachers
     * const accompanyingTeacher = await prisma.accompanyingTeacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccompanyingTeachers and only return the `id`
     * const accompanyingTeacherWithIdOnly = await prisma.accompanyingTeacher.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccompanyingTeacherCreateManyAndReturnArgs>(args?: SelectSubset<T, AccompanyingTeacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanyingTeacherPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AccompanyingTeacher.
     * @param {AccompanyingTeacherDeleteArgs} args - Arguments to delete one AccompanyingTeacher.
     * @example
     * // Delete one AccompanyingTeacher
     * const AccompanyingTeacher = await prisma.accompanyingTeacher.delete({
     *   where: {
     *     // ... filter to delete one AccompanyingTeacher
     *   }
     * })
     * 
     */
    delete<T extends AccompanyingTeacherDeleteArgs>(args: SelectSubset<T, AccompanyingTeacherDeleteArgs<ExtArgs>>): Prisma__AccompanyingTeacherClient<$Result.GetResult<Prisma.$AccompanyingTeacherPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccompanyingTeacher.
     * @param {AccompanyingTeacherUpdateArgs} args - Arguments to update one AccompanyingTeacher.
     * @example
     * // Update one AccompanyingTeacher
     * const accompanyingTeacher = await prisma.accompanyingTeacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccompanyingTeacherUpdateArgs>(args: SelectSubset<T, AccompanyingTeacherUpdateArgs<ExtArgs>>): Prisma__AccompanyingTeacherClient<$Result.GetResult<Prisma.$AccompanyingTeacherPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccompanyingTeachers.
     * @param {AccompanyingTeacherDeleteManyArgs} args - Arguments to filter AccompanyingTeachers to delete.
     * @example
     * // Delete a few AccompanyingTeachers
     * const { count } = await prisma.accompanyingTeacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccompanyingTeacherDeleteManyArgs>(args?: SelectSubset<T, AccompanyingTeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccompanyingTeachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanyingTeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccompanyingTeachers
     * const accompanyingTeacher = await prisma.accompanyingTeacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccompanyingTeacherUpdateManyArgs>(args: SelectSubset<T, AccompanyingTeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccompanyingTeacher.
     * @param {AccompanyingTeacherUpsertArgs} args - Arguments to update or create a AccompanyingTeacher.
     * @example
     * // Update or create a AccompanyingTeacher
     * const accompanyingTeacher = await prisma.accompanyingTeacher.upsert({
     *   create: {
     *     // ... data to create a AccompanyingTeacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccompanyingTeacher we want to update
     *   }
     * })
     */
    upsert<T extends AccompanyingTeacherUpsertArgs>(args: SelectSubset<T, AccompanyingTeacherUpsertArgs<ExtArgs>>): Prisma__AccompanyingTeacherClient<$Result.GetResult<Prisma.$AccompanyingTeacherPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccompanyingTeachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanyingTeacherCountArgs} args - Arguments to filter AccompanyingTeachers to count.
     * @example
     * // Count the number of AccompanyingTeachers
     * const count = await prisma.accompanyingTeacher.count({
     *   where: {
     *     // ... the filter for the AccompanyingTeachers we want to count
     *   }
     * })
    **/
    count<T extends AccompanyingTeacherCountArgs>(
      args?: Subset<T, AccompanyingTeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccompanyingTeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccompanyingTeacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanyingTeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccompanyingTeacherAggregateArgs>(args: Subset<T, AccompanyingTeacherAggregateArgs>): Prisma.PrismaPromise<GetAccompanyingTeacherAggregateType<T>>

    /**
     * Group by AccompanyingTeacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanyingTeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccompanyingTeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccompanyingTeacherGroupByArgs['orderBy'] }
        : { orderBy?: AccompanyingTeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccompanyingTeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccompanyingTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccompanyingTeacher model
   */
  readonly fields: AccompanyingTeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccompanyingTeacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccompanyingTeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccompanyingTeacher model
   */ 
  interface AccompanyingTeacherFieldRefs {
    readonly id: FieldRef<"AccompanyingTeacher", 'Int'>
    readonly name: FieldRef<"AccompanyingTeacher", 'String'>
    readonly gender: FieldRef<"AccompanyingTeacher", 'String'>
    readonly requiresAccommodation: FieldRef<"AccompanyingTeacher", 'Boolean'>
    readonly schoolId: FieldRef<"AccompanyingTeacher", 'Int'>
    readonly createdAt: FieldRef<"AccompanyingTeacher", 'DateTime'>
    readonly updatedAt: FieldRef<"AccompanyingTeacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccompanyingTeacher findUnique
   */
  export type AccompanyingTeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherInclude<ExtArgs> | null
    /**
     * Filter, which AccompanyingTeacher to fetch.
     */
    where: AccompanyingTeacherWhereUniqueInput
  }

  /**
   * AccompanyingTeacher findUniqueOrThrow
   */
  export type AccompanyingTeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherInclude<ExtArgs> | null
    /**
     * Filter, which AccompanyingTeacher to fetch.
     */
    where: AccompanyingTeacherWhereUniqueInput
  }

  /**
   * AccompanyingTeacher findFirst
   */
  export type AccompanyingTeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherInclude<ExtArgs> | null
    /**
     * Filter, which AccompanyingTeacher to fetch.
     */
    where?: AccompanyingTeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccompanyingTeachers to fetch.
     */
    orderBy?: AccompanyingTeacherOrderByWithRelationInput | AccompanyingTeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccompanyingTeachers.
     */
    cursor?: AccompanyingTeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccompanyingTeachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccompanyingTeachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccompanyingTeachers.
     */
    distinct?: AccompanyingTeacherScalarFieldEnum | AccompanyingTeacherScalarFieldEnum[]
  }

  /**
   * AccompanyingTeacher findFirstOrThrow
   */
  export type AccompanyingTeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherInclude<ExtArgs> | null
    /**
     * Filter, which AccompanyingTeacher to fetch.
     */
    where?: AccompanyingTeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccompanyingTeachers to fetch.
     */
    orderBy?: AccompanyingTeacherOrderByWithRelationInput | AccompanyingTeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccompanyingTeachers.
     */
    cursor?: AccompanyingTeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccompanyingTeachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccompanyingTeachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccompanyingTeachers.
     */
    distinct?: AccompanyingTeacherScalarFieldEnum | AccompanyingTeacherScalarFieldEnum[]
  }

  /**
   * AccompanyingTeacher findMany
   */
  export type AccompanyingTeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherInclude<ExtArgs> | null
    /**
     * Filter, which AccompanyingTeachers to fetch.
     */
    where?: AccompanyingTeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccompanyingTeachers to fetch.
     */
    orderBy?: AccompanyingTeacherOrderByWithRelationInput | AccompanyingTeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccompanyingTeachers.
     */
    cursor?: AccompanyingTeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccompanyingTeachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccompanyingTeachers.
     */
    skip?: number
    distinct?: AccompanyingTeacherScalarFieldEnum | AccompanyingTeacherScalarFieldEnum[]
  }

  /**
   * AccompanyingTeacher create
   */
  export type AccompanyingTeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a AccompanyingTeacher.
     */
    data: XOR<AccompanyingTeacherCreateInput, AccompanyingTeacherUncheckedCreateInput>
  }

  /**
   * AccompanyingTeacher createMany
   */
  export type AccompanyingTeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccompanyingTeachers.
     */
    data: AccompanyingTeacherCreateManyInput | AccompanyingTeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccompanyingTeacher createManyAndReturn
   */
  export type AccompanyingTeacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AccompanyingTeachers.
     */
    data: AccompanyingTeacherCreateManyInput | AccompanyingTeacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccompanyingTeacher update
   */
  export type AccompanyingTeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a AccompanyingTeacher.
     */
    data: XOR<AccompanyingTeacherUpdateInput, AccompanyingTeacherUncheckedUpdateInput>
    /**
     * Choose, which AccompanyingTeacher to update.
     */
    where: AccompanyingTeacherWhereUniqueInput
  }

  /**
   * AccompanyingTeacher updateMany
   */
  export type AccompanyingTeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccompanyingTeachers.
     */
    data: XOR<AccompanyingTeacherUpdateManyMutationInput, AccompanyingTeacherUncheckedUpdateManyInput>
    /**
     * Filter which AccompanyingTeachers to update
     */
    where?: AccompanyingTeacherWhereInput
  }

  /**
   * AccompanyingTeacher upsert
   */
  export type AccompanyingTeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the AccompanyingTeacher to update in case it exists.
     */
    where: AccompanyingTeacherWhereUniqueInput
    /**
     * In case the AccompanyingTeacher found by the `where` argument doesn't exist, create a new AccompanyingTeacher with this data.
     */
    create: XOR<AccompanyingTeacherCreateInput, AccompanyingTeacherUncheckedCreateInput>
    /**
     * In case the AccompanyingTeacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccompanyingTeacherUpdateInput, AccompanyingTeacherUncheckedUpdateInput>
  }

  /**
   * AccompanyingTeacher delete
   */
  export type AccompanyingTeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherInclude<ExtArgs> | null
    /**
     * Filter which AccompanyingTeacher to delete.
     */
    where: AccompanyingTeacherWhereUniqueInput
  }

  /**
   * AccompanyingTeacher deleteMany
   */
  export type AccompanyingTeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccompanyingTeachers to delete
     */
    where?: AccompanyingTeacherWhereInput
  }

  /**
   * AccompanyingTeacher without action
   */
  export type AccompanyingTeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanyingTeacher
     */
    select?: AccompanyingTeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanyingTeacherInclude<ExtArgs> | null
  }


  /**
   * Model Competition
   */

  export type AggregateCompetition = {
    _count: CompetitionCountAggregateOutputType | null
    _avg: CompetitionAvgAggregateOutputType | null
    _sum: CompetitionSumAggregateOutputType | null
    _min: CompetitionMinAggregateOutputType | null
    _max: CompetitionMaxAggregateOutputType | null
  }

  export type CompetitionAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type CompetitionSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type CompetitionMinAggregateOutputType = {
    id: number | null
    title: string | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompetitionMaxAggregateOutputType = {
    id: number | null
    title: string | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompetitionCountAggregateOutputType = {
    id: number
    title: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompetitionAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type CompetitionSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type CompetitionMinAggregateInputType = {
    id?: true
    title?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompetitionMaxAggregateInputType = {
    id?: true
    title?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompetitionCountAggregateInputType = {
    id?: true
    title?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompetitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Competition to aggregate.
     */
    where?: CompetitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competitions to fetch.
     */
    orderBy?: CompetitionOrderByWithRelationInput | CompetitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompetitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Competitions
    **/
    _count?: true | CompetitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompetitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompetitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompetitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompetitionMaxAggregateInputType
  }

  export type GetCompetitionAggregateType<T extends CompetitionAggregateArgs> = {
        [P in keyof T & keyof AggregateCompetition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompetition[P]>
      : GetScalarType<T[P], AggregateCompetition[P]>
  }




  export type CompetitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetitionWhereInput
    orderBy?: CompetitionOrderByWithAggregationInput | CompetitionOrderByWithAggregationInput[]
    by: CompetitionScalarFieldEnum[] | CompetitionScalarFieldEnum
    having?: CompetitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompetitionCountAggregateInputType | true
    _avg?: CompetitionAvgAggregateInputType
    _sum?: CompetitionSumAggregateInputType
    _min?: CompetitionMinAggregateInputType
    _max?: CompetitionMaxAggregateInputType
  }

  export type CompetitionGroupByOutputType = {
    id: number
    title: string
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: CompetitionCountAggregateOutputType | null
    _avg: CompetitionAvgAggregateOutputType | null
    _sum: CompetitionSumAggregateOutputType | null
    _min: CompetitionMinAggregateOutputType | null
    _max: CompetitionMaxAggregateOutputType | null
  }

  type GetCompetitionGroupByPayload<T extends CompetitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompetitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompetitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompetitionGroupByOutputType[P]>
            : GetScalarType<T[P], CompetitionGroupByOutputType[P]>
        }
      >
    >


  export type CompetitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["competition"]>

  export type CompetitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["competition"]>

  export type CompetitionSelectScalar = {
    id?: boolean
    title?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompetitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type CompetitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $CompetitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Competition"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["competition"]>
    composites: {}
  }

  type CompetitionGetPayload<S extends boolean | null | undefined | CompetitionDefaultArgs> = $Result.GetResult<Prisma.$CompetitionPayload, S>

  type CompetitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompetitionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompetitionCountAggregateInputType | true
    }

  export interface CompetitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Competition'], meta: { name: 'Competition' } }
    /**
     * Find zero or one Competition that matches the filter.
     * @param {CompetitionFindUniqueArgs} args - Arguments to find a Competition
     * @example
     * // Get one Competition
     * const competition = await prisma.competition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompetitionFindUniqueArgs>(args: SelectSubset<T, CompetitionFindUniqueArgs<ExtArgs>>): Prisma__CompetitionClient<$Result.GetResult<Prisma.$CompetitionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Competition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompetitionFindUniqueOrThrowArgs} args - Arguments to find a Competition
     * @example
     * // Get one Competition
     * const competition = await prisma.competition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompetitionFindUniqueOrThrowArgs>(args: SelectSubset<T, CompetitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompetitionClient<$Result.GetResult<Prisma.$CompetitionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Competition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitionFindFirstArgs} args - Arguments to find a Competition
     * @example
     * // Get one Competition
     * const competition = await prisma.competition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompetitionFindFirstArgs>(args?: SelectSubset<T, CompetitionFindFirstArgs<ExtArgs>>): Prisma__CompetitionClient<$Result.GetResult<Prisma.$CompetitionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Competition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitionFindFirstOrThrowArgs} args - Arguments to find a Competition
     * @example
     * // Get one Competition
     * const competition = await prisma.competition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompetitionFindFirstOrThrowArgs>(args?: SelectSubset<T, CompetitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompetitionClient<$Result.GetResult<Prisma.$CompetitionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Competitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Competitions
     * const competitions = await prisma.competition.findMany()
     * 
     * // Get first 10 Competitions
     * const competitions = await prisma.competition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const competitionWithIdOnly = await prisma.competition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompetitionFindManyArgs>(args?: SelectSubset<T, CompetitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetitionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Competition.
     * @param {CompetitionCreateArgs} args - Arguments to create a Competition.
     * @example
     * // Create one Competition
     * const Competition = await prisma.competition.create({
     *   data: {
     *     // ... data to create a Competition
     *   }
     * })
     * 
     */
    create<T extends CompetitionCreateArgs>(args: SelectSubset<T, CompetitionCreateArgs<ExtArgs>>): Prisma__CompetitionClient<$Result.GetResult<Prisma.$CompetitionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Competitions.
     * @param {CompetitionCreateManyArgs} args - Arguments to create many Competitions.
     * @example
     * // Create many Competitions
     * const competition = await prisma.competition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompetitionCreateManyArgs>(args?: SelectSubset<T, CompetitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Competitions and returns the data saved in the database.
     * @param {CompetitionCreateManyAndReturnArgs} args - Arguments to create many Competitions.
     * @example
     * // Create many Competitions
     * const competition = await prisma.competition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Competitions and only return the `id`
     * const competitionWithIdOnly = await prisma.competition.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompetitionCreateManyAndReturnArgs>(args?: SelectSubset<T, CompetitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetitionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Competition.
     * @param {CompetitionDeleteArgs} args - Arguments to delete one Competition.
     * @example
     * // Delete one Competition
     * const Competition = await prisma.competition.delete({
     *   where: {
     *     // ... filter to delete one Competition
     *   }
     * })
     * 
     */
    delete<T extends CompetitionDeleteArgs>(args: SelectSubset<T, CompetitionDeleteArgs<ExtArgs>>): Prisma__CompetitionClient<$Result.GetResult<Prisma.$CompetitionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Competition.
     * @param {CompetitionUpdateArgs} args - Arguments to update one Competition.
     * @example
     * // Update one Competition
     * const competition = await prisma.competition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompetitionUpdateArgs>(args: SelectSubset<T, CompetitionUpdateArgs<ExtArgs>>): Prisma__CompetitionClient<$Result.GetResult<Prisma.$CompetitionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Competitions.
     * @param {CompetitionDeleteManyArgs} args - Arguments to filter Competitions to delete.
     * @example
     * // Delete a few Competitions
     * const { count } = await prisma.competition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompetitionDeleteManyArgs>(args?: SelectSubset<T, CompetitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Competitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Competitions
     * const competition = await prisma.competition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompetitionUpdateManyArgs>(args: SelectSubset<T, CompetitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Competition.
     * @param {CompetitionUpsertArgs} args - Arguments to update or create a Competition.
     * @example
     * // Update or create a Competition
     * const competition = await prisma.competition.upsert({
     *   create: {
     *     // ... data to create a Competition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Competition we want to update
     *   }
     * })
     */
    upsert<T extends CompetitionUpsertArgs>(args: SelectSubset<T, CompetitionUpsertArgs<ExtArgs>>): Prisma__CompetitionClient<$Result.GetResult<Prisma.$CompetitionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Competitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitionCountArgs} args - Arguments to filter Competitions to count.
     * @example
     * // Count the number of Competitions
     * const count = await prisma.competition.count({
     *   where: {
     *     // ... the filter for the Competitions we want to count
     *   }
     * })
    **/
    count<T extends CompetitionCountArgs>(
      args?: Subset<T, CompetitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompetitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Competition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompetitionAggregateArgs>(args: Subset<T, CompetitionAggregateArgs>): Prisma.PrismaPromise<GetCompetitionAggregateType<T>>

    /**
     * Group by Competition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompetitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompetitionGroupByArgs['orderBy'] }
        : { orderBy?: CompetitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompetitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompetitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Competition model
   */
  readonly fields: CompetitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Competition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompetitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Competition model
   */ 
  interface CompetitionFieldRefs {
    readonly id: FieldRef<"Competition", 'Int'>
    readonly title: FieldRef<"Competition", 'String'>
    readonly schoolId: FieldRef<"Competition", 'Int'>
    readonly createdAt: FieldRef<"Competition", 'DateTime'>
    readonly updatedAt: FieldRef<"Competition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Competition findUnique
   */
  export type CompetitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionInclude<ExtArgs> | null
    /**
     * Filter, which Competition to fetch.
     */
    where: CompetitionWhereUniqueInput
  }

  /**
   * Competition findUniqueOrThrow
   */
  export type CompetitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionInclude<ExtArgs> | null
    /**
     * Filter, which Competition to fetch.
     */
    where: CompetitionWhereUniqueInput
  }

  /**
   * Competition findFirst
   */
  export type CompetitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionInclude<ExtArgs> | null
    /**
     * Filter, which Competition to fetch.
     */
    where?: CompetitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competitions to fetch.
     */
    orderBy?: CompetitionOrderByWithRelationInput | CompetitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Competitions.
     */
    cursor?: CompetitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Competitions.
     */
    distinct?: CompetitionScalarFieldEnum | CompetitionScalarFieldEnum[]
  }

  /**
   * Competition findFirstOrThrow
   */
  export type CompetitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionInclude<ExtArgs> | null
    /**
     * Filter, which Competition to fetch.
     */
    where?: CompetitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competitions to fetch.
     */
    orderBy?: CompetitionOrderByWithRelationInput | CompetitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Competitions.
     */
    cursor?: CompetitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Competitions.
     */
    distinct?: CompetitionScalarFieldEnum | CompetitionScalarFieldEnum[]
  }

  /**
   * Competition findMany
   */
  export type CompetitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionInclude<ExtArgs> | null
    /**
     * Filter, which Competitions to fetch.
     */
    where?: CompetitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competitions to fetch.
     */
    orderBy?: CompetitionOrderByWithRelationInput | CompetitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Competitions.
     */
    cursor?: CompetitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competitions.
     */
    skip?: number
    distinct?: CompetitionScalarFieldEnum | CompetitionScalarFieldEnum[]
  }

  /**
   * Competition create
   */
  export type CompetitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionInclude<ExtArgs> | null
    /**
     * The data needed to create a Competition.
     */
    data: XOR<CompetitionCreateInput, CompetitionUncheckedCreateInput>
  }

  /**
   * Competition createMany
   */
  export type CompetitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Competitions.
     */
    data: CompetitionCreateManyInput | CompetitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Competition createManyAndReturn
   */
  export type CompetitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Competitions.
     */
    data: CompetitionCreateManyInput | CompetitionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Competition update
   */
  export type CompetitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionInclude<ExtArgs> | null
    /**
     * The data needed to update a Competition.
     */
    data: XOR<CompetitionUpdateInput, CompetitionUncheckedUpdateInput>
    /**
     * Choose, which Competition to update.
     */
    where: CompetitionWhereUniqueInput
  }

  /**
   * Competition updateMany
   */
  export type CompetitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Competitions.
     */
    data: XOR<CompetitionUpdateManyMutationInput, CompetitionUncheckedUpdateManyInput>
    /**
     * Filter which Competitions to update
     */
    where?: CompetitionWhereInput
  }

  /**
   * Competition upsert
   */
  export type CompetitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionInclude<ExtArgs> | null
    /**
     * The filter to search for the Competition to update in case it exists.
     */
    where: CompetitionWhereUniqueInput
    /**
     * In case the Competition found by the `where` argument doesn't exist, create a new Competition with this data.
     */
    create: XOR<CompetitionCreateInput, CompetitionUncheckedCreateInput>
    /**
     * In case the Competition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompetitionUpdateInput, CompetitionUncheckedUpdateInput>
  }

  /**
   * Competition delete
   */
  export type CompetitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionInclude<ExtArgs> | null
    /**
     * Filter which Competition to delete.
     */
    where: CompetitionWhereUniqueInput
  }

  /**
   * Competition deleteMany
   */
  export type CompetitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Competitions to delete
     */
    where?: CompetitionWhereInput
  }

  /**
   * Competition without action
   */
  export type CompetitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competition
     */
    select?: CompetitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitionInclude<ExtArgs> | null
  }


  /**
   * Model StudentModel1
   */

  export type AggregateStudentModel1 = {
    _count: StudentModel1CountAggregateOutputType | null
    _avg: StudentModel1AvgAggregateOutputType | null
    _sum: StudentModel1SumAggregateOutputType | null
    _min: StudentModel1MinAggregateOutputType | null
    _max: StudentModel1MaxAggregateOutputType | null
  }

  export type StudentModel1AvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type StudentModel1SumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type StudentModel1MinAggregateOutputType = {
    id: number | null
    participant1Name: string | null
    participant1Gender: string | null
    participant1Class: string | null
    participant1Accommodation: string | null
    participant2Name: string | null
    participant2Gender: string | null
    participant2Class: string | null
    participant2Accommodation: string | null
    additionalRequirements: string | null
    declaration: boolean | null
    writeup: string | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentModel1MaxAggregateOutputType = {
    id: number | null
    participant1Name: string | null
    participant1Gender: string | null
    participant1Class: string | null
    participant1Accommodation: string | null
    participant2Name: string | null
    participant2Gender: string | null
    participant2Class: string | null
    participant2Accommodation: string | null
    additionalRequirements: string | null
    declaration: boolean | null
    writeup: string | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentModel1CountAggregateOutputType = {
    id: number
    participant1Name: number
    participant1Gender: number
    participant1Class: number
    participant1Accommodation: number
    participant2Name: number
    participant2Gender: number
    participant2Class: number
    participant2Accommodation: number
    additionalRequirements: number
    declaration: number
    writeup: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentModel1AvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type StudentModel1SumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type StudentModel1MinAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    additionalRequirements?: true
    declaration?: true
    writeup?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentModel1MaxAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    additionalRequirements?: true
    declaration?: true
    writeup?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentModel1CountAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    additionalRequirements?: true
    declaration?: true
    writeup?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentModel1AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentModel1 to aggregate.
     */
    where?: StudentModel1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentModel1s to fetch.
     */
    orderBy?: StudentModel1OrderByWithRelationInput | StudentModel1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentModel1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentModel1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentModel1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentModel1s
    **/
    _count?: true | StudentModel1CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentModel1AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentModel1SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentModel1MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentModel1MaxAggregateInputType
  }

  export type GetStudentModel1AggregateType<T extends StudentModel1AggregateArgs> = {
        [P in keyof T & keyof AggregateStudentModel1]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentModel1[P]>
      : GetScalarType<T[P], AggregateStudentModel1[P]>
  }




  export type StudentModel1GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentModel1WhereInput
    orderBy?: StudentModel1OrderByWithAggregationInput | StudentModel1OrderByWithAggregationInput[]
    by: StudentModel1ScalarFieldEnum[] | StudentModel1ScalarFieldEnum
    having?: StudentModel1ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentModel1CountAggregateInputType | true
    _avg?: StudentModel1AvgAggregateInputType
    _sum?: StudentModel1SumAggregateInputType
    _min?: StudentModel1MinAggregateInputType
    _max?: StudentModel1MaxAggregateInputType
  }

  export type StudentModel1GroupByOutputType = {
    id: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements: string | null
    declaration: boolean
    writeup: string
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: StudentModel1CountAggregateOutputType | null
    _avg: StudentModel1AvgAggregateOutputType | null
    _sum: StudentModel1SumAggregateOutputType | null
    _min: StudentModel1MinAggregateOutputType | null
    _max: StudentModel1MaxAggregateOutputType | null
  }

  type GetStudentModel1GroupByPayload<T extends StudentModel1GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentModel1GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentModel1GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentModel1GroupByOutputType[P]>
            : GetScalarType<T[P], StudentModel1GroupByOutputType[P]>
        }
      >
    >


  export type StudentModel1Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    writeup?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentModel1"]>

  export type StudentModel1SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    writeup?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentModel1"]>

  export type StudentModel1SelectScalar = {
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    writeup?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentModel1Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type StudentModel1IncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $StudentModel1Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentModel1"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      participant1Name: string
      participant1Gender: string
      participant1Class: string
      participant1Accommodation: string
      participant2Name: string
      participant2Gender: string
      participant2Class: string
      participant2Accommodation: string
      additionalRequirements: string | null
      declaration: boolean
      writeup: string
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentModel1"]>
    composites: {}
  }

  type StudentModel1GetPayload<S extends boolean | null | undefined | StudentModel1DefaultArgs> = $Result.GetResult<Prisma.$StudentModel1Payload, S>

  type StudentModel1CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentModel1FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentModel1CountAggregateInputType | true
    }

  export interface StudentModel1Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentModel1'], meta: { name: 'StudentModel1' } }
    /**
     * Find zero or one StudentModel1 that matches the filter.
     * @param {StudentModel1FindUniqueArgs} args - Arguments to find a StudentModel1
     * @example
     * // Get one StudentModel1
     * const studentModel1 = await prisma.studentModel1.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentModel1FindUniqueArgs>(args: SelectSubset<T, StudentModel1FindUniqueArgs<ExtArgs>>): Prisma__StudentModel1Client<$Result.GetResult<Prisma.$StudentModel1Payload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentModel1 that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentModel1FindUniqueOrThrowArgs} args - Arguments to find a StudentModel1
     * @example
     * // Get one StudentModel1
     * const studentModel1 = await prisma.studentModel1.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentModel1FindUniqueOrThrowArgs>(args: SelectSubset<T, StudentModel1FindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentModel1Client<$Result.GetResult<Prisma.$StudentModel1Payload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentModel1 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel1FindFirstArgs} args - Arguments to find a StudentModel1
     * @example
     * // Get one StudentModel1
     * const studentModel1 = await prisma.studentModel1.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentModel1FindFirstArgs>(args?: SelectSubset<T, StudentModel1FindFirstArgs<ExtArgs>>): Prisma__StudentModel1Client<$Result.GetResult<Prisma.$StudentModel1Payload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentModel1 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel1FindFirstOrThrowArgs} args - Arguments to find a StudentModel1
     * @example
     * // Get one StudentModel1
     * const studentModel1 = await prisma.studentModel1.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentModel1FindFirstOrThrowArgs>(args?: SelectSubset<T, StudentModel1FindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentModel1Client<$Result.GetResult<Prisma.$StudentModel1Payload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentModel1s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel1FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentModel1s
     * const studentModel1s = await prisma.studentModel1.findMany()
     * 
     * // Get first 10 StudentModel1s
     * const studentModel1s = await prisma.studentModel1.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentModel1WithIdOnly = await prisma.studentModel1.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentModel1FindManyArgs>(args?: SelectSubset<T, StudentModel1FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentModel1Payload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentModel1.
     * @param {StudentModel1CreateArgs} args - Arguments to create a StudentModel1.
     * @example
     * // Create one StudentModel1
     * const StudentModel1 = await prisma.studentModel1.create({
     *   data: {
     *     // ... data to create a StudentModel1
     *   }
     * })
     * 
     */
    create<T extends StudentModel1CreateArgs>(args: SelectSubset<T, StudentModel1CreateArgs<ExtArgs>>): Prisma__StudentModel1Client<$Result.GetResult<Prisma.$StudentModel1Payload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentModel1s.
     * @param {StudentModel1CreateManyArgs} args - Arguments to create many StudentModel1s.
     * @example
     * // Create many StudentModel1s
     * const studentModel1 = await prisma.studentModel1.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentModel1CreateManyArgs>(args?: SelectSubset<T, StudentModel1CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentModel1s and returns the data saved in the database.
     * @param {StudentModel1CreateManyAndReturnArgs} args - Arguments to create many StudentModel1s.
     * @example
     * // Create many StudentModel1s
     * const studentModel1 = await prisma.studentModel1.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentModel1s and only return the `id`
     * const studentModel1WithIdOnly = await prisma.studentModel1.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentModel1CreateManyAndReturnArgs>(args?: SelectSubset<T, StudentModel1CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentModel1Payload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentModel1.
     * @param {StudentModel1DeleteArgs} args - Arguments to delete one StudentModel1.
     * @example
     * // Delete one StudentModel1
     * const StudentModel1 = await prisma.studentModel1.delete({
     *   where: {
     *     // ... filter to delete one StudentModel1
     *   }
     * })
     * 
     */
    delete<T extends StudentModel1DeleteArgs>(args: SelectSubset<T, StudentModel1DeleteArgs<ExtArgs>>): Prisma__StudentModel1Client<$Result.GetResult<Prisma.$StudentModel1Payload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentModel1.
     * @param {StudentModel1UpdateArgs} args - Arguments to update one StudentModel1.
     * @example
     * // Update one StudentModel1
     * const studentModel1 = await prisma.studentModel1.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentModel1UpdateArgs>(args: SelectSubset<T, StudentModel1UpdateArgs<ExtArgs>>): Prisma__StudentModel1Client<$Result.GetResult<Prisma.$StudentModel1Payload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentModel1s.
     * @param {StudentModel1DeleteManyArgs} args - Arguments to filter StudentModel1s to delete.
     * @example
     * // Delete a few StudentModel1s
     * const { count } = await prisma.studentModel1.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentModel1DeleteManyArgs>(args?: SelectSubset<T, StudentModel1DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentModel1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel1UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentModel1s
     * const studentModel1 = await prisma.studentModel1.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentModel1UpdateManyArgs>(args: SelectSubset<T, StudentModel1UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentModel1.
     * @param {StudentModel1UpsertArgs} args - Arguments to update or create a StudentModel1.
     * @example
     * // Update or create a StudentModel1
     * const studentModel1 = await prisma.studentModel1.upsert({
     *   create: {
     *     // ... data to create a StudentModel1
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentModel1 we want to update
     *   }
     * })
     */
    upsert<T extends StudentModel1UpsertArgs>(args: SelectSubset<T, StudentModel1UpsertArgs<ExtArgs>>): Prisma__StudentModel1Client<$Result.GetResult<Prisma.$StudentModel1Payload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentModel1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel1CountArgs} args - Arguments to filter StudentModel1s to count.
     * @example
     * // Count the number of StudentModel1s
     * const count = await prisma.studentModel1.count({
     *   where: {
     *     // ... the filter for the StudentModel1s we want to count
     *   }
     * })
    **/
    count<T extends StudentModel1CountArgs>(
      args?: Subset<T, StudentModel1CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentModel1CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentModel1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel1AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentModel1AggregateArgs>(args: Subset<T, StudentModel1AggregateArgs>): Prisma.PrismaPromise<GetStudentModel1AggregateType<T>>

    /**
     * Group by StudentModel1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel1GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentModel1GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentModel1GroupByArgs['orderBy'] }
        : { orderBy?: StudentModel1GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentModel1GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentModel1GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentModel1 model
   */
  readonly fields: StudentModel1FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentModel1.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentModel1Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentModel1 model
   */ 
  interface StudentModel1FieldRefs {
    readonly id: FieldRef<"StudentModel1", 'Int'>
    readonly participant1Name: FieldRef<"StudentModel1", 'String'>
    readonly participant1Gender: FieldRef<"StudentModel1", 'String'>
    readonly participant1Class: FieldRef<"StudentModel1", 'String'>
    readonly participant1Accommodation: FieldRef<"StudentModel1", 'String'>
    readonly participant2Name: FieldRef<"StudentModel1", 'String'>
    readonly participant2Gender: FieldRef<"StudentModel1", 'String'>
    readonly participant2Class: FieldRef<"StudentModel1", 'String'>
    readonly participant2Accommodation: FieldRef<"StudentModel1", 'String'>
    readonly additionalRequirements: FieldRef<"StudentModel1", 'String'>
    readonly declaration: FieldRef<"StudentModel1", 'Boolean'>
    readonly writeup: FieldRef<"StudentModel1", 'String'>
    readonly schoolId: FieldRef<"StudentModel1", 'Int'>
    readonly createdAt: FieldRef<"StudentModel1", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentModel1", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentModel1 findUnique
   */
  export type StudentModel1FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1Include<ExtArgs> | null
    /**
     * Filter, which StudentModel1 to fetch.
     */
    where: StudentModel1WhereUniqueInput
  }

  /**
   * StudentModel1 findUniqueOrThrow
   */
  export type StudentModel1FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1Include<ExtArgs> | null
    /**
     * Filter, which StudentModel1 to fetch.
     */
    where: StudentModel1WhereUniqueInput
  }

  /**
   * StudentModel1 findFirst
   */
  export type StudentModel1FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1Include<ExtArgs> | null
    /**
     * Filter, which StudentModel1 to fetch.
     */
    where?: StudentModel1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentModel1s to fetch.
     */
    orderBy?: StudentModel1OrderByWithRelationInput | StudentModel1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentModel1s.
     */
    cursor?: StudentModel1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentModel1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentModel1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentModel1s.
     */
    distinct?: StudentModel1ScalarFieldEnum | StudentModel1ScalarFieldEnum[]
  }

  /**
   * StudentModel1 findFirstOrThrow
   */
  export type StudentModel1FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1Include<ExtArgs> | null
    /**
     * Filter, which StudentModel1 to fetch.
     */
    where?: StudentModel1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentModel1s to fetch.
     */
    orderBy?: StudentModel1OrderByWithRelationInput | StudentModel1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentModel1s.
     */
    cursor?: StudentModel1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentModel1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentModel1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentModel1s.
     */
    distinct?: StudentModel1ScalarFieldEnum | StudentModel1ScalarFieldEnum[]
  }

  /**
   * StudentModel1 findMany
   */
  export type StudentModel1FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1Include<ExtArgs> | null
    /**
     * Filter, which StudentModel1s to fetch.
     */
    where?: StudentModel1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentModel1s to fetch.
     */
    orderBy?: StudentModel1OrderByWithRelationInput | StudentModel1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentModel1s.
     */
    cursor?: StudentModel1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentModel1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentModel1s.
     */
    skip?: number
    distinct?: StudentModel1ScalarFieldEnum | StudentModel1ScalarFieldEnum[]
  }

  /**
   * StudentModel1 create
   */
  export type StudentModel1CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1Include<ExtArgs> | null
    /**
     * The data needed to create a StudentModel1.
     */
    data: XOR<StudentModel1CreateInput, StudentModel1UncheckedCreateInput>
  }

  /**
   * StudentModel1 createMany
   */
  export type StudentModel1CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentModel1s.
     */
    data: StudentModel1CreateManyInput | StudentModel1CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentModel1 createManyAndReturn
   */
  export type StudentModel1CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentModel1s.
     */
    data: StudentModel1CreateManyInput | StudentModel1CreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1IncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentModel1 update
   */
  export type StudentModel1UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1Include<ExtArgs> | null
    /**
     * The data needed to update a StudentModel1.
     */
    data: XOR<StudentModel1UpdateInput, StudentModel1UncheckedUpdateInput>
    /**
     * Choose, which StudentModel1 to update.
     */
    where: StudentModel1WhereUniqueInput
  }

  /**
   * StudentModel1 updateMany
   */
  export type StudentModel1UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentModel1s.
     */
    data: XOR<StudentModel1UpdateManyMutationInput, StudentModel1UncheckedUpdateManyInput>
    /**
     * Filter which StudentModel1s to update
     */
    where?: StudentModel1WhereInput
  }

  /**
   * StudentModel1 upsert
   */
  export type StudentModel1UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1Include<ExtArgs> | null
    /**
     * The filter to search for the StudentModel1 to update in case it exists.
     */
    where: StudentModel1WhereUniqueInput
    /**
     * In case the StudentModel1 found by the `where` argument doesn't exist, create a new StudentModel1 with this data.
     */
    create: XOR<StudentModel1CreateInput, StudentModel1UncheckedCreateInput>
    /**
     * In case the StudentModel1 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentModel1UpdateInput, StudentModel1UncheckedUpdateInput>
  }

  /**
   * StudentModel1 delete
   */
  export type StudentModel1DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1Include<ExtArgs> | null
    /**
     * Filter which StudentModel1 to delete.
     */
    where: StudentModel1WhereUniqueInput
  }

  /**
   * StudentModel1 deleteMany
   */
  export type StudentModel1DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentModel1s to delete
     */
    where?: StudentModel1WhereInput
  }

  /**
   * StudentModel1 without action
   */
  export type StudentModel1DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel1
     */
    select?: StudentModel1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel1Include<ExtArgs> | null
  }


  /**
   * Model StudentModel2
   */

  export type AggregateStudentModel2 = {
    _count: StudentModel2CountAggregateOutputType | null
    _avg: StudentModel2AvgAggregateOutputType | null
    _sum: StudentModel2SumAggregateOutputType | null
    _min: StudentModel2MinAggregateOutputType | null
    _max: StudentModel2MaxAggregateOutputType | null
  }

  export type StudentModel2AvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type StudentModel2SumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type StudentModel2MinAggregateOutputType = {
    id: number | null
    participant1Name: string | null
    participant1Gender: string | null
    participant1Class: string | null
    participant1Accommodation: string | null
    participant2Name: string | null
    participant2Gender: string | null
    participant2Class: string | null
    participant2Accommodation: string | null
    additionalRequirements: string | null
    declaration: boolean | null
    writeup: string | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentModel2MaxAggregateOutputType = {
    id: number | null
    participant1Name: string | null
    participant1Gender: string | null
    participant1Class: string | null
    participant1Accommodation: string | null
    participant2Name: string | null
    participant2Gender: string | null
    participant2Class: string | null
    participant2Accommodation: string | null
    additionalRequirements: string | null
    declaration: boolean | null
    writeup: string | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentModel2CountAggregateOutputType = {
    id: number
    participant1Name: number
    participant1Gender: number
    participant1Class: number
    participant1Accommodation: number
    participant2Name: number
    participant2Gender: number
    participant2Class: number
    participant2Accommodation: number
    additionalRequirements: number
    declaration: number
    writeup: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentModel2AvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type StudentModel2SumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type StudentModel2MinAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    additionalRequirements?: true
    declaration?: true
    writeup?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentModel2MaxAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    additionalRequirements?: true
    declaration?: true
    writeup?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentModel2CountAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    additionalRequirements?: true
    declaration?: true
    writeup?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentModel2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentModel2 to aggregate.
     */
    where?: StudentModel2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentModel2s to fetch.
     */
    orderBy?: StudentModel2OrderByWithRelationInput | StudentModel2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentModel2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentModel2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentModel2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentModel2s
    **/
    _count?: true | StudentModel2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentModel2AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentModel2SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentModel2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentModel2MaxAggregateInputType
  }

  export type GetStudentModel2AggregateType<T extends StudentModel2AggregateArgs> = {
        [P in keyof T & keyof AggregateStudentModel2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentModel2[P]>
      : GetScalarType<T[P], AggregateStudentModel2[P]>
  }




  export type StudentModel2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentModel2WhereInput
    orderBy?: StudentModel2OrderByWithAggregationInput | StudentModel2OrderByWithAggregationInput[]
    by: StudentModel2ScalarFieldEnum[] | StudentModel2ScalarFieldEnum
    having?: StudentModel2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentModel2CountAggregateInputType | true
    _avg?: StudentModel2AvgAggregateInputType
    _sum?: StudentModel2SumAggregateInputType
    _min?: StudentModel2MinAggregateInputType
    _max?: StudentModel2MaxAggregateInputType
  }

  export type StudentModel2GroupByOutputType = {
    id: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements: string | null
    declaration: boolean
    writeup: string
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: StudentModel2CountAggregateOutputType | null
    _avg: StudentModel2AvgAggregateOutputType | null
    _sum: StudentModel2SumAggregateOutputType | null
    _min: StudentModel2MinAggregateOutputType | null
    _max: StudentModel2MaxAggregateOutputType | null
  }

  type GetStudentModel2GroupByPayload<T extends StudentModel2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentModel2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentModel2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentModel2GroupByOutputType[P]>
            : GetScalarType<T[P], StudentModel2GroupByOutputType[P]>
        }
      >
    >


  export type StudentModel2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    writeup?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentModel2"]>

  export type StudentModel2SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    writeup?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentModel2"]>

  export type StudentModel2SelectScalar = {
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    writeup?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentModel2Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type StudentModel2IncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $StudentModel2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentModel2"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      participant1Name: string
      participant1Gender: string
      participant1Class: string
      participant1Accommodation: string
      participant2Name: string
      participant2Gender: string
      participant2Class: string
      participant2Accommodation: string
      additionalRequirements: string | null
      declaration: boolean
      writeup: string
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentModel2"]>
    composites: {}
  }

  type StudentModel2GetPayload<S extends boolean | null | undefined | StudentModel2DefaultArgs> = $Result.GetResult<Prisma.$StudentModel2Payload, S>

  type StudentModel2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentModel2FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentModel2CountAggregateInputType | true
    }

  export interface StudentModel2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentModel2'], meta: { name: 'StudentModel2' } }
    /**
     * Find zero or one StudentModel2 that matches the filter.
     * @param {StudentModel2FindUniqueArgs} args - Arguments to find a StudentModel2
     * @example
     * // Get one StudentModel2
     * const studentModel2 = await prisma.studentModel2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentModel2FindUniqueArgs>(args: SelectSubset<T, StudentModel2FindUniqueArgs<ExtArgs>>): Prisma__StudentModel2Client<$Result.GetResult<Prisma.$StudentModel2Payload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentModel2 that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentModel2FindUniqueOrThrowArgs} args - Arguments to find a StudentModel2
     * @example
     * // Get one StudentModel2
     * const studentModel2 = await prisma.studentModel2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentModel2FindUniqueOrThrowArgs>(args: SelectSubset<T, StudentModel2FindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentModel2Client<$Result.GetResult<Prisma.$StudentModel2Payload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentModel2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel2FindFirstArgs} args - Arguments to find a StudentModel2
     * @example
     * // Get one StudentModel2
     * const studentModel2 = await prisma.studentModel2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentModel2FindFirstArgs>(args?: SelectSubset<T, StudentModel2FindFirstArgs<ExtArgs>>): Prisma__StudentModel2Client<$Result.GetResult<Prisma.$StudentModel2Payload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentModel2 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel2FindFirstOrThrowArgs} args - Arguments to find a StudentModel2
     * @example
     * // Get one StudentModel2
     * const studentModel2 = await prisma.studentModel2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentModel2FindFirstOrThrowArgs>(args?: SelectSubset<T, StudentModel2FindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentModel2Client<$Result.GetResult<Prisma.$StudentModel2Payload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentModel2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel2FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentModel2s
     * const studentModel2s = await prisma.studentModel2.findMany()
     * 
     * // Get first 10 StudentModel2s
     * const studentModel2s = await prisma.studentModel2.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentModel2WithIdOnly = await prisma.studentModel2.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentModel2FindManyArgs>(args?: SelectSubset<T, StudentModel2FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentModel2Payload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentModel2.
     * @param {StudentModel2CreateArgs} args - Arguments to create a StudentModel2.
     * @example
     * // Create one StudentModel2
     * const StudentModel2 = await prisma.studentModel2.create({
     *   data: {
     *     // ... data to create a StudentModel2
     *   }
     * })
     * 
     */
    create<T extends StudentModel2CreateArgs>(args: SelectSubset<T, StudentModel2CreateArgs<ExtArgs>>): Prisma__StudentModel2Client<$Result.GetResult<Prisma.$StudentModel2Payload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentModel2s.
     * @param {StudentModel2CreateManyArgs} args - Arguments to create many StudentModel2s.
     * @example
     * // Create many StudentModel2s
     * const studentModel2 = await prisma.studentModel2.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentModel2CreateManyArgs>(args?: SelectSubset<T, StudentModel2CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentModel2s and returns the data saved in the database.
     * @param {StudentModel2CreateManyAndReturnArgs} args - Arguments to create many StudentModel2s.
     * @example
     * // Create many StudentModel2s
     * const studentModel2 = await prisma.studentModel2.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentModel2s and only return the `id`
     * const studentModel2WithIdOnly = await prisma.studentModel2.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentModel2CreateManyAndReturnArgs>(args?: SelectSubset<T, StudentModel2CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentModel2Payload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentModel2.
     * @param {StudentModel2DeleteArgs} args - Arguments to delete one StudentModel2.
     * @example
     * // Delete one StudentModel2
     * const StudentModel2 = await prisma.studentModel2.delete({
     *   where: {
     *     // ... filter to delete one StudentModel2
     *   }
     * })
     * 
     */
    delete<T extends StudentModel2DeleteArgs>(args: SelectSubset<T, StudentModel2DeleteArgs<ExtArgs>>): Prisma__StudentModel2Client<$Result.GetResult<Prisma.$StudentModel2Payload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentModel2.
     * @param {StudentModel2UpdateArgs} args - Arguments to update one StudentModel2.
     * @example
     * // Update one StudentModel2
     * const studentModel2 = await prisma.studentModel2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentModel2UpdateArgs>(args: SelectSubset<T, StudentModel2UpdateArgs<ExtArgs>>): Prisma__StudentModel2Client<$Result.GetResult<Prisma.$StudentModel2Payload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentModel2s.
     * @param {StudentModel2DeleteManyArgs} args - Arguments to filter StudentModel2s to delete.
     * @example
     * // Delete a few StudentModel2s
     * const { count } = await prisma.studentModel2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentModel2DeleteManyArgs>(args?: SelectSubset<T, StudentModel2DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentModel2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentModel2s
     * const studentModel2 = await prisma.studentModel2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentModel2UpdateManyArgs>(args: SelectSubset<T, StudentModel2UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentModel2.
     * @param {StudentModel2UpsertArgs} args - Arguments to update or create a StudentModel2.
     * @example
     * // Update or create a StudentModel2
     * const studentModel2 = await prisma.studentModel2.upsert({
     *   create: {
     *     // ... data to create a StudentModel2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentModel2 we want to update
     *   }
     * })
     */
    upsert<T extends StudentModel2UpsertArgs>(args: SelectSubset<T, StudentModel2UpsertArgs<ExtArgs>>): Prisma__StudentModel2Client<$Result.GetResult<Prisma.$StudentModel2Payload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentModel2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel2CountArgs} args - Arguments to filter StudentModel2s to count.
     * @example
     * // Count the number of StudentModel2s
     * const count = await prisma.studentModel2.count({
     *   where: {
     *     // ... the filter for the StudentModel2s we want to count
     *   }
     * })
    **/
    count<T extends StudentModel2CountArgs>(
      args?: Subset<T, StudentModel2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentModel2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentModel2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentModel2AggregateArgs>(args: Subset<T, StudentModel2AggregateArgs>): Prisma.PrismaPromise<GetStudentModel2AggregateType<T>>

    /**
     * Group by StudentModel2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentModel2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentModel2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentModel2GroupByArgs['orderBy'] }
        : { orderBy?: StudentModel2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentModel2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentModel2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentModel2 model
   */
  readonly fields: StudentModel2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentModel2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentModel2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentModel2 model
   */ 
  interface StudentModel2FieldRefs {
    readonly id: FieldRef<"StudentModel2", 'Int'>
    readonly participant1Name: FieldRef<"StudentModel2", 'String'>
    readonly participant1Gender: FieldRef<"StudentModel2", 'String'>
    readonly participant1Class: FieldRef<"StudentModel2", 'String'>
    readonly participant1Accommodation: FieldRef<"StudentModel2", 'String'>
    readonly participant2Name: FieldRef<"StudentModel2", 'String'>
    readonly participant2Gender: FieldRef<"StudentModel2", 'String'>
    readonly participant2Class: FieldRef<"StudentModel2", 'String'>
    readonly participant2Accommodation: FieldRef<"StudentModel2", 'String'>
    readonly additionalRequirements: FieldRef<"StudentModel2", 'String'>
    readonly declaration: FieldRef<"StudentModel2", 'Boolean'>
    readonly writeup: FieldRef<"StudentModel2", 'String'>
    readonly schoolId: FieldRef<"StudentModel2", 'Int'>
    readonly createdAt: FieldRef<"StudentModel2", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentModel2", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentModel2 findUnique
   */
  export type StudentModel2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2Include<ExtArgs> | null
    /**
     * Filter, which StudentModel2 to fetch.
     */
    where: StudentModel2WhereUniqueInput
  }

  /**
   * StudentModel2 findUniqueOrThrow
   */
  export type StudentModel2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2Include<ExtArgs> | null
    /**
     * Filter, which StudentModel2 to fetch.
     */
    where: StudentModel2WhereUniqueInput
  }

  /**
   * StudentModel2 findFirst
   */
  export type StudentModel2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2Include<ExtArgs> | null
    /**
     * Filter, which StudentModel2 to fetch.
     */
    where?: StudentModel2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentModel2s to fetch.
     */
    orderBy?: StudentModel2OrderByWithRelationInput | StudentModel2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentModel2s.
     */
    cursor?: StudentModel2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentModel2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentModel2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentModel2s.
     */
    distinct?: StudentModel2ScalarFieldEnum | StudentModel2ScalarFieldEnum[]
  }

  /**
   * StudentModel2 findFirstOrThrow
   */
  export type StudentModel2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2Include<ExtArgs> | null
    /**
     * Filter, which StudentModel2 to fetch.
     */
    where?: StudentModel2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentModel2s to fetch.
     */
    orderBy?: StudentModel2OrderByWithRelationInput | StudentModel2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentModel2s.
     */
    cursor?: StudentModel2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentModel2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentModel2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentModel2s.
     */
    distinct?: StudentModel2ScalarFieldEnum | StudentModel2ScalarFieldEnum[]
  }

  /**
   * StudentModel2 findMany
   */
  export type StudentModel2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2Include<ExtArgs> | null
    /**
     * Filter, which StudentModel2s to fetch.
     */
    where?: StudentModel2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentModel2s to fetch.
     */
    orderBy?: StudentModel2OrderByWithRelationInput | StudentModel2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentModel2s.
     */
    cursor?: StudentModel2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentModel2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentModel2s.
     */
    skip?: number
    distinct?: StudentModel2ScalarFieldEnum | StudentModel2ScalarFieldEnum[]
  }

  /**
   * StudentModel2 create
   */
  export type StudentModel2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2Include<ExtArgs> | null
    /**
     * The data needed to create a StudentModel2.
     */
    data: XOR<StudentModel2CreateInput, StudentModel2UncheckedCreateInput>
  }

  /**
   * StudentModel2 createMany
   */
  export type StudentModel2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentModel2s.
     */
    data: StudentModel2CreateManyInput | StudentModel2CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentModel2 createManyAndReturn
   */
  export type StudentModel2CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentModel2s.
     */
    data: StudentModel2CreateManyInput | StudentModel2CreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2IncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentModel2 update
   */
  export type StudentModel2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2Include<ExtArgs> | null
    /**
     * The data needed to update a StudentModel2.
     */
    data: XOR<StudentModel2UpdateInput, StudentModel2UncheckedUpdateInput>
    /**
     * Choose, which StudentModel2 to update.
     */
    where: StudentModel2WhereUniqueInput
  }

  /**
   * StudentModel2 updateMany
   */
  export type StudentModel2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentModel2s.
     */
    data: XOR<StudentModel2UpdateManyMutationInput, StudentModel2UncheckedUpdateManyInput>
    /**
     * Filter which StudentModel2s to update
     */
    where?: StudentModel2WhereInput
  }

  /**
   * StudentModel2 upsert
   */
  export type StudentModel2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2Include<ExtArgs> | null
    /**
     * The filter to search for the StudentModel2 to update in case it exists.
     */
    where: StudentModel2WhereUniqueInput
    /**
     * In case the StudentModel2 found by the `where` argument doesn't exist, create a new StudentModel2 with this data.
     */
    create: XOR<StudentModel2CreateInput, StudentModel2UncheckedCreateInput>
    /**
     * In case the StudentModel2 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentModel2UpdateInput, StudentModel2UncheckedUpdateInput>
  }

  /**
   * StudentModel2 delete
   */
  export type StudentModel2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2Include<ExtArgs> | null
    /**
     * Filter which StudentModel2 to delete.
     */
    where: StudentModel2WhereUniqueInput
  }

  /**
   * StudentModel2 deleteMany
   */
  export type StudentModel2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentModel2s to delete
     */
    where?: StudentModel2WhereInput
  }

  /**
   * StudentModel2 without action
   */
  export type StudentModel2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentModel2
     */
    select?: StudentModel2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentModel2Include<ExtArgs> | null
  }


  /**
   * Model EloquenceEnglish
   */

  export type AggregateEloquenceEnglish = {
    _count: EloquenceEnglishCountAggregateOutputType | null
    _avg: EloquenceEnglishAvgAggregateOutputType | null
    _sum: EloquenceEnglishSumAggregateOutputType | null
    _min: EloquenceEnglishMinAggregateOutputType | null
    _max: EloquenceEnglishMaxAggregateOutputType | null
  }

  export type EloquenceEnglishAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EloquenceEnglishSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EloquenceEnglishMinAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EloquenceEnglishMaxAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EloquenceEnglishCountAggregateOutputType = {
    id: number
    participantName: number
    participantGender: number
    participantClass: number
    accommodationRequired: number
    declaration: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EloquenceEnglishAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EloquenceEnglishSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EloquenceEnglishMinAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EloquenceEnglishMaxAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EloquenceEnglishCountAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EloquenceEnglishAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EloquenceEnglish to aggregate.
     */
    where?: EloquenceEnglishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceEnglishes to fetch.
     */
    orderBy?: EloquenceEnglishOrderByWithRelationInput | EloquenceEnglishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EloquenceEnglishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceEnglishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceEnglishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EloquenceEnglishes
    **/
    _count?: true | EloquenceEnglishCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EloquenceEnglishAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EloquenceEnglishSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EloquenceEnglishMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EloquenceEnglishMaxAggregateInputType
  }

  export type GetEloquenceEnglishAggregateType<T extends EloquenceEnglishAggregateArgs> = {
        [P in keyof T & keyof AggregateEloquenceEnglish]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEloquenceEnglish[P]>
      : GetScalarType<T[P], AggregateEloquenceEnglish[P]>
  }




  export type EloquenceEnglishGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EloquenceEnglishWhereInput
    orderBy?: EloquenceEnglishOrderByWithAggregationInput | EloquenceEnglishOrderByWithAggregationInput[]
    by: EloquenceEnglishScalarFieldEnum[] | EloquenceEnglishScalarFieldEnum
    having?: EloquenceEnglishScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EloquenceEnglishCountAggregateInputType | true
    _avg?: EloquenceEnglishAvgAggregateInputType
    _sum?: EloquenceEnglishSumAggregateInputType
    _min?: EloquenceEnglishMinAggregateInputType
    _max?: EloquenceEnglishMaxAggregateInputType
  }

  export type EloquenceEnglishGroupByOutputType = {
    id: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: EloquenceEnglishCountAggregateOutputType | null
    _avg: EloquenceEnglishAvgAggregateOutputType | null
    _sum: EloquenceEnglishSumAggregateOutputType | null
    _min: EloquenceEnglishMinAggregateOutputType | null
    _max: EloquenceEnglishMaxAggregateOutputType | null
  }

  type GetEloquenceEnglishGroupByPayload<T extends EloquenceEnglishGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EloquenceEnglishGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EloquenceEnglishGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EloquenceEnglishGroupByOutputType[P]>
            : GetScalarType<T[P], EloquenceEnglishGroupByOutputType[P]>
        }
      >
    >


  export type EloquenceEnglishSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eloquenceEnglish"]>

  export type EloquenceEnglishSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eloquenceEnglish"]>

  export type EloquenceEnglishSelectScalar = {
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EloquenceEnglishInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type EloquenceEnglishIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $EloquenceEnglishPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EloquenceEnglish"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      participantName: string
      participantGender: string
      participantClass: string
      accommodationRequired: string
      declaration: boolean
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eloquenceEnglish"]>
    composites: {}
  }

  type EloquenceEnglishGetPayload<S extends boolean | null | undefined | EloquenceEnglishDefaultArgs> = $Result.GetResult<Prisma.$EloquenceEnglishPayload, S>

  type EloquenceEnglishCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EloquenceEnglishFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EloquenceEnglishCountAggregateInputType | true
    }

  export interface EloquenceEnglishDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EloquenceEnglish'], meta: { name: 'EloquenceEnglish' } }
    /**
     * Find zero or one EloquenceEnglish that matches the filter.
     * @param {EloquenceEnglishFindUniqueArgs} args - Arguments to find a EloquenceEnglish
     * @example
     * // Get one EloquenceEnglish
     * const eloquenceEnglish = await prisma.eloquenceEnglish.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EloquenceEnglishFindUniqueArgs>(args: SelectSubset<T, EloquenceEnglishFindUniqueArgs<ExtArgs>>): Prisma__EloquenceEnglishClient<$Result.GetResult<Prisma.$EloquenceEnglishPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EloquenceEnglish that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EloquenceEnglishFindUniqueOrThrowArgs} args - Arguments to find a EloquenceEnglish
     * @example
     * // Get one EloquenceEnglish
     * const eloquenceEnglish = await prisma.eloquenceEnglish.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EloquenceEnglishFindUniqueOrThrowArgs>(args: SelectSubset<T, EloquenceEnglishFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EloquenceEnglishClient<$Result.GetResult<Prisma.$EloquenceEnglishPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EloquenceEnglish that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceEnglishFindFirstArgs} args - Arguments to find a EloquenceEnglish
     * @example
     * // Get one EloquenceEnglish
     * const eloquenceEnglish = await prisma.eloquenceEnglish.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EloquenceEnglishFindFirstArgs>(args?: SelectSubset<T, EloquenceEnglishFindFirstArgs<ExtArgs>>): Prisma__EloquenceEnglishClient<$Result.GetResult<Prisma.$EloquenceEnglishPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EloquenceEnglish that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceEnglishFindFirstOrThrowArgs} args - Arguments to find a EloquenceEnglish
     * @example
     * // Get one EloquenceEnglish
     * const eloquenceEnglish = await prisma.eloquenceEnglish.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EloquenceEnglishFindFirstOrThrowArgs>(args?: SelectSubset<T, EloquenceEnglishFindFirstOrThrowArgs<ExtArgs>>): Prisma__EloquenceEnglishClient<$Result.GetResult<Prisma.$EloquenceEnglishPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EloquenceEnglishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceEnglishFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EloquenceEnglishes
     * const eloquenceEnglishes = await prisma.eloquenceEnglish.findMany()
     * 
     * // Get first 10 EloquenceEnglishes
     * const eloquenceEnglishes = await prisma.eloquenceEnglish.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eloquenceEnglishWithIdOnly = await prisma.eloquenceEnglish.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EloquenceEnglishFindManyArgs>(args?: SelectSubset<T, EloquenceEnglishFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EloquenceEnglishPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EloquenceEnglish.
     * @param {EloquenceEnglishCreateArgs} args - Arguments to create a EloquenceEnglish.
     * @example
     * // Create one EloquenceEnglish
     * const EloquenceEnglish = await prisma.eloquenceEnglish.create({
     *   data: {
     *     // ... data to create a EloquenceEnglish
     *   }
     * })
     * 
     */
    create<T extends EloquenceEnglishCreateArgs>(args: SelectSubset<T, EloquenceEnglishCreateArgs<ExtArgs>>): Prisma__EloquenceEnglishClient<$Result.GetResult<Prisma.$EloquenceEnglishPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EloquenceEnglishes.
     * @param {EloquenceEnglishCreateManyArgs} args - Arguments to create many EloquenceEnglishes.
     * @example
     * // Create many EloquenceEnglishes
     * const eloquenceEnglish = await prisma.eloquenceEnglish.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EloquenceEnglishCreateManyArgs>(args?: SelectSubset<T, EloquenceEnglishCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EloquenceEnglishes and returns the data saved in the database.
     * @param {EloquenceEnglishCreateManyAndReturnArgs} args - Arguments to create many EloquenceEnglishes.
     * @example
     * // Create many EloquenceEnglishes
     * const eloquenceEnglish = await prisma.eloquenceEnglish.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EloquenceEnglishes and only return the `id`
     * const eloquenceEnglishWithIdOnly = await prisma.eloquenceEnglish.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EloquenceEnglishCreateManyAndReturnArgs>(args?: SelectSubset<T, EloquenceEnglishCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EloquenceEnglishPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EloquenceEnglish.
     * @param {EloquenceEnglishDeleteArgs} args - Arguments to delete one EloquenceEnglish.
     * @example
     * // Delete one EloquenceEnglish
     * const EloquenceEnglish = await prisma.eloquenceEnglish.delete({
     *   where: {
     *     // ... filter to delete one EloquenceEnglish
     *   }
     * })
     * 
     */
    delete<T extends EloquenceEnglishDeleteArgs>(args: SelectSubset<T, EloquenceEnglishDeleteArgs<ExtArgs>>): Prisma__EloquenceEnglishClient<$Result.GetResult<Prisma.$EloquenceEnglishPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EloquenceEnglish.
     * @param {EloquenceEnglishUpdateArgs} args - Arguments to update one EloquenceEnglish.
     * @example
     * // Update one EloquenceEnglish
     * const eloquenceEnglish = await prisma.eloquenceEnglish.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EloquenceEnglishUpdateArgs>(args: SelectSubset<T, EloquenceEnglishUpdateArgs<ExtArgs>>): Prisma__EloquenceEnglishClient<$Result.GetResult<Prisma.$EloquenceEnglishPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EloquenceEnglishes.
     * @param {EloquenceEnglishDeleteManyArgs} args - Arguments to filter EloquenceEnglishes to delete.
     * @example
     * // Delete a few EloquenceEnglishes
     * const { count } = await prisma.eloquenceEnglish.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EloquenceEnglishDeleteManyArgs>(args?: SelectSubset<T, EloquenceEnglishDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EloquenceEnglishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceEnglishUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EloquenceEnglishes
     * const eloquenceEnglish = await prisma.eloquenceEnglish.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EloquenceEnglishUpdateManyArgs>(args: SelectSubset<T, EloquenceEnglishUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EloquenceEnglish.
     * @param {EloquenceEnglishUpsertArgs} args - Arguments to update or create a EloquenceEnglish.
     * @example
     * // Update or create a EloquenceEnglish
     * const eloquenceEnglish = await prisma.eloquenceEnglish.upsert({
     *   create: {
     *     // ... data to create a EloquenceEnglish
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EloquenceEnglish we want to update
     *   }
     * })
     */
    upsert<T extends EloquenceEnglishUpsertArgs>(args: SelectSubset<T, EloquenceEnglishUpsertArgs<ExtArgs>>): Prisma__EloquenceEnglishClient<$Result.GetResult<Prisma.$EloquenceEnglishPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EloquenceEnglishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceEnglishCountArgs} args - Arguments to filter EloquenceEnglishes to count.
     * @example
     * // Count the number of EloquenceEnglishes
     * const count = await prisma.eloquenceEnglish.count({
     *   where: {
     *     // ... the filter for the EloquenceEnglishes we want to count
     *   }
     * })
    **/
    count<T extends EloquenceEnglishCountArgs>(
      args?: Subset<T, EloquenceEnglishCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EloquenceEnglishCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EloquenceEnglish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceEnglishAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EloquenceEnglishAggregateArgs>(args: Subset<T, EloquenceEnglishAggregateArgs>): Prisma.PrismaPromise<GetEloquenceEnglishAggregateType<T>>

    /**
     * Group by EloquenceEnglish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceEnglishGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EloquenceEnglishGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EloquenceEnglishGroupByArgs['orderBy'] }
        : { orderBy?: EloquenceEnglishGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EloquenceEnglishGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEloquenceEnglishGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EloquenceEnglish model
   */
  readonly fields: EloquenceEnglishFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EloquenceEnglish.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EloquenceEnglishClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EloquenceEnglish model
   */ 
  interface EloquenceEnglishFieldRefs {
    readonly id: FieldRef<"EloquenceEnglish", 'Int'>
    readonly participantName: FieldRef<"EloquenceEnglish", 'String'>
    readonly participantGender: FieldRef<"EloquenceEnglish", 'String'>
    readonly participantClass: FieldRef<"EloquenceEnglish", 'String'>
    readonly accommodationRequired: FieldRef<"EloquenceEnglish", 'String'>
    readonly declaration: FieldRef<"EloquenceEnglish", 'Boolean'>
    readonly schoolId: FieldRef<"EloquenceEnglish", 'Int'>
    readonly createdAt: FieldRef<"EloquenceEnglish", 'DateTime'>
    readonly updatedAt: FieldRef<"EloquenceEnglish", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EloquenceEnglish findUnique
   */
  export type EloquenceEnglishFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceEnglish to fetch.
     */
    where: EloquenceEnglishWhereUniqueInput
  }

  /**
   * EloquenceEnglish findUniqueOrThrow
   */
  export type EloquenceEnglishFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceEnglish to fetch.
     */
    where: EloquenceEnglishWhereUniqueInput
  }

  /**
   * EloquenceEnglish findFirst
   */
  export type EloquenceEnglishFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceEnglish to fetch.
     */
    where?: EloquenceEnglishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceEnglishes to fetch.
     */
    orderBy?: EloquenceEnglishOrderByWithRelationInput | EloquenceEnglishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EloquenceEnglishes.
     */
    cursor?: EloquenceEnglishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceEnglishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceEnglishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EloquenceEnglishes.
     */
    distinct?: EloquenceEnglishScalarFieldEnum | EloquenceEnglishScalarFieldEnum[]
  }

  /**
   * EloquenceEnglish findFirstOrThrow
   */
  export type EloquenceEnglishFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceEnglish to fetch.
     */
    where?: EloquenceEnglishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceEnglishes to fetch.
     */
    orderBy?: EloquenceEnglishOrderByWithRelationInput | EloquenceEnglishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EloquenceEnglishes.
     */
    cursor?: EloquenceEnglishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceEnglishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceEnglishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EloquenceEnglishes.
     */
    distinct?: EloquenceEnglishScalarFieldEnum | EloquenceEnglishScalarFieldEnum[]
  }

  /**
   * EloquenceEnglish findMany
   */
  export type EloquenceEnglishFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceEnglishes to fetch.
     */
    where?: EloquenceEnglishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceEnglishes to fetch.
     */
    orderBy?: EloquenceEnglishOrderByWithRelationInput | EloquenceEnglishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EloquenceEnglishes.
     */
    cursor?: EloquenceEnglishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceEnglishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceEnglishes.
     */
    skip?: number
    distinct?: EloquenceEnglishScalarFieldEnum | EloquenceEnglishScalarFieldEnum[]
  }

  /**
   * EloquenceEnglish create
   */
  export type EloquenceEnglishCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishInclude<ExtArgs> | null
    /**
     * The data needed to create a EloquenceEnglish.
     */
    data: XOR<EloquenceEnglishCreateInput, EloquenceEnglishUncheckedCreateInput>
  }

  /**
   * EloquenceEnglish createMany
   */
  export type EloquenceEnglishCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EloquenceEnglishes.
     */
    data: EloquenceEnglishCreateManyInput | EloquenceEnglishCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EloquenceEnglish createManyAndReturn
   */
  export type EloquenceEnglishCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EloquenceEnglishes.
     */
    data: EloquenceEnglishCreateManyInput | EloquenceEnglishCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EloquenceEnglish update
   */
  export type EloquenceEnglishUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishInclude<ExtArgs> | null
    /**
     * The data needed to update a EloquenceEnglish.
     */
    data: XOR<EloquenceEnglishUpdateInput, EloquenceEnglishUncheckedUpdateInput>
    /**
     * Choose, which EloquenceEnglish to update.
     */
    where: EloquenceEnglishWhereUniqueInput
  }

  /**
   * EloquenceEnglish updateMany
   */
  export type EloquenceEnglishUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EloquenceEnglishes.
     */
    data: XOR<EloquenceEnglishUpdateManyMutationInput, EloquenceEnglishUncheckedUpdateManyInput>
    /**
     * Filter which EloquenceEnglishes to update
     */
    where?: EloquenceEnglishWhereInput
  }

  /**
   * EloquenceEnglish upsert
   */
  export type EloquenceEnglishUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishInclude<ExtArgs> | null
    /**
     * The filter to search for the EloquenceEnglish to update in case it exists.
     */
    where: EloquenceEnglishWhereUniqueInput
    /**
     * In case the EloquenceEnglish found by the `where` argument doesn't exist, create a new EloquenceEnglish with this data.
     */
    create: XOR<EloquenceEnglishCreateInput, EloquenceEnglishUncheckedCreateInput>
    /**
     * In case the EloquenceEnglish was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EloquenceEnglishUpdateInput, EloquenceEnglishUncheckedUpdateInput>
  }

  /**
   * EloquenceEnglish delete
   */
  export type EloquenceEnglishDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishInclude<ExtArgs> | null
    /**
     * Filter which EloquenceEnglish to delete.
     */
    where: EloquenceEnglishWhereUniqueInput
  }

  /**
   * EloquenceEnglish deleteMany
   */
  export type EloquenceEnglishDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EloquenceEnglishes to delete
     */
    where?: EloquenceEnglishWhereInput
  }

  /**
   * EloquenceEnglish without action
   */
  export type EloquenceEnglishDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceEnglish
     */
    select?: EloquenceEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceEnglishInclude<ExtArgs> | null
  }


  /**
   * Model EloquenceHindi
   */

  export type AggregateEloquenceHindi = {
    _count: EloquenceHindiCountAggregateOutputType | null
    _avg: EloquenceHindiAvgAggregateOutputType | null
    _sum: EloquenceHindiSumAggregateOutputType | null
    _min: EloquenceHindiMinAggregateOutputType | null
    _max: EloquenceHindiMaxAggregateOutputType | null
  }

  export type EloquenceHindiAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EloquenceHindiSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EloquenceHindiMinAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EloquenceHindiMaxAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EloquenceHindiCountAggregateOutputType = {
    id: number
    participantName: number
    participantGender: number
    participantClass: number
    accommodationRequired: number
    declaration: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EloquenceHindiAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EloquenceHindiSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EloquenceHindiMinAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EloquenceHindiMaxAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EloquenceHindiCountAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EloquenceHindiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EloquenceHindi to aggregate.
     */
    where?: EloquenceHindiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceHindis to fetch.
     */
    orderBy?: EloquenceHindiOrderByWithRelationInput | EloquenceHindiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EloquenceHindiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceHindis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceHindis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EloquenceHindis
    **/
    _count?: true | EloquenceHindiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EloquenceHindiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EloquenceHindiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EloquenceHindiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EloquenceHindiMaxAggregateInputType
  }

  export type GetEloquenceHindiAggregateType<T extends EloquenceHindiAggregateArgs> = {
        [P in keyof T & keyof AggregateEloquenceHindi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEloquenceHindi[P]>
      : GetScalarType<T[P], AggregateEloquenceHindi[P]>
  }




  export type EloquenceHindiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EloquenceHindiWhereInput
    orderBy?: EloquenceHindiOrderByWithAggregationInput | EloquenceHindiOrderByWithAggregationInput[]
    by: EloquenceHindiScalarFieldEnum[] | EloquenceHindiScalarFieldEnum
    having?: EloquenceHindiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EloquenceHindiCountAggregateInputType | true
    _avg?: EloquenceHindiAvgAggregateInputType
    _sum?: EloquenceHindiSumAggregateInputType
    _min?: EloquenceHindiMinAggregateInputType
    _max?: EloquenceHindiMaxAggregateInputType
  }

  export type EloquenceHindiGroupByOutputType = {
    id: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: EloquenceHindiCountAggregateOutputType | null
    _avg: EloquenceHindiAvgAggregateOutputType | null
    _sum: EloquenceHindiSumAggregateOutputType | null
    _min: EloquenceHindiMinAggregateOutputType | null
    _max: EloquenceHindiMaxAggregateOutputType | null
  }

  type GetEloquenceHindiGroupByPayload<T extends EloquenceHindiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EloquenceHindiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EloquenceHindiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EloquenceHindiGroupByOutputType[P]>
            : GetScalarType<T[P], EloquenceHindiGroupByOutputType[P]>
        }
      >
    >


  export type EloquenceHindiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eloquenceHindi"]>

  export type EloquenceHindiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eloquenceHindi"]>

  export type EloquenceHindiSelectScalar = {
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EloquenceHindiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type EloquenceHindiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $EloquenceHindiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EloquenceHindi"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      participantName: string
      participantGender: string
      participantClass: string
      accommodationRequired: string
      declaration: boolean
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eloquenceHindi"]>
    composites: {}
  }

  type EloquenceHindiGetPayload<S extends boolean | null | undefined | EloquenceHindiDefaultArgs> = $Result.GetResult<Prisma.$EloquenceHindiPayload, S>

  type EloquenceHindiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EloquenceHindiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EloquenceHindiCountAggregateInputType | true
    }

  export interface EloquenceHindiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EloquenceHindi'], meta: { name: 'EloquenceHindi' } }
    /**
     * Find zero or one EloquenceHindi that matches the filter.
     * @param {EloquenceHindiFindUniqueArgs} args - Arguments to find a EloquenceHindi
     * @example
     * // Get one EloquenceHindi
     * const eloquenceHindi = await prisma.eloquenceHindi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EloquenceHindiFindUniqueArgs>(args: SelectSubset<T, EloquenceHindiFindUniqueArgs<ExtArgs>>): Prisma__EloquenceHindiClient<$Result.GetResult<Prisma.$EloquenceHindiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EloquenceHindi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EloquenceHindiFindUniqueOrThrowArgs} args - Arguments to find a EloquenceHindi
     * @example
     * // Get one EloquenceHindi
     * const eloquenceHindi = await prisma.eloquenceHindi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EloquenceHindiFindUniqueOrThrowArgs>(args: SelectSubset<T, EloquenceHindiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EloquenceHindiClient<$Result.GetResult<Prisma.$EloquenceHindiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EloquenceHindi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceHindiFindFirstArgs} args - Arguments to find a EloquenceHindi
     * @example
     * // Get one EloquenceHindi
     * const eloquenceHindi = await prisma.eloquenceHindi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EloquenceHindiFindFirstArgs>(args?: SelectSubset<T, EloquenceHindiFindFirstArgs<ExtArgs>>): Prisma__EloquenceHindiClient<$Result.GetResult<Prisma.$EloquenceHindiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EloquenceHindi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceHindiFindFirstOrThrowArgs} args - Arguments to find a EloquenceHindi
     * @example
     * // Get one EloquenceHindi
     * const eloquenceHindi = await prisma.eloquenceHindi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EloquenceHindiFindFirstOrThrowArgs>(args?: SelectSubset<T, EloquenceHindiFindFirstOrThrowArgs<ExtArgs>>): Prisma__EloquenceHindiClient<$Result.GetResult<Prisma.$EloquenceHindiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EloquenceHindis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceHindiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EloquenceHindis
     * const eloquenceHindis = await prisma.eloquenceHindi.findMany()
     * 
     * // Get first 10 EloquenceHindis
     * const eloquenceHindis = await prisma.eloquenceHindi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eloquenceHindiWithIdOnly = await prisma.eloquenceHindi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EloquenceHindiFindManyArgs>(args?: SelectSubset<T, EloquenceHindiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EloquenceHindiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EloquenceHindi.
     * @param {EloquenceHindiCreateArgs} args - Arguments to create a EloquenceHindi.
     * @example
     * // Create one EloquenceHindi
     * const EloquenceHindi = await prisma.eloquenceHindi.create({
     *   data: {
     *     // ... data to create a EloquenceHindi
     *   }
     * })
     * 
     */
    create<T extends EloquenceHindiCreateArgs>(args: SelectSubset<T, EloquenceHindiCreateArgs<ExtArgs>>): Prisma__EloquenceHindiClient<$Result.GetResult<Prisma.$EloquenceHindiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EloquenceHindis.
     * @param {EloquenceHindiCreateManyArgs} args - Arguments to create many EloquenceHindis.
     * @example
     * // Create many EloquenceHindis
     * const eloquenceHindi = await prisma.eloquenceHindi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EloquenceHindiCreateManyArgs>(args?: SelectSubset<T, EloquenceHindiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EloquenceHindis and returns the data saved in the database.
     * @param {EloquenceHindiCreateManyAndReturnArgs} args - Arguments to create many EloquenceHindis.
     * @example
     * // Create many EloquenceHindis
     * const eloquenceHindi = await prisma.eloquenceHindi.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EloquenceHindis and only return the `id`
     * const eloquenceHindiWithIdOnly = await prisma.eloquenceHindi.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EloquenceHindiCreateManyAndReturnArgs>(args?: SelectSubset<T, EloquenceHindiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EloquenceHindiPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EloquenceHindi.
     * @param {EloquenceHindiDeleteArgs} args - Arguments to delete one EloquenceHindi.
     * @example
     * // Delete one EloquenceHindi
     * const EloquenceHindi = await prisma.eloquenceHindi.delete({
     *   where: {
     *     // ... filter to delete one EloquenceHindi
     *   }
     * })
     * 
     */
    delete<T extends EloquenceHindiDeleteArgs>(args: SelectSubset<T, EloquenceHindiDeleteArgs<ExtArgs>>): Prisma__EloquenceHindiClient<$Result.GetResult<Prisma.$EloquenceHindiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EloquenceHindi.
     * @param {EloquenceHindiUpdateArgs} args - Arguments to update one EloquenceHindi.
     * @example
     * // Update one EloquenceHindi
     * const eloquenceHindi = await prisma.eloquenceHindi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EloquenceHindiUpdateArgs>(args: SelectSubset<T, EloquenceHindiUpdateArgs<ExtArgs>>): Prisma__EloquenceHindiClient<$Result.GetResult<Prisma.$EloquenceHindiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EloquenceHindis.
     * @param {EloquenceHindiDeleteManyArgs} args - Arguments to filter EloquenceHindis to delete.
     * @example
     * // Delete a few EloquenceHindis
     * const { count } = await prisma.eloquenceHindi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EloquenceHindiDeleteManyArgs>(args?: SelectSubset<T, EloquenceHindiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EloquenceHindis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceHindiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EloquenceHindis
     * const eloquenceHindi = await prisma.eloquenceHindi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EloquenceHindiUpdateManyArgs>(args: SelectSubset<T, EloquenceHindiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EloquenceHindi.
     * @param {EloquenceHindiUpsertArgs} args - Arguments to update or create a EloquenceHindi.
     * @example
     * // Update or create a EloquenceHindi
     * const eloquenceHindi = await prisma.eloquenceHindi.upsert({
     *   create: {
     *     // ... data to create a EloquenceHindi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EloquenceHindi we want to update
     *   }
     * })
     */
    upsert<T extends EloquenceHindiUpsertArgs>(args: SelectSubset<T, EloquenceHindiUpsertArgs<ExtArgs>>): Prisma__EloquenceHindiClient<$Result.GetResult<Prisma.$EloquenceHindiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EloquenceHindis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceHindiCountArgs} args - Arguments to filter EloquenceHindis to count.
     * @example
     * // Count the number of EloquenceHindis
     * const count = await prisma.eloquenceHindi.count({
     *   where: {
     *     // ... the filter for the EloquenceHindis we want to count
     *   }
     * })
    **/
    count<T extends EloquenceHindiCountArgs>(
      args?: Subset<T, EloquenceHindiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EloquenceHindiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EloquenceHindi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceHindiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EloquenceHindiAggregateArgs>(args: Subset<T, EloquenceHindiAggregateArgs>): Prisma.PrismaPromise<GetEloquenceHindiAggregateType<T>>

    /**
     * Group by EloquenceHindi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceHindiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EloquenceHindiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EloquenceHindiGroupByArgs['orderBy'] }
        : { orderBy?: EloquenceHindiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EloquenceHindiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEloquenceHindiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EloquenceHindi model
   */
  readonly fields: EloquenceHindiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EloquenceHindi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EloquenceHindiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EloquenceHindi model
   */ 
  interface EloquenceHindiFieldRefs {
    readonly id: FieldRef<"EloquenceHindi", 'Int'>
    readonly participantName: FieldRef<"EloquenceHindi", 'String'>
    readonly participantGender: FieldRef<"EloquenceHindi", 'String'>
    readonly participantClass: FieldRef<"EloquenceHindi", 'String'>
    readonly accommodationRequired: FieldRef<"EloquenceHindi", 'String'>
    readonly declaration: FieldRef<"EloquenceHindi", 'Boolean'>
    readonly schoolId: FieldRef<"EloquenceHindi", 'Int'>
    readonly createdAt: FieldRef<"EloquenceHindi", 'DateTime'>
    readonly updatedAt: FieldRef<"EloquenceHindi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EloquenceHindi findUnique
   */
  export type EloquenceHindiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceHindi to fetch.
     */
    where: EloquenceHindiWhereUniqueInput
  }

  /**
   * EloquenceHindi findUniqueOrThrow
   */
  export type EloquenceHindiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceHindi to fetch.
     */
    where: EloquenceHindiWhereUniqueInput
  }

  /**
   * EloquenceHindi findFirst
   */
  export type EloquenceHindiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceHindi to fetch.
     */
    where?: EloquenceHindiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceHindis to fetch.
     */
    orderBy?: EloquenceHindiOrderByWithRelationInput | EloquenceHindiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EloquenceHindis.
     */
    cursor?: EloquenceHindiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceHindis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceHindis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EloquenceHindis.
     */
    distinct?: EloquenceHindiScalarFieldEnum | EloquenceHindiScalarFieldEnum[]
  }

  /**
   * EloquenceHindi findFirstOrThrow
   */
  export type EloquenceHindiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceHindi to fetch.
     */
    where?: EloquenceHindiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceHindis to fetch.
     */
    orderBy?: EloquenceHindiOrderByWithRelationInput | EloquenceHindiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EloquenceHindis.
     */
    cursor?: EloquenceHindiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceHindis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceHindis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EloquenceHindis.
     */
    distinct?: EloquenceHindiScalarFieldEnum | EloquenceHindiScalarFieldEnum[]
  }

  /**
   * EloquenceHindi findMany
   */
  export type EloquenceHindiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceHindis to fetch.
     */
    where?: EloquenceHindiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceHindis to fetch.
     */
    orderBy?: EloquenceHindiOrderByWithRelationInput | EloquenceHindiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EloquenceHindis.
     */
    cursor?: EloquenceHindiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceHindis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceHindis.
     */
    skip?: number
    distinct?: EloquenceHindiScalarFieldEnum | EloquenceHindiScalarFieldEnum[]
  }

  /**
   * EloquenceHindi create
   */
  export type EloquenceHindiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiInclude<ExtArgs> | null
    /**
     * The data needed to create a EloquenceHindi.
     */
    data: XOR<EloquenceHindiCreateInput, EloquenceHindiUncheckedCreateInput>
  }

  /**
   * EloquenceHindi createMany
   */
  export type EloquenceHindiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EloquenceHindis.
     */
    data: EloquenceHindiCreateManyInput | EloquenceHindiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EloquenceHindi createManyAndReturn
   */
  export type EloquenceHindiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EloquenceHindis.
     */
    data: EloquenceHindiCreateManyInput | EloquenceHindiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EloquenceHindi update
   */
  export type EloquenceHindiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiInclude<ExtArgs> | null
    /**
     * The data needed to update a EloquenceHindi.
     */
    data: XOR<EloquenceHindiUpdateInput, EloquenceHindiUncheckedUpdateInput>
    /**
     * Choose, which EloquenceHindi to update.
     */
    where: EloquenceHindiWhereUniqueInput
  }

  /**
   * EloquenceHindi updateMany
   */
  export type EloquenceHindiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EloquenceHindis.
     */
    data: XOR<EloquenceHindiUpdateManyMutationInput, EloquenceHindiUncheckedUpdateManyInput>
    /**
     * Filter which EloquenceHindis to update
     */
    where?: EloquenceHindiWhereInput
  }

  /**
   * EloquenceHindi upsert
   */
  export type EloquenceHindiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiInclude<ExtArgs> | null
    /**
     * The filter to search for the EloquenceHindi to update in case it exists.
     */
    where: EloquenceHindiWhereUniqueInput
    /**
     * In case the EloquenceHindi found by the `where` argument doesn't exist, create a new EloquenceHindi with this data.
     */
    create: XOR<EloquenceHindiCreateInput, EloquenceHindiUncheckedCreateInput>
    /**
     * In case the EloquenceHindi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EloquenceHindiUpdateInput, EloquenceHindiUncheckedUpdateInput>
  }

  /**
   * EloquenceHindi delete
   */
  export type EloquenceHindiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiInclude<ExtArgs> | null
    /**
     * Filter which EloquenceHindi to delete.
     */
    where: EloquenceHindiWhereUniqueInput
  }

  /**
   * EloquenceHindi deleteMany
   */
  export type EloquenceHindiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EloquenceHindis to delete
     */
    where?: EloquenceHindiWhereInput
  }

  /**
   * EloquenceHindi without action
   */
  export type EloquenceHindiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceHindi
     */
    select?: EloquenceHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceHindiInclude<ExtArgs> | null
  }


  /**
   * Model EloquenceGujarati
   */

  export type AggregateEloquenceGujarati = {
    _count: EloquenceGujaratiCountAggregateOutputType | null
    _avg: EloquenceGujaratiAvgAggregateOutputType | null
    _sum: EloquenceGujaratiSumAggregateOutputType | null
    _min: EloquenceGujaratiMinAggregateOutputType | null
    _max: EloquenceGujaratiMaxAggregateOutputType | null
  }

  export type EloquenceGujaratiAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EloquenceGujaratiSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EloquenceGujaratiMinAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EloquenceGujaratiMaxAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EloquenceGujaratiCountAggregateOutputType = {
    id: number
    participantName: number
    participantGender: number
    participantClass: number
    accommodationRequired: number
    declaration: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EloquenceGujaratiAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EloquenceGujaratiSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EloquenceGujaratiMinAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EloquenceGujaratiMaxAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EloquenceGujaratiCountAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EloquenceGujaratiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EloquenceGujarati to aggregate.
     */
    where?: EloquenceGujaratiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceGujaratis to fetch.
     */
    orderBy?: EloquenceGujaratiOrderByWithRelationInput | EloquenceGujaratiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EloquenceGujaratiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceGujaratis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceGujaratis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EloquenceGujaratis
    **/
    _count?: true | EloquenceGujaratiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EloquenceGujaratiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EloquenceGujaratiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EloquenceGujaratiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EloquenceGujaratiMaxAggregateInputType
  }

  export type GetEloquenceGujaratiAggregateType<T extends EloquenceGujaratiAggregateArgs> = {
        [P in keyof T & keyof AggregateEloquenceGujarati]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEloquenceGujarati[P]>
      : GetScalarType<T[P], AggregateEloquenceGujarati[P]>
  }




  export type EloquenceGujaratiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EloquenceGujaratiWhereInput
    orderBy?: EloquenceGujaratiOrderByWithAggregationInput | EloquenceGujaratiOrderByWithAggregationInput[]
    by: EloquenceGujaratiScalarFieldEnum[] | EloquenceGujaratiScalarFieldEnum
    having?: EloquenceGujaratiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EloquenceGujaratiCountAggregateInputType | true
    _avg?: EloquenceGujaratiAvgAggregateInputType
    _sum?: EloquenceGujaratiSumAggregateInputType
    _min?: EloquenceGujaratiMinAggregateInputType
    _max?: EloquenceGujaratiMaxAggregateInputType
  }

  export type EloquenceGujaratiGroupByOutputType = {
    id: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: EloquenceGujaratiCountAggregateOutputType | null
    _avg: EloquenceGujaratiAvgAggregateOutputType | null
    _sum: EloquenceGujaratiSumAggregateOutputType | null
    _min: EloquenceGujaratiMinAggregateOutputType | null
    _max: EloquenceGujaratiMaxAggregateOutputType | null
  }

  type GetEloquenceGujaratiGroupByPayload<T extends EloquenceGujaratiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EloquenceGujaratiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EloquenceGujaratiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EloquenceGujaratiGroupByOutputType[P]>
            : GetScalarType<T[P], EloquenceGujaratiGroupByOutputType[P]>
        }
      >
    >


  export type EloquenceGujaratiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eloquenceGujarati"]>

  export type EloquenceGujaratiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eloquenceGujarati"]>

  export type EloquenceGujaratiSelectScalar = {
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EloquenceGujaratiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type EloquenceGujaratiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $EloquenceGujaratiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EloquenceGujarati"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      participantName: string
      participantGender: string
      participantClass: string
      accommodationRequired: string
      declaration: boolean
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eloquenceGujarati"]>
    composites: {}
  }

  type EloquenceGujaratiGetPayload<S extends boolean | null | undefined | EloquenceGujaratiDefaultArgs> = $Result.GetResult<Prisma.$EloquenceGujaratiPayload, S>

  type EloquenceGujaratiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EloquenceGujaratiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EloquenceGujaratiCountAggregateInputType | true
    }

  export interface EloquenceGujaratiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EloquenceGujarati'], meta: { name: 'EloquenceGujarati' } }
    /**
     * Find zero or one EloquenceGujarati that matches the filter.
     * @param {EloquenceGujaratiFindUniqueArgs} args - Arguments to find a EloquenceGujarati
     * @example
     * // Get one EloquenceGujarati
     * const eloquenceGujarati = await prisma.eloquenceGujarati.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EloquenceGujaratiFindUniqueArgs>(args: SelectSubset<T, EloquenceGujaratiFindUniqueArgs<ExtArgs>>): Prisma__EloquenceGujaratiClient<$Result.GetResult<Prisma.$EloquenceGujaratiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EloquenceGujarati that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EloquenceGujaratiFindUniqueOrThrowArgs} args - Arguments to find a EloquenceGujarati
     * @example
     * // Get one EloquenceGujarati
     * const eloquenceGujarati = await prisma.eloquenceGujarati.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EloquenceGujaratiFindUniqueOrThrowArgs>(args: SelectSubset<T, EloquenceGujaratiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EloquenceGujaratiClient<$Result.GetResult<Prisma.$EloquenceGujaratiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EloquenceGujarati that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceGujaratiFindFirstArgs} args - Arguments to find a EloquenceGujarati
     * @example
     * // Get one EloquenceGujarati
     * const eloquenceGujarati = await prisma.eloquenceGujarati.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EloquenceGujaratiFindFirstArgs>(args?: SelectSubset<T, EloquenceGujaratiFindFirstArgs<ExtArgs>>): Prisma__EloquenceGujaratiClient<$Result.GetResult<Prisma.$EloquenceGujaratiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EloquenceGujarati that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceGujaratiFindFirstOrThrowArgs} args - Arguments to find a EloquenceGujarati
     * @example
     * // Get one EloquenceGujarati
     * const eloquenceGujarati = await prisma.eloquenceGujarati.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EloquenceGujaratiFindFirstOrThrowArgs>(args?: SelectSubset<T, EloquenceGujaratiFindFirstOrThrowArgs<ExtArgs>>): Prisma__EloquenceGujaratiClient<$Result.GetResult<Prisma.$EloquenceGujaratiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EloquenceGujaratis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceGujaratiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EloquenceGujaratis
     * const eloquenceGujaratis = await prisma.eloquenceGujarati.findMany()
     * 
     * // Get first 10 EloquenceGujaratis
     * const eloquenceGujaratis = await prisma.eloquenceGujarati.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eloquenceGujaratiWithIdOnly = await prisma.eloquenceGujarati.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EloquenceGujaratiFindManyArgs>(args?: SelectSubset<T, EloquenceGujaratiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EloquenceGujaratiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EloquenceGujarati.
     * @param {EloquenceGujaratiCreateArgs} args - Arguments to create a EloquenceGujarati.
     * @example
     * // Create one EloquenceGujarati
     * const EloquenceGujarati = await prisma.eloquenceGujarati.create({
     *   data: {
     *     // ... data to create a EloquenceGujarati
     *   }
     * })
     * 
     */
    create<T extends EloquenceGujaratiCreateArgs>(args: SelectSubset<T, EloquenceGujaratiCreateArgs<ExtArgs>>): Prisma__EloquenceGujaratiClient<$Result.GetResult<Prisma.$EloquenceGujaratiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EloquenceGujaratis.
     * @param {EloquenceGujaratiCreateManyArgs} args - Arguments to create many EloquenceGujaratis.
     * @example
     * // Create many EloquenceGujaratis
     * const eloquenceGujarati = await prisma.eloquenceGujarati.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EloquenceGujaratiCreateManyArgs>(args?: SelectSubset<T, EloquenceGujaratiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EloquenceGujaratis and returns the data saved in the database.
     * @param {EloquenceGujaratiCreateManyAndReturnArgs} args - Arguments to create many EloquenceGujaratis.
     * @example
     * // Create many EloquenceGujaratis
     * const eloquenceGujarati = await prisma.eloquenceGujarati.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EloquenceGujaratis and only return the `id`
     * const eloquenceGujaratiWithIdOnly = await prisma.eloquenceGujarati.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EloquenceGujaratiCreateManyAndReturnArgs>(args?: SelectSubset<T, EloquenceGujaratiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EloquenceGujaratiPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EloquenceGujarati.
     * @param {EloquenceGujaratiDeleteArgs} args - Arguments to delete one EloquenceGujarati.
     * @example
     * // Delete one EloquenceGujarati
     * const EloquenceGujarati = await prisma.eloquenceGujarati.delete({
     *   where: {
     *     // ... filter to delete one EloquenceGujarati
     *   }
     * })
     * 
     */
    delete<T extends EloquenceGujaratiDeleteArgs>(args: SelectSubset<T, EloquenceGujaratiDeleteArgs<ExtArgs>>): Prisma__EloquenceGujaratiClient<$Result.GetResult<Prisma.$EloquenceGujaratiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EloquenceGujarati.
     * @param {EloquenceGujaratiUpdateArgs} args - Arguments to update one EloquenceGujarati.
     * @example
     * // Update one EloquenceGujarati
     * const eloquenceGujarati = await prisma.eloquenceGujarati.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EloquenceGujaratiUpdateArgs>(args: SelectSubset<T, EloquenceGujaratiUpdateArgs<ExtArgs>>): Prisma__EloquenceGujaratiClient<$Result.GetResult<Prisma.$EloquenceGujaratiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EloquenceGujaratis.
     * @param {EloquenceGujaratiDeleteManyArgs} args - Arguments to filter EloquenceGujaratis to delete.
     * @example
     * // Delete a few EloquenceGujaratis
     * const { count } = await prisma.eloquenceGujarati.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EloquenceGujaratiDeleteManyArgs>(args?: SelectSubset<T, EloquenceGujaratiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EloquenceGujaratis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceGujaratiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EloquenceGujaratis
     * const eloquenceGujarati = await prisma.eloquenceGujarati.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EloquenceGujaratiUpdateManyArgs>(args: SelectSubset<T, EloquenceGujaratiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EloquenceGujarati.
     * @param {EloquenceGujaratiUpsertArgs} args - Arguments to update or create a EloquenceGujarati.
     * @example
     * // Update or create a EloquenceGujarati
     * const eloquenceGujarati = await prisma.eloquenceGujarati.upsert({
     *   create: {
     *     // ... data to create a EloquenceGujarati
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EloquenceGujarati we want to update
     *   }
     * })
     */
    upsert<T extends EloquenceGujaratiUpsertArgs>(args: SelectSubset<T, EloquenceGujaratiUpsertArgs<ExtArgs>>): Prisma__EloquenceGujaratiClient<$Result.GetResult<Prisma.$EloquenceGujaratiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EloquenceGujaratis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceGujaratiCountArgs} args - Arguments to filter EloquenceGujaratis to count.
     * @example
     * // Count the number of EloquenceGujaratis
     * const count = await prisma.eloquenceGujarati.count({
     *   where: {
     *     // ... the filter for the EloquenceGujaratis we want to count
     *   }
     * })
    **/
    count<T extends EloquenceGujaratiCountArgs>(
      args?: Subset<T, EloquenceGujaratiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EloquenceGujaratiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EloquenceGujarati.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceGujaratiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EloquenceGujaratiAggregateArgs>(args: Subset<T, EloquenceGujaratiAggregateArgs>): Prisma.PrismaPromise<GetEloquenceGujaratiAggregateType<T>>

    /**
     * Group by EloquenceGujarati.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EloquenceGujaratiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EloquenceGujaratiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EloquenceGujaratiGroupByArgs['orderBy'] }
        : { orderBy?: EloquenceGujaratiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EloquenceGujaratiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEloquenceGujaratiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EloquenceGujarati model
   */
  readonly fields: EloquenceGujaratiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EloquenceGujarati.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EloquenceGujaratiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EloquenceGujarati model
   */ 
  interface EloquenceGujaratiFieldRefs {
    readonly id: FieldRef<"EloquenceGujarati", 'Int'>
    readonly participantName: FieldRef<"EloquenceGujarati", 'String'>
    readonly participantGender: FieldRef<"EloquenceGujarati", 'String'>
    readonly participantClass: FieldRef<"EloquenceGujarati", 'String'>
    readonly accommodationRequired: FieldRef<"EloquenceGujarati", 'String'>
    readonly declaration: FieldRef<"EloquenceGujarati", 'Boolean'>
    readonly schoolId: FieldRef<"EloquenceGujarati", 'Int'>
    readonly createdAt: FieldRef<"EloquenceGujarati", 'DateTime'>
    readonly updatedAt: FieldRef<"EloquenceGujarati", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EloquenceGujarati findUnique
   */
  export type EloquenceGujaratiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceGujarati to fetch.
     */
    where: EloquenceGujaratiWhereUniqueInput
  }

  /**
   * EloquenceGujarati findUniqueOrThrow
   */
  export type EloquenceGujaratiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceGujarati to fetch.
     */
    where: EloquenceGujaratiWhereUniqueInput
  }

  /**
   * EloquenceGujarati findFirst
   */
  export type EloquenceGujaratiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceGujarati to fetch.
     */
    where?: EloquenceGujaratiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceGujaratis to fetch.
     */
    orderBy?: EloquenceGujaratiOrderByWithRelationInput | EloquenceGujaratiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EloquenceGujaratis.
     */
    cursor?: EloquenceGujaratiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceGujaratis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceGujaratis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EloquenceGujaratis.
     */
    distinct?: EloquenceGujaratiScalarFieldEnum | EloquenceGujaratiScalarFieldEnum[]
  }

  /**
   * EloquenceGujarati findFirstOrThrow
   */
  export type EloquenceGujaratiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceGujarati to fetch.
     */
    where?: EloquenceGujaratiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceGujaratis to fetch.
     */
    orderBy?: EloquenceGujaratiOrderByWithRelationInput | EloquenceGujaratiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EloquenceGujaratis.
     */
    cursor?: EloquenceGujaratiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceGujaratis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceGujaratis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EloquenceGujaratis.
     */
    distinct?: EloquenceGujaratiScalarFieldEnum | EloquenceGujaratiScalarFieldEnum[]
  }

  /**
   * EloquenceGujarati findMany
   */
  export type EloquenceGujaratiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiInclude<ExtArgs> | null
    /**
     * Filter, which EloquenceGujaratis to fetch.
     */
    where?: EloquenceGujaratiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EloquenceGujaratis to fetch.
     */
    orderBy?: EloquenceGujaratiOrderByWithRelationInput | EloquenceGujaratiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EloquenceGujaratis.
     */
    cursor?: EloquenceGujaratiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EloquenceGujaratis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EloquenceGujaratis.
     */
    skip?: number
    distinct?: EloquenceGujaratiScalarFieldEnum | EloquenceGujaratiScalarFieldEnum[]
  }

  /**
   * EloquenceGujarati create
   */
  export type EloquenceGujaratiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiInclude<ExtArgs> | null
    /**
     * The data needed to create a EloquenceGujarati.
     */
    data: XOR<EloquenceGujaratiCreateInput, EloquenceGujaratiUncheckedCreateInput>
  }

  /**
   * EloquenceGujarati createMany
   */
  export type EloquenceGujaratiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EloquenceGujaratis.
     */
    data: EloquenceGujaratiCreateManyInput | EloquenceGujaratiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EloquenceGujarati createManyAndReturn
   */
  export type EloquenceGujaratiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EloquenceGujaratis.
     */
    data: EloquenceGujaratiCreateManyInput | EloquenceGujaratiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EloquenceGujarati update
   */
  export type EloquenceGujaratiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiInclude<ExtArgs> | null
    /**
     * The data needed to update a EloquenceGujarati.
     */
    data: XOR<EloquenceGujaratiUpdateInput, EloquenceGujaratiUncheckedUpdateInput>
    /**
     * Choose, which EloquenceGujarati to update.
     */
    where: EloquenceGujaratiWhereUniqueInput
  }

  /**
   * EloquenceGujarati updateMany
   */
  export type EloquenceGujaratiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EloquenceGujaratis.
     */
    data: XOR<EloquenceGujaratiUpdateManyMutationInput, EloquenceGujaratiUncheckedUpdateManyInput>
    /**
     * Filter which EloquenceGujaratis to update
     */
    where?: EloquenceGujaratiWhereInput
  }

  /**
   * EloquenceGujarati upsert
   */
  export type EloquenceGujaratiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiInclude<ExtArgs> | null
    /**
     * The filter to search for the EloquenceGujarati to update in case it exists.
     */
    where: EloquenceGujaratiWhereUniqueInput
    /**
     * In case the EloquenceGujarati found by the `where` argument doesn't exist, create a new EloquenceGujarati with this data.
     */
    create: XOR<EloquenceGujaratiCreateInput, EloquenceGujaratiUncheckedCreateInput>
    /**
     * In case the EloquenceGujarati was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EloquenceGujaratiUpdateInput, EloquenceGujaratiUncheckedUpdateInput>
  }

  /**
   * EloquenceGujarati delete
   */
  export type EloquenceGujaratiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiInclude<ExtArgs> | null
    /**
     * Filter which EloquenceGujarati to delete.
     */
    where: EloquenceGujaratiWhereUniqueInput
  }

  /**
   * EloquenceGujarati deleteMany
   */
  export type EloquenceGujaratiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EloquenceGujaratis to delete
     */
    where?: EloquenceGujaratiWhereInput
  }

  /**
   * EloquenceGujarati without action
   */
  export type EloquenceGujaratiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EloquenceGujarati
     */
    select?: EloquenceGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EloquenceGujaratiInclude<ExtArgs> | null
  }


  /**
   * Model EssayEnglish
   */

  export type AggregateEssayEnglish = {
    _count: EssayEnglishCountAggregateOutputType | null
    _avg: EssayEnglishAvgAggregateOutputType | null
    _sum: EssayEnglishSumAggregateOutputType | null
    _min: EssayEnglishMinAggregateOutputType | null
    _max: EssayEnglishMaxAggregateOutputType | null
  }

  export type EssayEnglishAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EssayEnglishSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EssayEnglishMinAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    essayFileUrl: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EssayEnglishMaxAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    essayFileUrl: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EssayEnglishCountAggregateOutputType = {
    id: number
    participantName: number
    participantGender: number
    participantClass: number
    accommodationRequired: number
    essayFileUrl: number
    declaration: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EssayEnglishAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EssayEnglishSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EssayEnglishMinAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    essayFileUrl?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EssayEnglishMaxAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    essayFileUrl?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EssayEnglishCountAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    essayFileUrl?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EssayEnglishAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EssayEnglish to aggregate.
     */
    where?: EssayEnglishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayEnglishes to fetch.
     */
    orderBy?: EssayEnglishOrderByWithRelationInput | EssayEnglishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EssayEnglishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayEnglishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayEnglishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EssayEnglishes
    **/
    _count?: true | EssayEnglishCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EssayEnglishAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EssayEnglishSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EssayEnglishMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EssayEnglishMaxAggregateInputType
  }

  export type GetEssayEnglishAggregateType<T extends EssayEnglishAggregateArgs> = {
        [P in keyof T & keyof AggregateEssayEnglish]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEssayEnglish[P]>
      : GetScalarType<T[P], AggregateEssayEnglish[P]>
  }




  export type EssayEnglishGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EssayEnglishWhereInput
    orderBy?: EssayEnglishOrderByWithAggregationInput | EssayEnglishOrderByWithAggregationInput[]
    by: EssayEnglishScalarFieldEnum[] | EssayEnglishScalarFieldEnum
    having?: EssayEnglishScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EssayEnglishCountAggregateInputType | true
    _avg?: EssayEnglishAvgAggregateInputType
    _sum?: EssayEnglishSumAggregateInputType
    _min?: EssayEnglishMinAggregateInputType
    _max?: EssayEnglishMaxAggregateInputType
  }

  export type EssayEnglishGroupByOutputType = {
    id: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: EssayEnglishCountAggregateOutputType | null
    _avg: EssayEnglishAvgAggregateOutputType | null
    _sum: EssayEnglishSumAggregateOutputType | null
    _min: EssayEnglishMinAggregateOutputType | null
    _max: EssayEnglishMaxAggregateOutputType | null
  }

  type GetEssayEnglishGroupByPayload<T extends EssayEnglishGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EssayEnglishGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EssayEnglishGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EssayEnglishGroupByOutputType[P]>
            : GetScalarType<T[P], EssayEnglishGroupByOutputType[P]>
        }
      >
    >


  export type EssayEnglishSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    essayFileUrl?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["essayEnglish"]>

  export type EssayEnglishSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    essayFileUrl?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["essayEnglish"]>

  export type EssayEnglishSelectScalar = {
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    essayFileUrl?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EssayEnglishInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type EssayEnglishIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $EssayEnglishPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EssayEnglish"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      participantName: string
      participantGender: string
      participantClass: string
      accommodationRequired: string
      essayFileUrl: string
      declaration: boolean
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["essayEnglish"]>
    composites: {}
  }

  type EssayEnglishGetPayload<S extends boolean | null | undefined | EssayEnglishDefaultArgs> = $Result.GetResult<Prisma.$EssayEnglishPayload, S>

  type EssayEnglishCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EssayEnglishFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EssayEnglishCountAggregateInputType | true
    }

  export interface EssayEnglishDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EssayEnglish'], meta: { name: 'EssayEnglish' } }
    /**
     * Find zero or one EssayEnglish that matches the filter.
     * @param {EssayEnglishFindUniqueArgs} args - Arguments to find a EssayEnglish
     * @example
     * // Get one EssayEnglish
     * const essayEnglish = await prisma.essayEnglish.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EssayEnglishFindUniqueArgs>(args: SelectSubset<T, EssayEnglishFindUniqueArgs<ExtArgs>>): Prisma__EssayEnglishClient<$Result.GetResult<Prisma.$EssayEnglishPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EssayEnglish that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EssayEnglishFindUniqueOrThrowArgs} args - Arguments to find a EssayEnglish
     * @example
     * // Get one EssayEnglish
     * const essayEnglish = await prisma.essayEnglish.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EssayEnglishFindUniqueOrThrowArgs>(args: SelectSubset<T, EssayEnglishFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EssayEnglishClient<$Result.GetResult<Prisma.$EssayEnglishPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EssayEnglish that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayEnglishFindFirstArgs} args - Arguments to find a EssayEnglish
     * @example
     * // Get one EssayEnglish
     * const essayEnglish = await prisma.essayEnglish.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EssayEnglishFindFirstArgs>(args?: SelectSubset<T, EssayEnglishFindFirstArgs<ExtArgs>>): Prisma__EssayEnglishClient<$Result.GetResult<Prisma.$EssayEnglishPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EssayEnglish that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayEnglishFindFirstOrThrowArgs} args - Arguments to find a EssayEnglish
     * @example
     * // Get one EssayEnglish
     * const essayEnglish = await prisma.essayEnglish.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EssayEnglishFindFirstOrThrowArgs>(args?: SelectSubset<T, EssayEnglishFindFirstOrThrowArgs<ExtArgs>>): Prisma__EssayEnglishClient<$Result.GetResult<Prisma.$EssayEnglishPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EssayEnglishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayEnglishFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EssayEnglishes
     * const essayEnglishes = await prisma.essayEnglish.findMany()
     * 
     * // Get first 10 EssayEnglishes
     * const essayEnglishes = await prisma.essayEnglish.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const essayEnglishWithIdOnly = await prisma.essayEnglish.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EssayEnglishFindManyArgs>(args?: SelectSubset<T, EssayEnglishFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EssayEnglishPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EssayEnglish.
     * @param {EssayEnglishCreateArgs} args - Arguments to create a EssayEnglish.
     * @example
     * // Create one EssayEnglish
     * const EssayEnglish = await prisma.essayEnglish.create({
     *   data: {
     *     // ... data to create a EssayEnglish
     *   }
     * })
     * 
     */
    create<T extends EssayEnglishCreateArgs>(args: SelectSubset<T, EssayEnglishCreateArgs<ExtArgs>>): Prisma__EssayEnglishClient<$Result.GetResult<Prisma.$EssayEnglishPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EssayEnglishes.
     * @param {EssayEnglishCreateManyArgs} args - Arguments to create many EssayEnglishes.
     * @example
     * // Create many EssayEnglishes
     * const essayEnglish = await prisma.essayEnglish.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EssayEnglishCreateManyArgs>(args?: SelectSubset<T, EssayEnglishCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EssayEnglishes and returns the data saved in the database.
     * @param {EssayEnglishCreateManyAndReturnArgs} args - Arguments to create many EssayEnglishes.
     * @example
     * // Create many EssayEnglishes
     * const essayEnglish = await prisma.essayEnglish.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EssayEnglishes and only return the `id`
     * const essayEnglishWithIdOnly = await prisma.essayEnglish.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EssayEnglishCreateManyAndReturnArgs>(args?: SelectSubset<T, EssayEnglishCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EssayEnglishPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EssayEnglish.
     * @param {EssayEnglishDeleteArgs} args - Arguments to delete one EssayEnglish.
     * @example
     * // Delete one EssayEnglish
     * const EssayEnglish = await prisma.essayEnglish.delete({
     *   where: {
     *     // ... filter to delete one EssayEnglish
     *   }
     * })
     * 
     */
    delete<T extends EssayEnglishDeleteArgs>(args: SelectSubset<T, EssayEnglishDeleteArgs<ExtArgs>>): Prisma__EssayEnglishClient<$Result.GetResult<Prisma.$EssayEnglishPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EssayEnglish.
     * @param {EssayEnglishUpdateArgs} args - Arguments to update one EssayEnglish.
     * @example
     * // Update one EssayEnglish
     * const essayEnglish = await prisma.essayEnglish.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EssayEnglishUpdateArgs>(args: SelectSubset<T, EssayEnglishUpdateArgs<ExtArgs>>): Prisma__EssayEnglishClient<$Result.GetResult<Prisma.$EssayEnglishPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EssayEnglishes.
     * @param {EssayEnglishDeleteManyArgs} args - Arguments to filter EssayEnglishes to delete.
     * @example
     * // Delete a few EssayEnglishes
     * const { count } = await prisma.essayEnglish.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EssayEnglishDeleteManyArgs>(args?: SelectSubset<T, EssayEnglishDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EssayEnglishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayEnglishUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EssayEnglishes
     * const essayEnglish = await prisma.essayEnglish.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EssayEnglishUpdateManyArgs>(args: SelectSubset<T, EssayEnglishUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EssayEnglish.
     * @param {EssayEnglishUpsertArgs} args - Arguments to update or create a EssayEnglish.
     * @example
     * // Update or create a EssayEnglish
     * const essayEnglish = await prisma.essayEnglish.upsert({
     *   create: {
     *     // ... data to create a EssayEnglish
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EssayEnglish we want to update
     *   }
     * })
     */
    upsert<T extends EssayEnglishUpsertArgs>(args: SelectSubset<T, EssayEnglishUpsertArgs<ExtArgs>>): Prisma__EssayEnglishClient<$Result.GetResult<Prisma.$EssayEnglishPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EssayEnglishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayEnglishCountArgs} args - Arguments to filter EssayEnglishes to count.
     * @example
     * // Count the number of EssayEnglishes
     * const count = await prisma.essayEnglish.count({
     *   where: {
     *     // ... the filter for the EssayEnglishes we want to count
     *   }
     * })
    **/
    count<T extends EssayEnglishCountArgs>(
      args?: Subset<T, EssayEnglishCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EssayEnglishCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EssayEnglish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayEnglishAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EssayEnglishAggregateArgs>(args: Subset<T, EssayEnglishAggregateArgs>): Prisma.PrismaPromise<GetEssayEnglishAggregateType<T>>

    /**
     * Group by EssayEnglish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayEnglishGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EssayEnglishGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EssayEnglishGroupByArgs['orderBy'] }
        : { orderBy?: EssayEnglishGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EssayEnglishGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEssayEnglishGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EssayEnglish model
   */
  readonly fields: EssayEnglishFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EssayEnglish.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EssayEnglishClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EssayEnglish model
   */ 
  interface EssayEnglishFieldRefs {
    readonly id: FieldRef<"EssayEnglish", 'Int'>
    readonly participantName: FieldRef<"EssayEnglish", 'String'>
    readonly participantGender: FieldRef<"EssayEnglish", 'String'>
    readonly participantClass: FieldRef<"EssayEnglish", 'String'>
    readonly accommodationRequired: FieldRef<"EssayEnglish", 'String'>
    readonly essayFileUrl: FieldRef<"EssayEnglish", 'String'>
    readonly declaration: FieldRef<"EssayEnglish", 'Boolean'>
    readonly schoolId: FieldRef<"EssayEnglish", 'Int'>
    readonly createdAt: FieldRef<"EssayEnglish", 'DateTime'>
    readonly updatedAt: FieldRef<"EssayEnglish", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EssayEnglish findUnique
   */
  export type EssayEnglishFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishInclude<ExtArgs> | null
    /**
     * Filter, which EssayEnglish to fetch.
     */
    where: EssayEnglishWhereUniqueInput
  }

  /**
   * EssayEnglish findUniqueOrThrow
   */
  export type EssayEnglishFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishInclude<ExtArgs> | null
    /**
     * Filter, which EssayEnglish to fetch.
     */
    where: EssayEnglishWhereUniqueInput
  }

  /**
   * EssayEnglish findFirst
   */
  export type EssayEnglishFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishInclude<ExtArgs> | null
    /**
     * Filter, which EssayEnglish to fetch.
     */
    where?: EssayEnglishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayEnglishes to fetch.
     */
    orderBy?: EssayEnglishOrderByWithRelationInput | EssayEnglishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EssayEnglishes.
     */
    cursor?: EssayEnglishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayEnglishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayEnglishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EssayEnglishes.
     */
    distinct?: EssayEnglishScalarFieldEnum | EssayEnglishScalarFieldEnum[]
  }

  /**
   * EssayEnglish findFirstOrThrow
   */
  export type EssayEnglishFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishInclude<ExtArgs> | null
    /**
     * Filter, which EssayEnglish to fetch.
     */
    where?: EssayEnglishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayEnglishes to fetch.
     */
    orderBy?: EssayEnglishOrderByWithRelationInput | EssayEnglishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EssayEnglishes.
     */
    cursor?: EssayEnglishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayEnglishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayEnglishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EssayEnglishes.
     */
    distinct?: EssayEnglishScalarFieldEnum | EssayEnglishScalarFieldEnum[]
  }

  /**
   * EssayEnglish findMany
   */
  export type EssayEnglishFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishInclude<ExtArgs> | null
    /**
     * Filter, which EssayEnglishes to fetch.
     */
    where?: EssayEnglishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayEnglishes to fetch.
     */
    orderBy?: EssayEnglishOrderByWithRelationInput | EssayEnglishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EssayEnglishes.
     */
    cursor?: EssayEnglishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayEnglishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayEnglishes.
     */
    skip?: number
    distinct?: EssayEnglishScalarFieldEnum | EssayEnglishScalarFieldEnum[]
  }

  /**
   * EssayEnglish create
   */
  export type EssayEnglishCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishInclude<ExtArgs> | null
    /**
     * The data needed to create a EssayEnglish.
     */
    data: XOR<EssayEnglishCreateInput, EssayEnglishUncheckedCreateInput>
  }

  /**
   * EssayEnglish createMany
   */
  export type EssayEnglishCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EssayEnglishes.
     */
    data: EssayEnglishCreateManyInput | EssayEnglishCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EssayEnglish createManyAndReturn
   */
  export type EssayEnglishCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EssayEnglishes.
     */
    data: EssayEnglishCreateManyInput | EssayEnglishCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EssayEnglish update
   */
  export type EssayEnglishUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishInclude<ExtArgs> | null
    /**
     * The data needed to update a EssayEnglish.
     */
    data: XOR<EssayEnglishUpdateInput, EssayEnglishUncheckedUpdateInput>
    /**
     * Choose, which EssayEnglish to update.
     */
    where: EssayEnglishWhereUniqueInput
  }

  /**
   * EssayEnglish updateMany
   */
  export type EssayEnglishUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EssayEnglishes.
     */
    data: XOR<EssayEnglishUpdateManyMutationInput, EssayEnglishUncheckedUpdateManyInput>
    /**
     * Filter which EssayEnglishes to update
     */
    where?: EssayEnglishWhereInput
  }

  /**
   * EssayEnglish upsert
   */
  export type EssayEnglishUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishInclude<ExtArgs> | null
    /**
     * The filter to search for the EssayEnglish to update in case it exists.
     */
    where: EssayEnglishWhereUniqueInput
    /**
     * In case the EssayEnglish found by the `where` argument doesn't exist, create a new EssayEnglish with this data.
     */
    create: XOR<EssayEnglishCreateInput, EssayEnglishUncheckedCreateInput>
    /**
     * In case the EssayEnglish was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EssayEnglishUpdateInput, EssayEnglishUncheckedUpdateInput>
  }

  /**
   * EssayEnglish delete
   */
  export type EssayEnglishDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishInclude<ExtArgs> | null
    /**
     * Filter which EssayEnglish to delete.
     */
    where: EssayEnglishWhereUniqueInput
  }

  /**
   * EssayEnglish deleteMany
   */
  export type EssayEnglishDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EssayEnglishes to delete
     */
    where?: EssayEnglishWhereInput
  }

  /**
   * EssayEnglish without action
   */
  export type EssayEnglishDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayEnglish
     */
    select?: EssayEnglishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayEnglishInclude<ExtArgs> | null
  }


  /**
   * Model EssayHindi
   */

  export type AggregateEssayHindi = {
    _count: EssayHindiCountAggregateOutputType | null
    _avg: EssayHindiAvgAggregateOutputType | null
    _sum: EssayHindiSumAggregateOutputType | null
    _min: EssayHindiMinAggregateOutputType | null
    _max: EssayHindiMaxAggregateOutputType | null
  }

  export type EssayHindiAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EssayHindiSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EssayHindiMinAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    essayFileUrl: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EssayHindiMaxAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    essayFileUrl: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EssayHindiCountAggregateOutputType = {
    id: number
    participantName: number
    participantGender: number
    participantClass: number
    accommodationRequired: number
    essayFileUrl: number
    declaration: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EssayHindiAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EssayHindiSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EssayHindiMinAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    essayFileUrl?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EssayHindiMaxAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    essayFileUrl?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EssayHindiCountAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    essayFileUrl?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EssayHindiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EssayHindi to aggregate.
     */
    where?: EssayHindiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayHindis to fetch.
     */
    orderBy?: EssayHindiOrderByWithRelationInput | EssayHindiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EssayHindiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayHindis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayHindis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EssayHindis
    **/
    _count?: true | EssayHindiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EssayHindiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EssayHindiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EssayHindiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EssayHindiMaxAggregateInputType
  }

  export type GetEssayHindiAggregateType<T extends EssayHindiAggregateArgs> = {
        [P in keyof T & keyof AggregateEssayHindi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEssayHindi[P]>
      : GetScalarType<T[P], AggregateEssayHindi[P]>
  }




  export type EssayHindiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EssayHindiWhereInput
    orderBy?: EssayHindiOrderByWithAggregationInput | EssayHindiOrderByWithAggregationInput[]
    by: EssayHindiScalarFieldEnum[] | EssayHindiScalarFieldEnum
    having?: EssayHindiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EssayHindiCountAggregateInputType | true
    _avg?: EssayHindiAvgAggregateInputType
    _sum?: EssayHindiSumAggregateInputType
    _min?: EssayHindiMinAggregateInputType
    _max?: EssayHindiMaxAggregateInputType
  }

  export type EssayHindiGroupByOutputType = {
    id: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: EssayHindiCountAggregateOutputType | null
    _avg: EssayHindiAvgAggregateOutputType | null
    _sum: EssayHindiSumAggregateOutputType | null
    _min: EssayHindiMinAggregateOutputType | null
    _max: EssayHindiMaxAggregateOutputType | null
  }

  type GetEssayHindiGroupByPayload<T extends EssayHindiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EssayHindiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EssayHindiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EssayHindiGroupByOutputType[P]>
            : GetScalarType<T[P], EssayHindiGroupByOutputType[P]>
        }
      >
    >


  export type EssayHindiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    essayFileUrl?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["essayHindi"]>

  export type EssayHindiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    essayFileUrl?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["essayHindi"]>

  export type EssayHindiSelectScalar = {
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    essayFileUrl?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EssayHindiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type EssayHindiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $EssayHindiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EssayHindi"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      participantName: string
      participantGender: string
      participantClass: string
      accommodationRequired: string
      essayFileUrl: string
      declaration: boolean
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["essayHindi"]>
    composites: {}
  }

  type EssayHindiGetPayload<S extends boolean | null | undefined | EssayHindiDefaultArgs> = $Result.GetResult<Prisma.$EssayHindiPayload, S>

  type EssayHindiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EssayHindiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EssayHindiCountAggregateInputType | true
    }

  export interface EssayHindiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EssayHindi'], meta: { name: 'EssayHindi' } }
    /**
     * Find zero or one EssayHindi that matches the filter.
     * @param {EssayHindiFindUniqueArgs} args - Arguments to find a EssayHindi
     * @example
     * // Get one EssayHindi
     * const essayHindi = await prisma.essayHindi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EssayHindiFindUniqueArgs>(args: SelectSubset<T, EssayHindiFindUniqueArgs<ExtArgs>>): Prisma__EssayHindiClient<$Result.GetResult<Prisma.$EssayHindiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EssayHindi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EssayHindiFindUniqueOrThrowArgs} args - Arguments to find a EssayHindi
     * @example
     * // Get one EssayHindi
     * const essayHindi = await prisma.essayHindi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EssayHindiFindUniqueOrThrowArgs>(args: SelectSubset<T, EssayHindiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EssayHindiClient<$Result.GetResult<Prisma.$EssayHindiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EssayHindi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayHindiFindFirstArgs} args - Arguments to find a EssayHindi
     * @example
     * // Get one EssayHindi
     * const essayHindi = await prisma.essayHindi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EssayHindiFindFirstArgs>(args?: SelectSubset<T, EssayHindiFindFirstArgs<ExtArgs>>): Prisma__EssayHindiClient<$Result.GetResult<Prisma.$EssayHindiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EssayHindi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayHindiFindFirstOrThrowArgs} args - Arguments to find a EssayHindi
     * @example
     * // Get one EssayHindi
     * const essayHindi = await prisma.essayHindi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EssayHindiFindFirstOrThrowArgs>(args?: SelectSubset<T, EssayHindiFindFirstOrThrowArgs<ExtArgs>>): Prisma__EssayHindiClient<$Result.GetResult<Prisma.$EssayHindiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EssayHindis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayHindiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EssayHindis
     * const essayHindis = await prisma.essayHindi.findMany()
     * 
     * // Get first 10 EssayHindis
     * const essayHindis = await prisma.essayHindi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const essayHindiWithIdOnly = await prisma.essayHindi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EssayHindiFindManyArgs>(args?: SelectSubset<T, EssayHindiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EssayHindiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EssayHindi.
     * @param {EssayHindiCreateArgs} args - Arguments to create a EssayHindi.
     * @example
     * // Create one EssayHindi
     * const EssayHindi = await prisma.essayHindi.create({
     *   data: {
     *     // ... data to create a EssayHindi
     *   }
     * })
     * 
     */
    create<T extends EssayHindiCreateArgs>(args: SelectSubset<T, EssayHindiCreateArgs<ExtArgs>>): Prisma__EssayHindiClient<$Result.GetResult<Prisma.$EssayHindiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EssayHindis.
     * @param {EssayHindiCreateManyArgs} args - Arguments to create many EssayHindis.
     * @example
     * // Create many EssayHindis
     * const essayHindi = await prisma.essayHindi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EssayHindiCreateManyArgs>(args?: SelectSubset<T, EssayHindiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EssayHindis and returns the data saved in the database.
     * @param {EssayHindiCreateManyAndReturnArgs} args - Arguments to create many EssayHindis.
     * @example
     * // Create many EssayHindis
     * const essayHindi = await prisma.essayHindi.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EssayHindis and only return the `id`
     * const essayHindiWithIdOnly = await prisma.essayHindi.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EssayHindiCreateManyAndReturnArgs>(args?: SelectSubset<T, EssayHindiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EssayHindiPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EssayHindi.
     * @param {EssayHindiDeleteArgs} args - Arguments to delete one EssayHindi.
     * @example
     * // Delete one EssayHindi
     * const EssayHindi = await prisma.essayHindi.delete({
     *   where: {
     *     // ... filter to delete one EssayHindi
     *   }
     * })
     * 
     */
    delete<T extends EssayHindiDeleteArgs>(args: SelectSubset<T, EssayHindiDeleteArgs<ExtArgs>>): Prisma__EssayHindiClient<$Result.GetResult<Prisma.$EssayHindiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EssayHindi.
     * @param {EssayHindiUpdateArgs} args - Arguments to update one EssayHindi.
     * @example
     * // Update one EssayHindi
     * const essayHindi = await prisma.essayHindi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EssayHindiUpdateArgs>(args: SelectSubset<T, EssayHindiUpdateArgs<ExtArgs>>): Prisma__EssayHindiClient<$Result.GetResult<Prisma.$EssayHindiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EssayHindis.
     * @param {EssayHindiDeleteManyArgs} args - Arguments to filter EssayHindis to delete.
     * @example
     * // Delete a few EssayHindis
     * const { count } = await prisma.essayHindi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EssayHindiDeleteManyArgs>(args?: SelectSubset<T, EssayHindiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EssayHindis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayHindiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EssayHindis
     * const essayHindi = await prisma.essayHindi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EssayHindiUpdateManyArgs>(args: SelectSubset<T, EssayHindiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EssayHindi.
     * @param {EssayHindiUpsertArgs} args - Arguments to update or create a EssayHindi.
     * @example
     * // Update or create a EssayHindi
     * const essayHindi = await prisma.essayHindi.upsert({
     *   create: {
     *     // ... data to create a EssayHindi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EssayHindi we want to update
     *   }
     * })
     */
    upsert<T extends EssayHindiUpsertArgs>(args: SelectSubset<T, EssayHindiUpsertArgs<ExtArgs>>): Prisma__EssayHindiClient<$Result.GetResult<Prisma.$EssayHindiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EssayHindis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayHindiCountArgs} args - Arguments to filter EssayHindis to count.
     * @example
     * // Count the number of EssayHindis
     * const count = await prisma.essayHindi.count({
     *   where: {
     *     // ... the filter for the EssayHindis we want to count
     *   }
     * })
    **/
    count<T extends EssayHindiCountArgs>(
      args?: Subset<T, EssayHindiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EssayHindiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EssayHindi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayHindiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EssayHindiAggregateArgs>(args: Subset<T, EssayHindiAggregateArgs>): Prisma.PrismaPromise<GetEssayHindiAggregateType<T>>

    /**
     * Group by EssayHindi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayHindiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EssayHindiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EssayHindiGroupByArgs['orderBy'] }
        : { orderBy?: EssayHindiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EssayHindiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEssayHindiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EssayHindi model
   */
  readonly fields: EssayHindiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EssayHindi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EssayHindiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EssayHindi model
   */ 
  interface EssayHindiFieldRefs {
    readonly id: FieldRef<"EssayHindi", 'Int'>
    readonly participantName: FieldRef<"EssayHindi", 'String'>
    readonly participantGender: FieldRef<"EssayHindi", 'String'>
    readonly participantClass: FieldRef<"EssayHindi", 'String'>
    readonly accommodationRequired: FieldRef<"EssayHindi", 'String'>
    readonly essayFileUrl: FieldRef<"EssayHindi", 'String'>
    readonly declaration: FieldRef<"EssayHindi", 'Boolean'>
    readonly schoolId: FieldRef<"EssayHindi", 'Int'>
    readonly createdAt: FieldRef<"EssayHindi", 'DateTime'>
    readonly updatedAt: FieldRef<"EssayHindi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EssayHindi findUnique
   */
  export type EssayHindiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiInclude<ExtArgs> | null
    /**
     * Filter, which EssayHindi to fetch.
     */
    where: EssayHindiWhereUniqueInput
  }

  /**
   * EssayHindi findUniqueOrThrow
   */
  export type EssayHindiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiInclude<ExtArgs> | null
    /**
     * Filter, which EssayHindi to fetch.
     */
    where: EssayHindiWhereUniqueInput
  }

  /**
   * EssayHindi findFirst
   */
  export type EssayHindiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiInclude<ExtArgs> | null
    /**
     * Filter, which EssayHindi to fetch.
     */
    where?: EssayHindiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayHindis to fetch.
     */
    orderBy?: EssayHindiOrderByWithRelationInput | EssayHindiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EssayHindis.
     */
    cursor?: EssayHindiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayHindis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayHindis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EssayHindis.
     */
    distinct?: EssayHindiScalarFieldEnum | EssayHindiScalarFieldEnum[]
  }

  /**
   * EssayHindi findFirstOrThrow
   */
  export type EssayHindiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiInclude<ExtArgs> | null
    /**
     * Filter, which EssayHindi to fetch.
     */
    where?: EssayHindiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayHindis to fetch.
     */
    orderBy?: EssayHindiOrderByWithRelationInput | EssayHindiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EssayHindis.
     */
    cursor?: EssayHindiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayHindis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayHindis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EssayHindis.
     */
    distinct?: EssayHindiScalarFieldEnum | EssayHindiScalarFieldEnum[]
  }

  /**
   * EssayHindi findMany
   */
  export type EssayHindiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiInclude<ExtArgs> | null
    /**
     * Filter, which EssayHindis to fetch.
     */
    where?: EssayHindiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayHindis to fetch.
     */
    orderBy?: EssayHindiOrderByWithRelationInput | EssayHindiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EssayHindis.
     */
    cursor?: EssayHindiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayHindis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayHindis.
     */
    skip?: number
    distinct?: EssayHindiScalarFieldEnum | EssayHindiScalarFieldEnum[]
  }

  /**
   * EssayHindi create
   */
  export type EssayHindiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiInclude<ExtArgs> | null
    /**
     * The data needed to create a EssayHindi.
     */
    data: XOR<EssayHindiCreateInput, EssayHindiUncheckedCreateInput>
  }

  /**
   * EssayHindi createMany
   */
  export type EssayHindiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EssayHindis.
     */
    data: EssayHindiCreateManyInput | EssayHindiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EssayHindi createManyAndReturn
   */
  export type EssayHindiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EssayHindis.
     */
    data: EssayHindiCreateManyInput | EssayHindiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EssayHindi update
   */
  export type EssayHindiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiInclude<ExtArgs> | null
    /**
     * The data needed to update a EssayHindi.
     */
    data: XOR<EssayHindiUpdateInput, EssayHindiUncheckedUpdateInput>
    /**
     * Choose, which EssayHindi to update.
     */
    where: EssayHindiWhereUniqueInput
  }

  /**
   * EssayHindi updateMany
   */
  export type EssayHindiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EssayHindis.
     */
    data: XOR<EssayHindiUpdateManyMutationInput, EssayHindiUncheckedUpdateManyInput>
    /**
     * Filter which EssayHindis to update
     */
    where?: EssayHindiWhereInput
  }

  /**
   * EssayHindi upsert
   */
  export type EssayHindiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiInclude<ExtArgs> | null
    /**
     * The filter to search for the EssayHindi to update in case it exists.
     */
    where: EssayHindiWhereUniqueInput
    /**
     * In case the EssayHindi found by the `where` argument doesn't exist, create a new EssayHindi with this data.
     */
    create: XOR<EssayHindiCreateInput, EssayHindiUncheckedCreateInput>
    /**
     * In case the EssayHindi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EssayHindiUpdateInput, EssayHindiUncheckedUpdateInput>
  }

  /**
   * EssayHindi delete
   */
  export type EssayHindiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiInclude<ExtArgs> | null
    /**
     * Filter which EssayHindi to delete.
     */
    where: EssayHindiWhereUniqueInput
  }

  /**
   * EssayHindi deleteMany
   */
  export type EssayHindiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EssayHindis to delete
     */
    where?: EssayHindiWhereInput
  }

  /**
   * EssayHindi without action
   */
  export type EssayHindiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayHindi
     */
    select?: EssayHindiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayHindiInclude<ExtArgs> | null
  }


  /**
   * Model EssayGujarati
   */

  export type AggregateEssayGujarati = {
    _count: EssayGujaratiCountAggregateOutputType | null
    _avg: EssayGujaratiAvgAggregateOutputType | null
    _sum: EssayGujaratiSumAggregateOutputType | null
    _min: EssayGujaratiMinAggregateOutputType | null
    _max: EssayGujaratiMaxAggregateOutputType | null
  }

  export type EssayGujaratiAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EssayGujaratiSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type EssayGujaratiMinAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    essayFileUrl: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EssayGujaratiMaxAggregateOutputType = {
    id: number | null
    participantName: string | null
    participantGender: string | null
    participantClass: string | null
    accommodationRequired: string | null
    essayFileUrl: string | null
    declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EssayGujaratiCountAggregateOutputType = {
    id: number
    participantName: number
    participantGender: number
    participantClass: number
    accommodationRequired: number
    essayFileUrl: number
    declaration: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EssayGujaratiAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EssayGujaratiSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type EssayGujaratiMinAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    essayFileUrl?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EssayGujaratiMaxAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    essayFileUrl?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EssayGujaratiCountAggregateInputType = {
    id?: true
    participantName?: true
    participantGender?: true
    participantClass?: true
    accommodationRequired?: true
    essayFileUrl?: true
    declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EssayGujaratiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EssayGujarati to aggregate.
     */
    where?: EssayGujaratiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayGujaratis to fetch.
     */
    orderBy?: EssayGujaratiOrderByWithRelationInput | EssayGujaratiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EssayGujaratiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayGujaratis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayGujaratis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EssayGujaratis
    **/
    _count?: true | EssayGujaratiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EssayGujaratiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EssayGujaratiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EssayGujaratiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EssayGujaratiMaxAggregateInputType
  }

  export type GetEssayGujaratiAggregateType<T extends EssayGujaratiAggregateArgs> = {
        [P in keyof T & keyof AggregateEssayGujarati]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEssayGujarati[P]>
      : GetScalarType<T[P], AggregateEssayGujarati[P]>
  }




  export type EssayGujaratiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EssayGujaratiWhereInput
    orderBy?: EssayGujaratiOrderByWithAggregationInput | EssayGujaratiOrderByWithAggregationInput[]
    by: EssayGujaratiScalarFieldEnum[] | EssayGujaratiScalarFieldEnum
    having?: EssayGujaratiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EssayGujaratiCountAggregateInputType | true
    _avg?: EssayGujaratiAvgAggregateInputType
    _sum?: EssayGujaratiSumAggregateInputType
    _min?: EssayGujaratiMinAggregateInputType
    _max?: EssayGujaratiMaxAggregateInputType
  }

  export type EssayGujaratiGroupByOutputType = {
    id: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: EssayGujaratiCountAggregateOutputType | null
    _avg: EssayGujaratiAvgAggregateOutputType | null
    _sum: EssayGujaratiSumAggregateOutputType | null
    _min: EssayGujaratiMinAggregateOutputType | null
    _max: EssayGujaratiMaxAggregateOutputType | null
  }

  type GetEssayGujaratiGroupByPayload<T extends EssayGujaratiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EssayGujaratiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EssayGujaratiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EssayGujaratiGroupByOutputType[P]>
            : GetScalarType<T[P], EssayGujaratiGroupByOutputType[P]>
        }
      >
    >


  export type EssayGujaratiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    essayFileUrl?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["essayGujarati"]>

  export type EssayGujaratiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    essayFileUrl?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["essayGujarati"]>

  export type EssayGujaratiSelectScalar = {
    id?: boolean
    participantName?: boolean
    participantGender?: boolean
    participantClass?: boolean
    accommodationRequired?: boolean
    essayFileUrl?: boolean
    declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EssayGujaratiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type EssayGujaratiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $EssayGujaratiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EssayGujarati"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      participantName: string
      participantGender: string
      participantClass: string
      accommodationRequired: string
      essayFileUrl: string
      declaration: boolean
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["essayGujarati"]>
    composites: {}
  }

  type EssayGujaratiGetPayload<S extends boolean | null | undefined | EssayGujaratiDefaultArgs> = $Result.GetResult<Prisma.$EssayGujaratiPayload, S>

  type EssayGujaratiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EssayGujaratiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EssayGujaratiCountAggregateInputType | true
    }

  export interface EssayGujaratiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EssayGujarati'], meta: { name: 'EssayGujarati' } }
    /**
     * Find zero or one EssayGujarati that matches the filter.
     * @param {EssayGujaratiFindUniqueArgs} args - Arguments to find a EssayGujarati
     * @example
     * // Get one EssayGujarati
     * const essayGujarati = await prisma.essayGujarati.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EssayGujaratiFindUniqueArgs>(args: SelectSubset<T, EssayGujaratiFindUniqueArgs<ExtArgs>>): Prisma__EssayGujaratiClient<$Result.GetResult<Prisma.$EssayGujaratiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EssayGujarati that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EssayGujaratiFindUniqueOrThrowArgs} args - Arguments to find a EssayGujarati
     * @example
     * // Get one EssayGujarati
     * const essayGujarati = await prisma.essayGujarati.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EssayGujaratiFindUniqueOrThrowArgs>(args: SelectSubset<T, EssayGujaratiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EssayGujaratiClient<$Result.GetResult<Prisma.$EssayGujaratiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EssayGujarati that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayGujaratiFindFirstArgs} args - Arguments to find a EssayGujarati
     * @example
     * // Get one EssayGujarati
     * const essayGujarati = await prisma.essayGujarati.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EssayGujaratiFindFirstArgs>(args?: SelectSubset<T, EssayGujaratiFindFirstArgs<ExtArgs>>): Prisma__EssayGujaratiClient<$Result.GetResult<Prisma.$EssayGujaratiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EssayGujarati that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayGujaratiFindFirstOrThrowArgs} args - Arguments to find a EssayGujarati
     * @example
     * // Get one EssayGujarati
     * const essayGujarati = await prisma.essayGujarati.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EssayGujaratiFindFirstOrThrowArgs>(args?: SelectSubset<T, EssayGujaratiFindFirstOrThrowArgs<ExtArgs>>): Prisma__EssayGujaratiClient<$Result.GetResult<Prisma.$EssayGujaratiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EssayGujaratis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayGujaratiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EssayGujaratis
     * const essayGujaratis = await prisma.essayGujarati.findMany()
     * 
     * // Get first 10 EssayGujaratis
     * const essayGujaratis = await prisma.essayGujarati.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const essayGujaratiWithIdOnly = await prisma.essayGujarati.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EssayGujaratiFindManyArgs>(args?: SelectSubset<T, EssayGujaratiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EssayGujaratiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EssayGujarati.
     * @param {EssayGujaratiCreateArgs} args - Arguments to create a EssayGujarati.
     * @example
     * // Create one EssayGujarati
     * const EssayGujarati = await prisma.essayGujarati.create({
     *   data: {
     *     // ... data to create a EssayGujarati
     *   }
     * })
     * 
     */
    create<T extends EssayGujaratiCreateArgs>(args: SelectSubset<T, EssayGujaratiCreateArgs<ExtArgs>>): Prisma__EssayGujaratiClient<$Result.GetResult<Prisma.$EssayGujaratiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EssayGujaratis.
     * @param {EssayGujaratiCreateManyArgs} args - Arguments to create many EssayGujaratis.
     * @example
     * // Create many EssayGujaratis
     * const essayGujarati = await prisma.essayGujarati.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EssayGujaratiCreateManyArgs>(args?: SelectSubset<T, EssayGujaratiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EssayGujaratis and returns the data saved in the database.
     * @param {EssayGujaratiCreateManyAndReturnArgs} args - Arguments to create many EssayGujaratis.
     * @example
     * // Create many EssayGujaratis
     * const essayGujarati = await prisma.essayGujarati.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EssayGujaratis and only return the `id`
     * const essayGujaratiWithIdOnly = await prisma.essayGujarati.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EssayGujaratiCreateManyAndReturnArgs>(args?: SelectSubset<T, EssayGujaratiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EssayGujaratiPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EssayGujarati.
     * @param {EssayGujaratiDeleteArgs} args - Arguments to delete one EssayGujarati.
     * @example
     * // Delete one EssayGujarati
     * const EssayGujarati = await prisma.essayGujarati.delete({
     *   where: {
     *     // ... filter to delete one EssayGujarati
     *   }
     * })
     * 
     */
    delete<T extends EssayGujaratiDeleteArgs>(args: SelectSubset<T, EssayGujaratiDeleteArgs<ExtArgs>>): Prisma__EssayGujaratiClient<$Result.GetResult<Prisma.$EssayGujaratiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EssayGujarati.
     * @param {EssayGujaratiUpdateArgs} args - Arguments to update one EssayGujarati.
     * @example
     * // Update one EssayGujarati
     * const essayGujarati = await prisma.essayGujarati.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EssayGujaratiUpdateArgs>(args: SelectSubset<T, EssayGujaratiUpdateArgs<ExtArgs>>): Prisma__EssayGujaratiClient<$Result.GetResult<Prisma.$EssayGujaratiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EssayGujaratis.
     * @param {EssayGujaratiDeleteManyArgs} args - Arguments to filter EssayGujaratis to delete.
     * @example
     * // Delete a few EssayGujaratis
     * const { count } = await prisma.essayGujarati.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EssayGujaratiDeleteManyArgs>(args?: SelectSubset<T, EssayGujaratiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EssayGujaratis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayGujaratiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EssayGujaratis
     * const essayGujarati = await prisma.essayGujarati.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EssayGujaratiUpdateManyArgs>(args: SelectSubset<T, EssayGujaratiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EssayGujarati.
     * @param {EssayGujaratiUpsertArgs} args - Arguments to update or create a EssayGujarati.
     * @example
     * // Update or create a EssayGujarati
     * const essayGujarati = await prisma.essayGujarati.upsert({
     *   create: {
     *     // ... data to create a EssayGujarati
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EssayGujarati we want to update
     *   }
     * })
     */
    upsert<T extends EssayGujaratiUpsertArgs>(args: SelectSubset<T, EssayGujaratiUpsertArgs<ExtArgs>>): Prisma__EssayGujaratiClient<$Result.GetResult<Prisma.$EssayGujaratiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EssayGujaratis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayGujaratiCountArgs} args - Arguments to filter EssayGujaratis to count.
     * @example
     * // Count the number of EssayGujaratis
     * const count = await prisma.essayGujarati.count({
     *   where: {
     *     // ... the filter for the EssayGujaratis we want to count
     *   }
     * })
    **/
    count<T extends EssayGujaratiCountArgs>(
      args?: Subset<T, EssayGujaratiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EssayGujaratiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EssayGujarati.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayGujaratiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EssayGujaratiAggregateArgs>(args: Subset<T, EssayGujaratiAggregateArgs>): Prisma.PrismaPromise<GetEssayGujaratiAggregateType<T>>

    /**
     * Group by EssayGujarati.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EssayGujaratiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EssayGujaratiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EssayGujaratiGroupByArgs['orderBy'] }
        : { orderBy?: EssayGujaratiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EssayGujaratiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEssayGujaratiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EssayGujarati model
   */
  readonly fields: EssayGujaratiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EssayGujarati.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EssayGujaratiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EssayGujarati model
   */ 
  interface EssayGujaratiFieldRefs {
    readonly id: FieldRef<"EssayGujarati", 'Int'>
    readonly participantName: FieldRef<"EssayGujarati", 'String'>
    readonly participantGender: FieldRef<"EssayGujarati", 'String'>
    readonly participantClass: FieldRef<"EssayGujarati", 'String'>
    readonly accommodationRequired: FieldRef<"EssayGujarati", 'String'>
    readonly essayFileUrl: FieldRef<"EssayGujarati", 'String'>
    readonly declaration: FieldRef<"EssayGujarati", 'Boolean'>
    readonly schoolId: FieldRef<"EssayGujarati", 'Int'>
    readonly createdAt: FieldRef<"EssayGujarati", 'DateTime'>
    readonly updatedAt: FieldRef<"EssayGujarati", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EssayGujarati findUnique
   */
  export type EssayGujaratiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiInclude<ExtArgs> | null
    /**
     * Filter, which EssayGujarati to fetch.
     */
    where: EssayGujaratiWhereUniqueInput
  }

  /**
   * EssayGujarati findUniqueOrThrow
   */
  export type EssayGujaratiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiInclude<ExtArgs> | null
    /**
     * Filter, which EssayGujarati to fetch.
     */
    where: EssayGujaratiWhereUniqueInput
  }

  /**
   * EssayGujarati findFirst
   */
  export type EssayGujaratiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiInclude<ExtArgs> | null
    /**
     * Filter, which EssayGujarati to fetch.
     */
    where?: EssayGujaratiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayGujaratis to fetch.
     */
    orderBy?: EssayGujaratiOrderByWithRelationInput | EssayGujaratiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EssayGujaratis.
     */
    cursor?: EssayGujaratiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayGujaratis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayGujaratis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EssayGujaratis.
     */
    distinct?: EssayGujaratiScalarFieldEnum | EssayGujaratiScalarFieldEnum[]
  }

  /**
   * EssayGujarati findFirstOrThrow
   */
  export type EssayGujaratiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiInclude<ExtArgs> | null
    /**
     * Filter, which EssayGujarati to fetch.
     */
    where?: EssayGujaratiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayGujaratis to fetch.
     */
    orderBy?: EssayGujaratiOrderByWithRelationInput | EssayGujaratiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EssayGujaratis.
     */
    cursor?: EssayGujaratiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayGujaratis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayGujaratis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EssayGujaratis.
     */
    distinct?: EssayGujaratiScalarFieldEnum | EssayGujaratiScalarFieldEnum[]
  }

  /**
   * EssayGujarati findMany
   */
  export type EssayGujaratiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiInclude<ExtArgs> | null
    /**
     * Filter, which EssayGujaratis to fetch.
     */
    where?: EssayGujaratiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EssayGujaratis to fetch.
     */
    orderBy?: EssayGujaratiOrderByWithRelationInput | EssayGujaratiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EssayGujaratis.
     */
    cursor?: EssayGujaratiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EssayGujaratis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EssayGujaratis.
     */
    skip?: number
    distinct?: EssayGujaratiScalarFieldEnum | EssayGujaratiScalarFieldEnum[]
  }

  /**
   * EssayGujarati create
   */
  export type EssayGujaratiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiInclude<ExtArgs> | null
    /**
     * The data needed to create a EssayGujarati.
     */
    data: XOR<EssayGujaratiCreateInput, EssayGujaratiUncheckedCreateInput>
  }

  /**
   * EssayGujarati createMany
   */
  export type EssayGujaratiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EssayGujaratis.
     */
    data: EssayGujaratiCreateManyInput | EssayGujaratiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EssayGujarati createManyAndReturn
   */
  export type EssayGujaratiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EssayGujaratis.
     */
    data: EssayGujaratiCreateManyInput | EssayGujaratiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EssayGujarati update
   */
  export type EssayGujaratiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiInclude<ExtArgs> | null
    /**
     * The data needed to update a EssayGujarati.
     */
    data: XOR<EssayGujaratiUpdateInput, EssayGujaratiUncheckedUpdateInput>
    /**
     * Choose, which EssayGujarati to update.
     */
    where: EssayGujaratiWhereUniqueInput
  }

  /**
   * EssayGujarati updateMany
   */
  export type EssayGujaratiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EssayGujaratis.
     */
    data: XOR<EssayGujaratiUpdateManyMutationInput, EssayGujaratiUncheckedUpdateManyInput>
    /**
     * Filter which EssayGujaratis to update
     */
    where?: EssayGujaratiWhereInput
  }

  /**
   * EssayGujarati upsert
   */
  export type EssayGujaratiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiInclude<ExtArgs> | null
    /**
     * The filter to search for the EssayGujarati to update in case it exists.
     */
    where: EssayGujaratiWhereUniqueInput
    /**
     * In case the EssayGujarati found by the `where` argument doesn't exist, create a new EssayGujarati with this data.
     */
    create: XOR<EssayGujaratiCreateInput, EssayGujaratiUncheckedCreateInput>
    /**
     * In case the EssayGujarati was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EssayGujaratiUpdateInput, EssayGujaratiUncheckedUpdateInput>
  }

  /**
   * EssayGujarati delete
   */
  export type EssayGujaratiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiInclude<ExtArgs> | null
    /**
     * Filter which EssayGujarati to delete.
     */
    where: EssayGujaratiWhereUniqueInput
  }

  /**
   * EssayGujarati deleteMany
   */
  export type EssayGujaratiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EssayGujaratis to delete
     */
    where?: EssayGujaratiWhereInput
  }

  /**
   * EssayGujarati without action
   */
  export type EssayGujaratiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EssayGujarati
     */
    select?: EssayGujaratiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EssayGujaratiInclude<ExtArgs> | null
  }


  /**
   * Model Poster
   */

  export type AggregatePoster = {
    _count: PosterCountAggregateOutputType | null
    _avg: PosterAvgAggregateOutputType | null
    _sum: PosterSumAggregateOutputType | null
    _min: PosterMinAggregateOutputType | null
    _max: PosterMaxAggregateOutputType | null
  }

  export type PosterAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type PosterSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type PosterMinAggregateOutputType = {
    id: number | null
    participant1Name: string | null
    participant1Gender: string | null
    participant1Class: string | null
    participant1Accommodation: string | null
    participant1Declaration: boolean | null
    participant2Name: string | null
    participant2Gender: string | null
    participant2Class: string | null
    participant2Accommodation: string | null
    participant2Declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PosterMaxAggregateOutputType = {
    id: number | null
    participant1Name: string | null
    participant1Gender: string | null
    participant1Class: string | null
    participant1Accommodation: string | null
    participant1Declaration: boolean | null
    participant2Name: string | null
    participant2Gender: string | null
    participant2Class: string | null
    participant2Accommodation: string | null
    participant2Declaration: boolean | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PosterCountAggregateOutputType = {
    id: number
    participant1Name: number
    participant1Gender: number
    participant1Class: number
    participant1Accommodation: number
    participant1Declaration: number
    participant2Name: number
    participant2Gender: number
    participant2Class: number
    participant2Accommodation: number
    participant2Declaration: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PosterAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type PosterSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type PosterMinAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant1Declaration?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    participant2Declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PosterMaxAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant1Declaration?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    participant2Declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PosterCountAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant1Declaration?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    participant2Declaration?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PosterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Poster to aggregate.
     */
    where?: PosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posters to fetch.
     */
    orderBy?: PosterOrderByWithRelationInput | PosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posters
    **/
    _count?: true | PosterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PosterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PosterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosterMaxAggregateInputType
  }

  export type GetPosterAggregateType<T extends PosterAggregateArgs> = {
        [P in keyof T & keyof AggregatePoster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoster[P]>
      : GetScalarType<T[P], AggregatePoster[P]>
  }




  export type PosterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosterWhereInput
    orderBy?: PosterOrderByWithAggregationInput | PosterOrderByWithAggregationInput[]
    by: PosterScalarFieldEnum[] | PosterScalarFieldEnum
    having?: PosterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosterCountAggregateInputType | true
    _avg?: PosterAvgAggregateInputType
    _sum?: PosterSumAggregateInputType
    _min?: PosterMinAggregateInputType
    _max?: PosterMaxAggregateInputType
  }

  export type PosterGroupByOutputType = {
    id: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant1Declaration: boolean
    participant2Name: string | null
    participant2Gender: string | null
    participant2Class: string | null
    participant2Accommodation: string | null
    participant2Declaration: boolean | null
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: PosterCountAggregateOutputType | null
    _avg: PosterAvgAggregateOutputType | null
    _sum: PosterSumAggregateOutputType | null
    _min: PosterMinAggregateOutputType | null
    _max: PosterMaxAggregateOutputType | null
  }

  type GetPosterGroupByPayload<T extends PosterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosterGroupByOutputType[P]>
            : GetScalarType<T[P], PosterGroupByOutputType[P]>
        }
      >
    >


  export type PosterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant1Declaration?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    participant2Declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poster"]>

  export type PosterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant1Declaration?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    participant2Declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poster"]>

  export type PosterSelectScalar = {
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant1Declaration?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    participant2Declaration?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PosterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type PosterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $PosterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Poster"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      participant1Name: string
      participant1Gender: string
      participant1Class: string
      participant1Accommodation: string
      participant1Declaration: boolean
      participant2Name: string | null
      participant2Gender: string | null
      participant2Class: string | null
      participant2Accommodation: string | null
      participant2Declaration: boolean | null
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["poster"]>
    composites: {}
  }

  type PosterGetPayload<S extends boolean | null | undefined | PosterDefaultArgs> = $Result.GetResult<Prisma.$PosterPayload, S>

  type PosterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PosterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PosterCountAggregateInputType | true
    }

  export interface PosterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Poster'], meta: { name: 'Poster' } }
    /**
     * Find zero or one Poster that matches the filter.
     * @param {PosterFindUniqueArgs} args - Arguments to find a Poster
     * @example
     * // Get one Poster
     * const poster = await prisma.poster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosterFindUniqueArgs>(args: SelectSubset<T, PosterFindUniqueArgs<ExtArgs>>): Prisma__PosterClient<$Result.GetResult<Prisma.$PosterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Poster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PosterFindUniqueOrThrowArgs} args - Arguments to find a Poster
     * @example
     * // Get one Poster
     * const poster = await prisma.poster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosterFindUniqueOrThrowArgs>(args: SelectSubset<T, PosterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosterClient<$Result.GetResult<Prisma.$PosterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Poster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosterFindFirstArgs} args - Arguments to find a Poster
     * @example
     * // Get one Poster
     * const poster = await prisma.poster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosterFindFirstArgs>(args?: SelectSubset<T, PosterFindFirstArgs<ExtArgs>>): Prisma__PosterClient<$Result.GetResult<Prisma.$PosterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Poster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosterFindFirstOrThrowArgs} args - Arguments to find a Poster
     * @example
     * // Get one Poster
     * const poster = await prisma.poster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosterFindFirstOrThrowArgs>(args?: SelectSubset<T, PosterFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosterClient<$Result.GetResult<Prisma.$PosterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posters
     * const posters = await prisma.poster.findMany()
     * 
     * // Get first 10 Posters
     * const posters = await prisma.poster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posterWithIdOnly = await prisma.poster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosterFindManyArgs>(args?: SelectSubset<T, PosterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Poster.
     * @param {PosterCreateArgs} args - Arguments to create a Poster.
     * @example
     * // Create one Poster
     * const Poster = await prisma.poster.create({
     *   data: {
     *     // ... data to create a Poster
     *   }
     * })
     * 
     */
    create<T extends PosterCreateArgs>(args: SelectSubset<T, PosterCreateArgs<ExtArgs>>): Prisma__PosterClient<$Result.GetResult<Prisma.$PosterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posters.
     * @param {PosterCreateManyArgs} args - Arguments to create many Posters.
     * @example
     * // Create many Posters
     * const poster = await prisma.poster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosterCreateManyArgs>(args?: SelectSubset<T, PosterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posters and returns the data saved in the database.
     * @param {PosterCreateManyAndReturnArgs} args - Arguments to create many Posters.
     * @example
     * // Create many Posters
     * const poster = await prisma.poster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posters and only return the `id`
     * const posterWithIdOnly = await prisma.poster.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosterCreateManyAndReturnArgs>(args?: SelectSubset<T, PosterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Poster.
     * @param {PosterDeleteArgs} args - Arguments to delete one Poster.
     * @example
     * // Delete one Poster
     * const Poster = await prisma.poster.delete({
     *   where: {
     *     // ... filter to delete one Poster
     *   }
     * })
     * 
     */
    delete<T extends PosterDeleteArgs>(args: SelectSubset<T, PosterDeleteArgs<ExtArgs>>): Prisma__PosterClient<$Result.GetResult<Prisma.$PosterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Poster.
     * @param {PosterUpdateArgs} args - Arguments to update one Poster.
     * @example
     * // Update one Poster
     * const poster = await prisma.poster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosterUpdateArgs>(args: SelectSubset<T, PosterUpdateArgs<ExtArgs>>): Prisma__PosterClient<$Result.GetResult<Prisma.$PosterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posters.
     * @param {PosterDeleteManyArgs} args - Arguments to filter Posters to delete.
     * @example
     * // Delete a few Posters
     * const { count } = await prisma.poster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosterDeleteManyArgs>(args?: SelectSubset<T, PosterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posters
     * const poster = await prisma.poster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosterUpdateManyArgs>(args: SelectSubset<T, PosterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Poster.
     * @param {PosterUpsertArgs} args - Arguments to update or create a Poster.
     * @example
     * // Update or create a Poster
     * const poster = await prisma.poster.upsert({
     *   create: {
     *     // ... data to create a Poster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Poster we want to update
     *   }
     * })
     */
    upsert<T extends PosterUpsertArgs>(args: SelectSubset<T, PosterUpsertArgs<ExtArgs>>): Prisma__PosterClient<$Result.GetResult<Prisma.$PosterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Posters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosterCountArgs} args - Arguments to filter Posters to count.
     * @example
     * // Count the number of Posters
     * const count = await prisma.poster.count({
     *   where: {
     *     // ... the filter for the Posters we want to count
     *   }
     * })
    **/
    count<T extends PosterCountArgs>(
      args?: Subset<T, PosterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Poster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosterAggregateArgs>(args: Subset<T, PosterAggregateArgs>): Prisma.PrismaPromise<GetPosterAggregateType<T>>

    /**
     * Group by Poster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosterGroupByArgs['orderBy'] }
        : { orderBy?: PosterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Poster model
   */
  readonly fields: PosterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Poster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Poster model
   */ 
  interface PosterFieldRefs {
    readonly id: FieldRef<"Poster", 'Int'>
    readonly participant1Name: FieldRef<"Poster", 'String'>
    readonly participant1Gender: FieldRef<"Poster", 'String'>
    readonly participant1Class: FieldRef<"Poster", 'String'>
    readonly participant1Accommodation: FieldRef<"Poster", 'String'>
    readonly participant1Declaration: FieldRef<"Poster", 'Boolean'>
    readonly participant2Name: FieldRef<"Poster", 'String'>
    readonly participant2Gender: FieldRef<"Poster", 'String'>
    readonly participant2Class: FieldRef<"Poster", 'String'>
    readonly participant2Accommodation: FieldRef<"Poster", 'String'>
    readonly participant2Declaration: FieldRef<"Poster", 'Boolean'>
    readonly schoolId: FieldRef<"Poster", 'Int'>
    readonly createdAt: FieldRef<"Poster", 'DateTime'>
    readonly updatedAt: FieldRef<"Poster", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Poster findUnique
   */
  export type PosterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterInclude<ExtArgs> | null
    /**
     * Filter, which Poster to fetch.
     */
    where: PosterWhereUniqueInput
  }

  /**
   * Poster findUniqueOrThrow
   */
  export type PosterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterInclude<ExtArgs> | null
    /**
     * Filter, which Poster to fetch.
     */
    where: PosterWhereUniqueInput
  }

  /**
   * Poster findFirst
   */
  export type PosterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterInclude<ExtArgs> | null
    /**
     * Filter, which Poster to fetch.
     */
    where?: PosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posters to fetch.
     */
    orderBy?: PosterOrderByWithRelationInput | PosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posters.
     */
    cursor?: PosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posters.
     */
    distinct?: PosterScalarFieldEnum | PosterScalarFieldEnum[]
  }

  /**
   * Poster findFirstOrThrow
   */
  export type PosterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterInclude<ExtArgs> | null
    /**
     * Filter, which Poster to fetch.
     */
    where?: PosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posters to fetch.
     */
    orderBy?: PosterOrderByWithRelationInput | PosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posters.
     */
    cursor?: PosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posters.
     */
    distinct?: PosterScalarFieldEnum | PosterScalarFieldEnum[]
  }

  /**
   * Poster findMany
   */
  export type PosterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterInclude<ExtArgs> | null
    /**
     * Filter, which Posters to fetch.
     */
    where?: PosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posters to fetch.
     */
    orderBy?: PosterOrderByWithRelationInput | PosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posters.
     */
    cursor?: PosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posters.
     */
    skip?: number
    distinct?: PosterScalarFieldEnum | PosterScalarFieldEnum[]
  }

  /**
   * Poster create
   */
  export type PosterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterInclude<ExtArgs> | null
    /**
     * The data needed to create a Poster.
     */
    data: XOR<PosterCreateInput, PosterUncheckedCreateInput>
  }

  /**
   * Poster createMany
   */
  export type PosterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posters.
     */
    data: PosterCreateManyInput | PosterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Poster createManyAndReturn
   */
  export type PosterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Posters.
     */
    data: PosterCreateManyInput | PosterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Poster update
   */
  export type PosterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterInclude<ExtArgs> | null
    /**
     * The data needed to update a Poster.
     */
    data: XOR<PosterUpdateInput, PosterUncheckedUpdateInput>
    /**
     * Choose, which Poster to update.
     */
    where: PosterWhereUniqueInput
  }

  /**
   * Poster updateMany
   */
  export type PosterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posters.
     */
    data: XOR<PosterUpdateManyMutationInput, PosterUncheckedUpdateManyInput>
    /**
     * Filter which Posters to update
     */
    where?: PosterWhereInput
  }

  /**
   * Poster upsert
   */
  export type PosterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterInclude<ExtArgs> | null
    /**
     * The filter to search for the Poster to update in case it exists.
     */
    where: PosterWhereUniqueInput
    /**
     * In case the Poster found by the `where` argument doesn't exist, create a new Poster with this data.
     */
    create: XOR<PosterCreateInput, PosterUncheckedCreateInput>
    /**
     * In case the Poster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosterUpdateInput, PosterUncheckedUpdateInput>
  }

  /**
   * Poster delete
   */
  export type PosterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterInclude<ExtArgs> | null
    /**
     * Filter which Poster to delete.
     */
    where: PosterWhereUniqueInput
  }

  /**
   * Poster deleteMany
   */
  export type PosterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posters to delete
     */
    where?: PosterWhereInput
  }

  /**
   * Poster without action
   */
  export type PosterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poster
     */
    select?: PosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosterInclude<ExtArgs> | null
  }


  /**
   * Model Skit
   */

  export type AggregateSkit = {
    _count: SkitCountAggregateOutputType | null
    _avg: SkitAvgAggregateOutputType | null
    _sum: SkitSumAggregateOutputType | null
    _min: SkitMinAggregateOutputType | null
    _max: SkitMaxAggregateOutputType | null
  }

  export type SkitAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type SkitSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type SkitMinAggregateOutputType = {
    id: number | null
    participant1Name: string | null
    participant1Gender: string | null
    participant1Class: string | null
    participant1Accommodation: string | null
    participant2Name: string | null
    participant2Gender: string | null
    participant2Class: string | null
    participant2Accommodation: string | null
    participant3Name: string | null
    participant3Gender: string | null
    participant3Class: string | null
    participant3Accommodation: string | null
    participant4Name: string | null
    participant4Gender: string | null
    participant4Class: string | null
    participant4Accommodation: string | null
    participant5Name: string | null
    participant5Gender: string | null
    participant5Class: string | null
    participant5Accommodation: string | null
    participant6Name: string | null
    participant6Gender: string | null
    participant6Class: string | null
    participant6Accommodation: string | null
    additionalRequirements: string | null
    declaration: boolean | null
    videoLink: string | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkitMaxAggregateOutputType = {
    id: number | null
    participant1Name: string | null
    participant1Gender: string | null
    participant1Class: string | null
    participant1Accommodation: string | null
    participant2Name: string | null
    participant2Gender: string | null
    participant2Class: string | null
    participant2Accommodation: string | null
    participant3Name: string | null
    participant3Gender: string | null
    participant3Class: string | null
    participant3Accommodation: string | null
    participant4Name: string | null
    participant4Gender: string | null
    participant4Class: string | null
    participant4Accommodation: string | null
    participant5Name: string | null
    participant5Gender: string | null
    participant5Class: string | null
    participant5Accommodation: string | null
    participant6Name: string | null
    participant6Gender: string | null
    participant6Class: string | null
    participant6Accommodation: string | null
    additionalRequirements: string | null
    declaration: boolean | null
    videoLink: string | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkitCountAggregateOutputType = {
    id: number
    participant1Name: number
    participant1Gender: number
    participant1Class: number
    participant1Accommodation: number
    participant2Name: number
    participant2Gender: number
    participant2Class: number
    participant2Accommodation: number
    participant3Name: number
    participant3Gender: number
    participant3Class: number
    participant3Accommodation: number
    participant4Name: number
    participant4Gender: number
    participant4Class: number
    participant4Accommodation: number
    participant5Name: number
    participant5Gender: number
    participant5Class: number
    participant5Accommodation: number
    participant6Name: number
    participant6Gender: number
    participant6Class: number
    participant6Accommodation: number
    additionalRequirements: number
    declaration: number
    videoLink: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkitAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type SkitSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type SkitMinAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    participant3Name?: true
    participant3Gender?: true
    participant3Class?: true
    participant3Accommodation?: true
    participant4Name?: true
    participant4Gender?: true
    participant4Class?: true
    participant4Accommodation?: true
    participant5Name?: true
    participant5Gender?: true
    participant5Class?: true
    participant5Accommodation?: true
    participant6Name?: true
    participant6Gender?: true
    participant6Class?: true
    participant6Accommodation?: true
    additionalRequirements?: true
    declaration?: true
    videoLink?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkitMaxAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    participant3Name?: true
    participant3Gender?: true
    participant3Class?: true
    participant3Accommodation?: true
    participant4Name?: true
    participant4Gender?: true
    participant4Class?: true
    participant4Accommodation?: true
    participant5Name?: true
    participant5Gender?: true
    participant5Class?: true
    participant5Accommodation?: true
    participant6Name?: true
    participant6Gender?: true
    participant6Class?: true
    participant6Accommodation?: true
    additionalRequirements?: true
    declaration?: true
    videoLink?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkitCountAggregateInputType = {
    id?: true
    participant1Name?: true
    participant1Gender?: true
    participant1Class?: true
    participant1Accommodation?: true
    participant2Name?: true
    participant2Gender?: true
    participant2Class?: true
    participant2Accommodation?: true
    participant3Name?: true
    participant3Gender?: true
    participant3Class?: true
    participant3Accommodation?: true
    participant4Name?: true
    participant4Gender?: true
    participant4Class?: true
    participant4Accommodation?: true
    participant5Name?: true
    participant5Gender?: true
    participant5Class?: true
    participant5Accommodation?: true
    participant6Name?: true
    participant6Gender?: true
    participant6Class?: true
    participant6Accommodation?: true
    additionalRequirements?: true
    declaration?: true
    videoLink?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skit to aggregate.
     */
    where?: SkitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skits to fetch.
     */
    orderBy?: SkitOrderByWithRelationInput | SkitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skits
    **/
    _count?: true | SkitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkitMaxAggregateInputType
  }

  export type GetSkitAggregateType<T extends SkitAggregateArgs> = {
        [P in keyof T & keyof AggregateSkit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkit[P]>
      : GetScalarType<T[P], AggregateSkit[P]>
  }




  export type SkitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkitWhereInput
    orderBy?: SkitOrderByWithAggregationInput | SkitOrderByWithAggregationInput[]
    by: SkitScalarFieldEnum[] | SkitScalarFieldEnum
    having?: SkitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkitCountAggregateInputType | true
    _avg?: SkitAvgAggregateInputType
    _sum?: SkitSumAggregateInputType
    _min?: SkitMinAggregateInputType
    _max?: SkitMaxAggregateInputType
  }

  export type SkitGroupByOutputType = {
    id: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string | null
    participant2Gender: string | null
    participant2Class: string | null
    participant2Accommodation: string | null
    participant3Name: string | null
    participant3Gender: string | null
    participant3Class: string | null
    participant3Accommodation: string | null
    participant4Name: string | null
    participant4Gender: string | null
    participant4Class: string | null
    participant4Accommodation: string | null
    participant5Name: string | null
    participant5Gender: string | null
    participant5Class: string | null
    participant5Accommodation: string | null
    participant6Name: string | null
    participant6Gender: string | null
    participant6Class: string | null
    participant6Accommodation: string | null
    additionalRequirements: string | null
    declaration: boolean
    videoLink: string
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: SkitCountAggregateOutputType | null
    _avg: SkitAvgAggregateOutputType | null
    _sum: SkitSumAggregateOutputType | null
    _min: SkitMinAggregateOutputType | null
    _max: SkitMaxAggregateOutputType | null
  }

  type GetSkitGroupByPayload<T extends SkitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkitGroupByOutputType[P]>
            : GetScalarType<T[P], SkitGroupByOutputType[P]>
        }
      >
    >


  export type SkitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    participant3Name?: boolean
    participant3Gender?: boolean
    participant3Class?: boolean
    participant3Accommodation?: boolean
    participant4Name?: boolean
    participant4Gender?: boolean
    participant4Class?: boolean
    participant4Accommodation?: boolean
    participant5Name?: boolean
    participant5Gender?: boolean
    participant5Class?: boolean
    participant5Accommodation?: boolean
    participant6Name?: boolean
    participant6Gender?: boolean
    participant6Class?: boolean
    participant6Accommodation?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    videoLink?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skit"]>

  export type SkitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    participant3Name?: boolean
    participant3Gender?: boolean
    participant3Class?: boolean
    participant3Accommodation?: boolean
    participant4Name?: boolean
    participant4Gender?: boolean
    participant4Class?: boolean
    participant4Accommodation?: boolean
    participant5Name?: boolean
    participant5Gender?: boolean
    participant5Class?: boolean
    participant5Accommodation?: boolean
    participant6Name?: boolean
    participant6Gender?: boolean
    participant6Class?: boolean
    participant6Accommodation?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    videoLink?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skit"]>

  export type SkitSelectScalar = {
    id?: boolean
    participant1Name?: boolean
    participant1Gender?: boolean
    participant1Class?: boolean
    participant1Accommodation?: boolean
    participant2Name?: boolean
    participant2Gender?: boolean
    participant2Class?: boolean
    participant2Accommodation?: boolean
    participant3Name?: boolean
    participant3Gender?: boolean
    participant3Class?: boolean
    participant3Accommodation?: boolean
    participant4Name?: boolean
    participant4Gender?: boolean
    participant4Class?: boolean
    participant4Accommodation?: boolean
    participant5Name?: boolean
    participant5Gender?: boolean
    participant5Class?: boolean
    participant5Accommodation?: boolean
    participant6Name?: boolean
    participant6Gender?: boolean
    participant6Class?: boolean
    participant6Accommodation?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    videoLink?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SkitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SkitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skit"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      participant1Name: string
      participant1Gender: string
      participant1Class: string
      participant1Accommodation: string
      participant2Name: string | null
      participant2Gender: string | null
      participant2Class: string | null
      participant2Accommodation: string | null
      participant3Name: string | null
      participant3Gender: string | null
      participant3Class: string | null
      participant3Accommodation: string | null
      participant4Name: string | null
      participant4Gender: string | null
      participant4Class: string | null
      participant4Accommodation: string | null
      participant5Name: string | null
      participant5Gender: string | null
      participant5Class: string | null
      participant5Accommodation: string | null
      participant6Name: string | null
      participant6Gender: string | null
      participant6Class: string | null
      participant6Accommodation: string | null
      additionalRequirements: string | null
      declaration: boolean
      videoLink: string
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skit"]>
    composites: {}
  }

  type SkitGetPayload<S extends boolean | null | undefined | SkitDefaultArgs> = $Result.GetResult<Prisma.$SkitPayload, S>

  type SkitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkitCountAggregateInputType | true
    }

  export interface SkitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skit'], meta: { name: 'Skit' } }
    /**
     * Find zero or one Skit that matches the filter.
     * @param {SkitFindUniqueArgs} args - Arguments to find a Skit
     * @example
     * // Get one Skit
     * const skit = await prisma.skit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkitFindUniqueArgs>(args: SelectSubset<T, SkitFindUniqueArgs<ExtArgs>>): Prisma__SkitClient<$Result.GetResult<Prisma.$SkitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Skit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkitFindUniqueOrThrowArgs} args - Arguments to find a Skit
     * @example
     * // Get one Skit
     * const skit = await prisma.skit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkitFindUniqueOrThrowArgs>(args: SelectSubset<T, SkitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkitClient<$Result.GetResult<Prisma.$SkitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Skit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkitFindFirstArgs} args - Arguments to find a Skit
     * @example
     * // Get one Skit
     * const skit = await prisma.skit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkitFindFirstArgs>(args?: SelectSubset<T, SkitFindFirstArgs<ExtArgs>>): Prisma__SkitClient<$Result.GetResult<Prisma.$SkitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Skit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkitFindFirstOrThrowArgs} args - Arguments to find a Skit
     * @example
     * // Get one Skit
     * const skit = await prisma.skit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkitFindFirstOrThrowArgs>(args?: SelectSubset<T, SkitFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkitClient<$Result.GetResult<Prisma.$SkitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Skits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skits
     * const skits = await prisma.skit.findMany()
     * 
     * // Get first 10 Skits
     * const skits = await prisma.skit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skitWithIdOnly = await prisma.skit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkitFindManyArgs>(args?: SelectSubset<T, SkitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Skit.
     * @param {SkitCreateArgs} args - Arguments to create a Skit.
     * @example
     * // Create one Skit
     * const Skit = await prisma.skit.create({
     *   data: {
     *     // ... data to create a Skit
     *   }
     * })
     * 
     */
    create<T extends SkitCreateArgs>(args: SelectSubset<T, SkitCreateArgs<ExtArgs>>): Prisma__SkitClient<$Result.GetResult<Prisma.$SkitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Skits.
     * @param {SkitCreateManyArgs} args - Arguments to create many Skits.
     * @example
     * // Create many Skits
     * const skit = await prisma.skit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkitCreateManyArgs>(args?: SelectSubset<T, SkitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skits and returns the data saved in the database.
     * @param {SkitCreateManyAndReturnArgs} args - Arguments to create many Skits.
     * @example
     * // Create many Skits
     * const skit = await prisma.skit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skits and only return the `id`
     * const skitWithIdOnly = await prisma.skit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkitCreateManyAndReturnArgs>(args?: SelectSubset<T, SkitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Skit.
     * @param {SkitDeleteArgs} args - Arguments to delete one Skit.
     * @example
     * // Delete one Skit
     * const Skit = await prisma.skit.delete({
     *   where: {
     *     // ... filter to delete one Skit
     *   }
     * })
     * 
     */
    delete<T extends SkitDeleteArgs>(args: SelectSubset<T, SkitDeleteArgs<ExtArgs>>): Prisma__SkitClient<$Result.GetResult<Prisma.$SkitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Skit.
     * @param {SkitUpdateArgs} args - Arguments to update one Skit.
     * @example
     * // Update one Skit
     * const skit = await prisma.skit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkitUpdateArgs>(args: SelectSubset<T, SkitUpdateArgs<ExtArgs>>): Prisma__SkitClient<$Result.GetResult<Prisma.$SkitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Skits.
     * @param {SkitDeleteManyArgs} args - Arguments to filter Skits to delete.
     * @example
     * // Delete a few Skits
     * const { count } = await prisma.skit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkitDeleteManyArgs>(args?: SelectSubset<T, SkitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skits
     * const skit = await prisma.skit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkitUpdateManyArgs>(args: SelectSubset<T, SkitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skit.
     * @param {SkitUpsertArgs} args - Arguments to update or create a Skit.
     * @example
     * // Update or create a Skit
     * const skit = await prisma.skit.upsert({
     *   create: {
     *     // ... data to create a Skit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skit we want to update
     *   }
     * })
     */
    upsert<T extends SkitUpsertArgs>(args: SelectSubset<T, SkitUpsertArgs<ExtArgs>>): Prisma__SkitClient<$Result.GetResult<Prisma.$SkitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Skits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkitCountArgs} args - Arguments to filter Skits to count.
     * @example
     * // Count the number of Skits
     * const count = await prisma.skit.count({
     *   where: {
     *     // ... the filter for the Skits we want to count
     *   }
     * })
    **/
    count<T extends SkitCountArgs>(
      args?: Subset<T, SkitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkitAggregateArgs>(args: Subset<T, SkitAggregateArgs>): Prisma.PrismaPromise<GetSkitAggregateType<T>>

    /**
     * Group by Skit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkitGroupByArgs['orderBy'] }
        : { orderBy?: SkitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skit model
   */
  readonly fields: SkitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skit model
   */ 
  interface SkitFieldRefs {
    readonly id: FieldRef<"Skit", 'Int'>
    readonly participant1Name: FieldRef<"Skit", 'String'>
    readonly participant1Gender: FieldRef<"Skit", 'String'>
    readonly participant1Class: FieldRef<"Skit", 'String'>
    readonly participant1Accommodation: FieldRef<"Skit", 'String'>
    readonly participant2Name: FieldRef<"Skit", 'String'>
    readonly participant2Gender: FieldRef<"Skit", 'String'>
    readonly participant2Class: FieldRef<"Skit", 'String'>
    readonly participant2Accommodation: FieldRef<"Skit", 'String'>
    readonly participant3Name: FieldRef<"Skit", 'String'>
    readonly participant3Gender: FieldRef<"Skit", 'String'>
    readonly participant3Class: FieldRef<"Skit", 'String'>
    readonly participant3Accommodation: FieldRef<"Skit", 'String'>
    readonly participant4Name: FieldRef<"Skit", 'String'>
    readonly participant4Gender: FieldRef<"Skit", 'String'>
    readonly participant4Class: FieldRef<"Skit", 'String'>
    readonly participant4Accommodation: FieldRef<"Skit", 'String'>
    readonly participant5Name: FieldRef<"Skit", 'String'>
    readonly participant5Gender: FieldRef<"Skit", 'String'>
    readonly participant5Class: FieldRef<"Skit", 'String'>
    readonly participant5Accommodation: FieldRef<"Skit", 'String'>
    readonly participant6Name: FieldRef<"Skit", 'String'>
    readonly participant6Gender: FieldRef<"Skit", 'String'>
    readonly participant6Class: FieldRef<"Skit", 'String'>
    readonly participant6Accommodation: FieldRef<"Skit", 'String'>
    readonly additionalRequirements: FieldRef<"Skit", 'String'>
    readonly declaration: FieldRef<"Skit", 'Boolean'>
    readonly videoLink: FieldRef<"Skit", 'String'>
    readonly schoolId: FieldRef<"Skit", 'Int'>
    readonly createdAt: FieldRef<"Skit", 'DateTime'>
    readonly updatedAt: FieldRef<"Skit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Skit findUnique
   */
  export type SkitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitInclude<ExtArgs> | null
    /**
     * Filter, which Skit to fetch.
     */
    where: SkitWhereUniqueInput
  }

  /**
   * Skit findUniqueOrThrow
   */
  export type SkitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitInclude<ExtArgs> | null
    /**
     * Filter, which Skit to fetch.
     */
    where: SkitWhereUniqueInput
  }

  /**
   * Skit findFirst
   */
  export type SkitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitInclude<ExtArgs> | null
    /**
     * Filter, which Skit to fetch.
     */
    where?: SkitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skits to fetch.
     */
    orderBy?: SkitOrderByWithRelationInput | SkitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skits.
     */
    cursor?: SkitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skits.
     */
    distinct?: SkitScalarFieldEnum | SkitScalarFieldEnum[]
  }

  /**
   * Skit findFirstOrThrow
   */
  export type SkitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitInclude<ExtArgs> | null
    /**
     * Filter, which Skit to fetch.
     */
    where?: SkitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skits to fetch.
     */
    orderBy?: SkitOrderByWithRelationInput | SkitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skits.
     */
    cursor?: SkitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skits.
     */
    distinct?: SkitScalarFieldEnum | SkitScalarFieldEnum[]
  }

  /**
   * Skit findMany
   */
  export type SkitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitInclude<ExtArgs> | null
    /**
     * Filter, which Skits to fetch.
     */
    where?: SkitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skits to fetch.
     */
    orderBy?: SkitOrderByWithRelationInput | SkitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skits.
     */
    cursor?: SkitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skits.
     */
    skip?: number
    distinct?: SkitScalarFieldEnum | SkitScalarFieldEnum[]
  }

  /**
   * Skit create
   */
  export type SkitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitInclude<ExtArgs> | null
    /**
     * The data needed to create a Skit.
     */
    data: XOR<SkitCreateInput, SkitUncheckedCreateInput>
  }

  /**
   * Skit createMany
   */
  export type SkitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skits.
     */
    data: SkitCreateManyInput | SkitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skit createManyAndReturn
   */
  export type SkitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Skits.
     */
    data: SkitCreateManyInput | SkitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skit update
   */
  export type SkitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitInclude<ExtArgs> | null
    /**
     * The data needed to update a Skit.
     */
    data: XOR<SkitUpdateInput, SkitUncheckedUpdateInput>
    /**
     * Choose, which Skit to update.
     */
    where: SkitWhereUniqueInput
  }

  /**
   * Skit updateMany
   */
  export type SkitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skits.
     */
    data: XOR<SkitUpdateManyMutationInput, SkitUncheckedUpdateManyInput>
    /**
     * Filter which Skits to update
     */
    where?: SkitWhereInput
  }

  /**
   * Skit upsert
   */
  export type SkitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitInclude<ExtArgs> | null
    /**
     * The filter to search for the Skit to update in case it exists.
     */
    where: SkitWhereUniqueInput
    /**
     * In case the Skit found by the `where` argument doesn't exist, create a new Skit with this data.
     */
    create: XOR<SkitCreateInput, SkitUncheckedCreateInput>
    /**
     * In case the Skit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkitUpdateInput, SkitUncheckedUpdateInput>
  }

  /**
   * Skit delete
   */
  export type SkitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitInclude<ExtArgs> | null
    /**
     * Filter which Skit to delete.
     */
    where: SkitWhereUniqueInput
  }

  /**
   * Skit deleteMany
   */
  export type SkitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skits to delete
     */
    where?: SkitWhereInput
  }

  /**
   * Skit without action
   */
  export type SkitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skit
     */
    select?: SkitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkitInclude<ExtArgs> | null
  }


  /**
   * Model TeacherModel
   */

  export type AggregateTeacherModel = {
    _count: TeacherModelCountAggregateOutputType | null
    _avg: TeacherModelAvgAggregateOutputType | null
    _sum: TeacherModelSumAggregateOutputType | null
    _min: TeacherModelMinAggregateOutputType | null
    _max: TeacherModelMaxAggregateOutputType | null
  }

  export type TeacherModelAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type TeacherModelSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type TeacherModelMinAggregateOutputType = {
    id: number | null
    teacherName: string | null
    teacherGender: string | null
    accommodationRequired: string | null
    additionalRequirements: string | null
    declaration: boolean | null
    writeup: string | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherModelMaxAggregateOutputType = {
    id: number | null
    teacherName: string | null
    teacherGender: string | null
    accommodationRequired: string | null
    additionalRequirements: string | null
    declaration: boolean | null
    writeup: string | null
    schoolId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherModelCountAggregateOutputType = {
    id: number
    teacherName: number
    teacherGender: number
    accommodationRequired: number
    additionalRequirements: number
    declaration: number
    writeup: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherModelAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type TeacherModelSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type TeacherModelMinAggregateInputType = {
    id?: true
    teacherName?: true
    teacherGender?: true
    accommodationRequired?: true
    additionalRequirements?: true
    declaration?: true
    writeup?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherModelMaxAggregateInputType = {
    id?: true
    teacherName?: true
    teacherGender?: true
    accommodationRequired?: true
    additionalRequirements?: true
    declaration?: true
    writeup?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherModelCountAggregateInputType = {
    id?: true
    teacherName?: true
    teacherGender?: true
    accommodationRequired?: true
    additionalRequirements?: true
    declaration?: true
    writeup?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherModel to aggregate.
     */
    where?: TeacherModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherModels to fetch.
     */
    orderBy?: TeacherModelOrderByWithRelationInput | TeacherModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherModels
    **/
    _count?: true | TeacherModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherModelMaxAggregateInputType
  }

  export type GetTeacherModelAggregateType<T extends TeacherModelAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherModel[P]>
      : GetScalarType<T[P], AggregateTeacherModel[P]>
  }




  export type TeacherModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherModelWhereInput
    orderBy?: TeacherModelOrderByWithAggregationInput | TeacherModelOrderByWithAggregationInput[]
    by: TeacherModelScalarFieldEnum[] | TeacherModelScalarFieldEnum
    having?: TeacherModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherModelCountAggregateInputType | true
    _avg?: TeacherModelAvgAggregateInputType
    _sum?: TeacherModelSumAggregateInputType
    _min?: TeacherModelMinAggregateInputType
    _max?: TeacherModelMaxAggregateInputType
  }

  export type TeacherModelGroupByOutputType = {
    id: number
    teacherName: string
    teacherGender: string
    accommodationRequired: string
    additionalRequirements: string | null
    declaration: boolean
    writeup: string
    schoolId: number
    createdAt: Date
    updatedAt: Date
    _count: TeacherModelCountAggregateOutputType | null
    _avg: TeacherModelAvgAggregateOutputType | null
    _sum: TeacherModelSumAggregateOutputType | null
    _min: TeacherModelMinAggregateOutputType | null
    _max: TeacherModelMaxAggregateOutputType | null
  }

  type GetTeacherModelGroupByPayload<T extends TeacherModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherModelGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherModelGroupByOutputType[P]>
        }
      >
    >


  export type TeacherModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherName?: boolean
    teacherGender?: boolean
    accommodationRequired?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    writeup?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherModel"]>

  export type TeacherModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherName?: boolean
    teacherGender?: boolean
    accommodationRequired?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    writeup?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherModel"]>

  export type TeacherModelSelectScalar = {
    id?: boolean
    teacherName?: boolean
    teacherGender?: boolean
    accommodationRequired?: boolean
    additionalRequirements?: boolean
    declaration?: boolean
    writeup?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeacherModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type TeacherModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $TeacherModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherModel"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacherName: string
      teacherGender: string
      accommodationRequired: string
      additionalRequirements: string | null
      declaration: boolean
      writeup: string
      schoolId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teacherModel"]>
    composites: {}
  }

  type TeacherModelGetPayload<S extends boolean | null | undefined | TeacherModelDefaultArgs> = $Result.GetResult<Prisma.$TeacherModelPayload, S>

  type TeacherModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherModelCountAggregateInputType | true
    }

  export interface TeacherModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherModel'], meta: { name: 'TeacherModel' } }
    /**
     * Find zero or one TeacherModel that matches the filter.
     * @param {TeacherModelFindUniqueArgs} args - Arguments to find a TeacherModel
     * @example
     * // Get one TeacherModel
     * const teacherModel = await prisma.teacherModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherModelFindUniqueArgs>(args: SelectSubset<T, TeacherModelFindUniqueArgs<ExtArgs>>): Prisma__TeacherModelClient<$Result.GetResult<Prisma.$TeacherModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeacherModel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeacherModelFindUniqueOrThrowArgs} args - Arguments to find a TeacherModel
     * @example
     * // Get one TeacherModel
     * const teacherModel = await prisma.teacherModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherModelFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherModelClient<$Result.GetResult<Prisma.$TeacherModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeacherModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherModelFindFirstArgs} args - Arguments to find a TeacherModel
     * @example
     * // Get one TeacherModel
     * const teacherModel = await prisma.teacherModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherModelFindFirstArgs>(args?: SelectSubset<T, TeacherModelFindFirstArgs<ExtArgs>>): Prisma__TeacherModelClient<$Result.GetResult<Prisma.$TeacherModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeacherModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherModelFindFirstOrThrowArgs} args - Arguments to find a TeacherModel
     * @example
     * // Get one TeacherModel
     * const teacherModel = await prisma.teacherModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherModelFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherModelClient<$Result.GetResult<Prisma.$TeacherModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeacherModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherModels
     * const teacherModels = await prisma.teacherModel.findMany()
     * 
     * // Get first 10 TeacherModels
     * const teacherModels = await prisma.teacherModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherModelWithIdOnly = await prisma.teacherModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherModelFindManyArgs>(args?: SelectSubset<T, TeacherModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeacherModel.
     * @param {TeacherModelCreateArgs} args - Arguments to create a TeacherModel.
     * @example
     * // Create one TeacherModel
     * const TeacherModel = await prisma.teacherModel.create({
     *   data: {
     *     // ... data to create a TeacherModel
     *   }
     * })
     * 
     */
    create<T extends TeacherModelCreateArgs>(args: SelectSubset<T, TeacherModelCreateArgs<ExtArgs>>): Prisma__TeacherModelClient<$Result.GetResult<Prisma.$TeacherModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeacherModels.
     * @param {TeacherModelCreateManyArgs} args - Arguments to create many TeacherModels.
     * @example
     * // Create many TeacherModels
     * const teacherModel = await prisma.teacherModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherModelCreateManyArgs>(args?: SelectSubset<T, TeacherModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherModels and returns the data saved in the database.
     * @param {TeacherModelCreateManyAndReturnArgs} args - Arguments to create many TeacherModels.
     * @example
     * // Create many TeacherModels
     * const teacherModel = await prisma.teacherModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherModels and only return the `id`
     * const teacherModelWithIdOnly = await prisma.teacherModel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherModelCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeacherModel.
     * @param {TeacherModelDeleteArgs} args - Arguments to delete one TeacherModel.
     * @example
     * // Delete one TeacherModel
     * const TeacherModel = await prisma.teacherModel.delete({
     *   where: {
     *     // ... filter to delete one TeacherModel
     *   }
     * })
     * 
     */
    delete<T extends TeacherModelDeleteArgs>(args: SelectSubset<T, TeacherModelDeleteArgs<ExtArgs>>): Prisma__TeacherModelClient<$Result.GetResult<Prisma.$TeacherModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeacherModel.
     * @param {TeacherModelUpdateArgs} args - Arguments to update one TeacherModel.
     * @example
     * // Update one TeacherModel
     * const teacherModel = await prisma.teacherModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherModelUpdateArgs>(args: SelectSubset<T, TeacherModelUpdateArgs<ExtArgs>>): Prisma__TeacherModelClient<$Result.GetResult<Prisma.$TeacherModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeacherModels.
     * @param {TeacherModelDeleteManyArgs} args - Arguments to filter TeacherModels to delete.
     * @example
     * // Delete a few TeacherModels
     * const { count } = await prisma.teacherModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherModelDeleteManyArgs>(args?: SelectSubset<T, TeacherModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherModels
     * const teacherModel = await prisma.teacherModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherModelUpdateManyArgs>(args: SelectSubset<T, TeacherModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherModel.
     * @param {TeacherModelUpsertArgs} args - Arguments to update or create a TeacherModel.
     * @example
     * // Update or create a TeacherModel
     * const teacherModel = await prisma.teacherModel.upsert({
     *   create: {
     *     // ... data to create a TeacherModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherModel we want to update
     *   }
     * })
     */
    upsert<T extends TeacherModelUpsertArgs>(args: SelectSubset<T, TeacherModelUpsertArgs<ExtArgs>>): Prisma__TeacherModelClient<$Result.GetResult<Prisma.$TeacherModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeacherModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherModelCountArgs} args - Arguments to filter TeacherModels to count.
     * @example
     * // Count the number of TeacherModels
     * const count = await prisma.teacherModel.count({
     *   where: {
     *     // ... the filter for the TeacherModels we want to count
     *   }
     * })
    **/
    count<T extends TeacherModelCountArgs>(
      args?: Subset<T, TeacherModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherModelAggregateArgs>(args: Subset<T, TeacherModelAggregateArgs>): Prisma.PrismaPromise<GetTeacherModelAggregateType<T>>

    /**
     * Group by TeacherModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherModelGroupByArgs['orderBy'] }
        : { orderBy?: TeacherModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherModel model
   */
  readonly fields: TeacherModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherModel model
   */ 
  interface TeacherModelFieldRefs {
    readonly id: FieldRef<"TeacherModel", 'Int'>
    readonly teacherName: FieldRef<"TeacherModel", 'String'>
    readonly teacherGender: FieldRef<"TeacherModel", 'String'>
    readonly accommodationRequired: FieldRef<"TeacherModel", 'String'>
    readonly additionalRequirements: FieldRef<"TeacherModel", 'String'>
    readonly declaration: FieldRef<"TeacherModel", 'Boolean'>
    readonly writeup: FieldRef<"TeacherModel", 'String'>
    readonly schoolId: FieldRef<"TeacherModel", 'Int'>
    readonly createdAt: FieldRef<"TeacherModel", 'DateTime'>
    readonly updatedAt: FieldRef<"TeacherModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeacherModel findUnique
   */
  export type TeacherModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelInclude<ExtArgs> | null
    /**
     * Filter, which TeacherModel to fetch.
     */
    where: TeacherModelWhereUniqueInput
  }

  /**
   * TeacherModel findUniqueOrThrow
   */
  export type TeacherModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelInclude<ExtArgs> | null
    /**
     * Filter, which TeacherModel to fetch.
     */
    where: TeacherModelWhereUniqueInput
  }

  /**
   * TeacherModel findFirst
   */
  export type TeacherModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelInclude<ExtArgs> | null
    /**
     * Filter, which TeacherModel to fetch.
     */
    where?: TeacherModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherModels to fetch.
     */
    orderBy?: TeacherModelOrderByWithRelationInput | TeacherModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherModels.
     */
    cursor?: TeacherModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherModels.
     */
    distinct?: TeacherModelScalarFieldEnum | TeacherModelScalarFieldEnum[]
  }

  /**
   * TeacherModel findFirstOrThrow
   */
  export type TeacherModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelInclude<ExtArgs> | null
    /**
     * Filter, which TeacherModel to fetch.
     */
    where?: TeacherModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherModels to fetch.
     */
    orderBy?: TeacherModelOrderByWithRelationInput | TeacherModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherModels.
     */
    cursor?: TeacherModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherModels.
     */
    distinct?: TeacherModelScalarFieldEnum | TeacherModelScalarFieldEnum[]
  }

  /**
   * TeacherModel findMany
   */
  export type TeacherModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelInclude<ExtArgs> | null
    /**
     * Filter, which TeacherModels to fetch.
     */
    where?: TeacherModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherModels to fetch.
     */
    orderBy?: TeacherModelOrderByWithRelationInput | TeacherModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherModels.
     */
    cursor?: TeacherModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherModels.
     */
    skip?: number
    distinct?: TeacherModelScalarFieldEnum | TeacherModelScalarFieldEnum[]
  }

  /**
   * TeacherModel create
   */
  export type TeacherModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherModel.
     */
    data: XOR<TeacherModelCreateInput, TeacherModelUncheckedCreateInput>
  }

  /**
   * TeacherModel createMany
   */
  export type TeacherModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherModels.
     */
    data: TeacherModelCreateManyInput | TeacherModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeacherModel createManyAndReturn
   */
  export type TeacherModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeacherModels.
     */
    data: TeacherModelCreateManyInput | TeacherModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherModel update
   */
  export type TeacherModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherModel.
     */
    data: XOR<TeacherModelUpdateInput, TeacherModelUncheckedUpdateInput>
    /**
     * Choose, which TeacherModel to update.
     */
    where: TeacherModelWhereUniqueInput
  }

  /**
   * TeacherModel updateMany
   */
  export type TeacherModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherModels.
     */
    data: XOR<TeacherModelUpdateManyMutationInput, TeacherModelUncheckedUpdateManyInput>
    /**
     * Filter which TeacherModels to update
     */
    where?: TeacherModelWhereInput
  }

  /**
   * TeacherModel upsert
   */
  export type TeacherModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherModel to update in case it exists.
     */
    where: TeacherModelWhereUniqueInput
    /**
     * In case the TeacherModel found by the `where` argument doesn't exist, create a new TeacherModel with this data.
     */
    create: XOR<TeacherModelCreateInput, TeacherModelUncheckedCreateInput>
    /**
     * In case the TeacherModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherModelUpdateInput, TeacherModelUncheckedUpdateInput>
  }

  /**
   * TeacherModel delete
   */
  export type TeacherModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelInclude<ExtArgs> | null
    /**
     * Filter which TeacherModel to delete.
     */
    where: TeacherModelWhereUniqueInput
  }

  /**
   * TeacherModel deleteMany
   */
  export type TeacherModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherModels to delete
     */
    where?: TeacherModelWhereInput
  }

  /**
   * TeacherModel without action
   */
  export type TeacherModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherModel
     */
    select?: TeacherModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherModelInclude<ExtArgs> | null
  }


  /**
   * Model IPRExhibitionForm
   */

  export type AggregateIPRExhibitionForm = {
    _count: IPRExhibitionFormCountAggregateOutputType | null
    _avg: IPRExhibitionFormAvgAggregateOutputType | null
    _sum: IPRExhibitionFormSumAggregateOutputType | null
    _min: IPRExhibitionFormMinAggregateOutputType | null
    _max: IPRExhibitionFormMaxAggregateOutputType | null
  }

  export type IPRExhibitionFormAvgAggregateOutputType = {
    id: number | null
    powerOutlets: number | null
    numTables: number | null
    seatingCapacity: number | null
    teacherInvitation: number | null
    teacherRegistration: number | null
  }

  export type IPRExhibitionFormSumAggregateOutputType = {
    id: number | null
    powerOutlets: number | null
    numTables: number | null
    seatingCapacity: number | null
    teacherInvitation: number | null
    teacherRegistration: number | null
  }

  export type IPRExhibitionFormMinAggregateOutputType = {
    id: number | null
    hallDimension: string | null
    isEnclosedHall: string | null
    canBeDarkened: string | null
    hasCooling: string | null
    isGroundFloor: string | null
    hasStorageSpace: string | null
    powerOutlets: number | null
    numTables: number | null
    vrSpace: string | null
    hasWifi: string | null
    lectureHallArea: string | null
    seatingCapacity: number | null
    hasAVFacilities: string | null
    distanceFromExhibition: string | null
    accommodationProvided: string | null
    localTransportation: string | null
    secureParkingSpace: string | null
    manpowerForLoading: string | null
    contactPersonName: string | null
    contactPersonMobile: string | null
    contactPersonEmail: string | null
    venueLocation: string | null
    teacherInvitation: number | null
    teacherRegistration: number | null
    providesWritingMaterials: string | null
    providesRefreshments: string | null
    quizForSchoolStudents: string | null
    quizTeamSelection: string | null
    quizArrangements: string | null
    quizRefreshments: string | null
  }

  export type IPRExhibitionFormMaxAggregateOutputType = {
    id: number | null
    hallDimension: string | null
    isEnclosedHall: string | null
    canBeDarkened: string | null
    hasCooling: string | null
    isGroundFloor: string | null
    hasStorageSpace: string | null
    powerOutlets: number | null
    numTables: number | null
    vrSpace: string | null
    hasWifi: string | null
    lectureHallArea: string | null
    seatingCapacity: number | null
    hasAVFacilities: string | null
    distanceFromExhibition: string | null
    accommodationProvided: string | null
    localTransportation: string | null
    secureParkingSpace: string | null
    manpowerForLoading: string | null
    contactPersonName: string | null
    contactPersonMobile: string | null
    contactPersonEmail: string | null
    venueLocation: string | null
    teacherInvitation: number | null
    teacherRegistration: number | null
    providesWritingMaterials: string | null
    providesRefreshments: string | null
    quizForSchoolStudents: string | null
    quizTeamSelection: string | null
    quizArrangements: string | null
    quizRefreshments: string | null
  }

  export type IPRExhibitionFormCountAggregateOutputType = {
    id: number
    hallDimension: number
    isEnclosedHall: number
    canBeDarkened: number
    hasCooling: number
    isGroundFloor: number
    hasStorageSpace: number
    powerOutlets: number
    numTables: number
    vrSpace: number
    hasWifi: number
    lectureHallArea: number
    seatingCapacity: number
    hasAVFacilities: number
    distanceFromExhibition: number
    accommodationProvided: number
    localTransportation: number
    secureParkingSpace: number
    manpowerForLoading: number
    contactPersonName: number
    contactPersonMobile: number
    contactPersonEmail: number
    venueLocation: number
    teacherInvitation: number
    teacherRegistration: number
    providesWritingMaterials: number
    providesRefreshments: number
    quizForSchoolStudents: number
    quizTeamSelection: number
    quizArrangements: number
    quizRefreshments: number
    _all: number
  }


  export type IPRExhibitionFormAvgAggregateInputType = {
    id?: true
    powerOutlets?: true
    numTables?: true
    seatingCapacity?: true
    teacherInvitation?: true
    teacherRegistration?: true
  }

  export type IPRExhibitionFormSumAggregateInputType = {
    id?: true
    powerOutlets?: true
    numTables?: true
    seatingCapacity?: true
    teacherInvitation?: true
    teacherRegistration?: true
  }

  export type IPRExhibitionFormMinAggregateInputType = {
    id?: true
    hallDimension?: true
    isEnclosedHall?: true
    canBeDarkened?: true
    hasCooling?: true
    isGroundFloor?: true
    hasStorageSpace?: true
    powerOutlets?: true
    numTables?: true
    vrSpace?: true
    hasWifi?: true
    lectureHallArea?: true
    seatingCapacity?: true
    hasAVFacilities?: true
    distanceFromExhibition?: true
    accommodationProvided?: true
    localTransportation?: true
    secureParkingSpace?: true
    manpowerForLoading?: true
    contactPersonName?: true
    contactPersonMobile?: true
    contactPersonEmail?: true
    venueLocation?: true
    teacherInvitation?: true
    teacherRegistration?: true
    providesWritingMaterials?: true
    providesRefreshments?: true
    quizForSchoolStudents?: true
    quizTeamSelection?: true
    quizArrangements?: true
    quizRefreshments?: true
  }

  export type IPRExhibitionFormMaxAggregateInputType = {
    id?: true
    hallDimension?: true
    isEnclosedHall?: true
    canBeDarkened?: true
    hasCooling?: true
    isGroundFloor?: true
    hasStorageSpace?: true
    powerOutlets?: true
    numTables?: true
    vrSpace?: true
    hasWifi?: true
    lectureHallArea?: true
    seatingCapacity?: true
    hasAVFacilities?: true
    distanceFromExhibition?: true
    accommodationProvided?: true
    localTransportation?: true
    secureParkingSpace?: true
    manpowerForLoading?: true
    contactPersonName?: true
    contactPersonMobile?: true
    contactPersonEmail?: true
    venueLocation?: true
    teacherInvitation?: true
    teacherRegistration?: true
    providesWritingMaterials?: true
    providesRefreshments?: true
    quizForSchoolStudents?: true
    quizTeamSelection?: true
    quizArrangements?: true
    quizRefreshments?: true
  }

  export type IPRExhibitionFormCountAggregateInputType = {
    id?: true
    hallDimension?: true
    isEnclosedHall?: true
    canBeDarkened?: true
    hasCooling?: true
    isGroundFloor?: true
    hasStorageSpace?: true
    powerOutlets?: true
    numTables?: true
    vrSpace?: true
    hasWifi?: true
    lectureHallArea?: true
    seatingCapacity?: true
    hasAVFacilities?: true
    distanceFromExhibition?: true
    accommodationProvided?: true
    localTransportation?: true
    secureParkingSpace?: true
    manpowerForLoading?: true
    contactPersonName?: true
    contactPersonMobile?: true
    contactPersonEmail?: true
    venueLocation?: true
    teacherInvitation?: true
    teacherRegistration?: true
    providesWritingMaterials?: true
    providesRefreshments?: true
    quizForSchoolStudents?: true
    quizTeamSelection?: true
    quizArrangements?: true
    quizRefreshments?: true
    _all?: true
  }

  export type IPRExhibitionFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IPRExhibitionForm to aggregate.
     */
    where?: IPRExhibitionFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPRExhibitionForms to fetch.
     */
    orderBy?: IPRExhibitionFormOrderByWithRelationInput | IPRExhibitionFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IPRExhibitionFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPRExhibitionForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPRExhibitionForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IPRExhibitionForms
    **/
    _count?: true | IPRExhibitionFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IPRExhibitionFormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IPRExhibitionFormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IPRExhibitionFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IPRExhibitionFormMaxAggregateInputType
  }

  export type GetIPRExhibitionFormAggregateType<T extends IPRExhibitionFormAggregateArgs> = {
        [P in keyof T & keyof AggregateIPRExhibitionForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIPRExhibitionForm[P]>
      : GetScalarType<T[P], AggregateIPRExhibitionForm[P]>
  }




  export type IPRExhibitionFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IPRExhibitionFormWhereInput
    orderBy?: IPRExhibitionFormOrderByWithAggregationInput | IPRExhibitionFormOrderByWithAggregationInput[]
    by: IPRExhibitionFormScalarFieldEnum[] | IPRExhibitionFormScalarFieldEnum
    having?: IPRExhibitionFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IPRExhibitionFormCountAggregateInputType | true
    _avg?: IPRExhibitionFormAvgAggregateInputType
    _sum?: IPRExhibitionFormSumAggregateInputType
    _min?: IPRExhibitionFormMinAggregateInputType
    _max?: IPRExhibitionFormMaxAggregateInputType
  }

  export type IPRExhibitionFormGroupByOutputType = {
    id: number
    hallDimension: string
    isEnclosedHall: string
    canBeDarkened: string
    hasCooling: string | null
    isGroundFloor: string
    hasStorageSpace: string | null
    powerOutlets: number
    numTables: number | null
    vrSpace: string | null
    hasWifi: string | null
    lectureHallArea: string
    seatingCapacity: number
    hasAVFacilities: string | null
    distanceFromExhibition: string | null
    accommodationProvided: string | null
    localTransportation: string | null
    secureParkingSpace: string | null
    manpowerForLoading: string | null
    contactPersonName: string
    contactPersonMobile: string
    contactPersonEmail: string
    venueLocation: string
    teacherInvitation: number
    teacherRegistration: number
    providesWritingMaterials: string | null
    providesRefreshments: string | null
    quizForSchoolStudents: string | null
    quizTeamSelection: string | null
    quizArrangements: string | null
    quizRefreshments: string | null
    _count: IPRExhibitionFormCountAggregateOutputType | null
    _avg: IPRExhibitionFormAvgAggregateOutputType | null
    _sum: IPRExhibitionFormSumAggregateOutputType | null
    _min: IPRExhibitionFormMinAggregateOutputType | null
    _max: IPRExhibitionFormMaxAggregateOutputType | null
  }

  type GetIPRExhibitionFormGroupByPayload<T extends IPRExhibitionFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IPRExhibitionFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IPRExhibitionFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IPRExhibitionFormGroupByOutputType[P]>
            : GetScalarType<T[P], IPRExhibitionFormGroupByOutputType[P]>
        }
      >
    >


  export type IPRExhibitionFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hallDimension?: boolean
    isEnclosedHall?: boolean
    canBeDarkened?: boolean
    hasCooling?: boolean
    isGroundFloor?: boolean
    hasStorageSpace?: boolean
    powerOutlets?: boolean
    numTables?: boolean
    vrSpace?: boolean
    hasWifi?: boolean
    lectureHallArea?: boolean
    seatingCapacity?: boolean
    hasAVFacilities?: boolean
    distanceFromExhibition?: boolean
    accommodationProvided?: boolean
    localTransportation?: boolean
    secureParkingSpace?: boolean
    manpowerForLoading?: boolean
    contactPersonName?: boolean
    contactPersonMobile?: boolean
    contactPersonEmail?: boolean
    venueLocation?: boolean
    teacherInvitation?: boolean
    teacherRegistration?: boolean
    providesWritingMaterials?: boolean
    providesRefreshments?: boolean
    quizForSchoolStudents?: boolean
    quizTeamSelection?: boolean
    quizArrangements?: boolean
    quizRefreshments?: boolean
  }, ExtArgs["result"]["iPRExhibitionForm"]>

  export type IPRExhibitionFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hallDimension?: boolean
    isEnclosedHall?: boolean
    canBeDarkened?: boolean
    hasCooling?: boolean
    isGroundFloor?: boolean
    hasStorageSpace?: boolean
    powerOutlets?: boolean
    numTables?: boolean
    vrSpace?: boolean
    hasWifi?: boolean
    lectureHallArea?: boolean
    seatingCapacity?: boolean
    hasAVFacilities?: boolean
    distanceFromExhibition?: boolean
    accommodationProvided?: boolean
    localTransportation?: boolean
    secureParkingSpace?: boolean
    manpowerForLoading?: boolean
    contactPersonName?: boolean
    contactPersonMobile?: boolean
    contactPersonEmail?: boolean
    venueLocation?: boolean
    teacherInvitation?: boolean
    teacherRegistration?: boolean
    providesWritingMaterials?: boolean
    providesRefreshments?: boolean
    quizForSchoolStudents?: boolean
    quizTeamSelection?: boolean
    quizArrangements?: boolean
    quizRefreshments?: boolean
  }, ExtArgs["result"]["iPRExhibitionForm"]>

  export type IPRExhibitionFormSelectScalar = {
    id?: boolean
    hallDimension?: boolean
    isEnclosedHall?: boolean
    canBeDarkened?: boolean
    hasCooling?: boolean
    isGroundFloor?: boolean
    hasStorageSpace?: boolean
    powerOutlets?: boolean
    numTables?: boolean
    vrSpace?: boolean
    hasWifi?: boolean
    lectureHallArea?: boolean
    seatingCapacity?: boolean
    hasAVFacilities?: boolean
    distanceFromExhibition?: boolean
    accommodationProvided?: boolean
    localTransportation?: boolean
    secureParkingSpace?: boolean
    manpowerForLoading?: boolean
    contactPersonName?: boolean
    contactPersonMobile?: boolean
    contactPersonEmail?: boolean
    venueLocation?: boolean
    teacherInvitation?: boolean
    teacherRegistration?: boolean
    providesWritingMaterials?: boolean
    providesRefreshments?: boolean
    quizForSchoolStudents?: boolean
    quizTeamSelection?: boolean
    quizArrangements?: boolean
    quizRefreshments?: boolean
  }


  export type $IPRExhibitionFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IPRExhibitionForm"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hallDimension: string
      isEnclosedHall: string
      canBeDarkened: string
      hasCooling: string | null
      isGroundFloor: string
      hasStorageSpace: string | null
      powerOutlets: number
      numTables: number | null
      vrSpace: string | null
      hasWifi: string | null
      lectureHallArea: string
      seatingCapacity: number
      hasAVFacilities: string | null
      distanceFromExhibition: string | null
      accommodationProvided: string | null
      localTransportation: string | null
      secureParkingSpace: string | null
      manpowerForLoading: string | null
      contactPersonName: string
      contactPersonMobile: string
      contactPersonEmail: string
      venueLocation: string
      teacherInvitation: number
      teacherRegistration: number
      providesWritingMaterials: string | null
      providesRefreshments: string | null
      quizForSchoolStudents: string | null
      quizTeamSelection: string | null
      quizArrangements: string | null
      quizRefreshments: string | null
    }, ExtArgs["result"]["iPRExhibitionForm"]>
    composites: {}
  }

  type IPRExhibitionFormGetPayload<S extends boolean | null | undefined | IPRExhibitionFormDefaultArgs> = $Result.GetResult<Prisma.$IPRExhibitionFormPayload, S>

  type IPRExhibitionFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IPRExhibitionFormFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IPRExhibitionFormCountAggregateInputType | true
    }

  export interface IPRExhibitionFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IPRExhibitionForm'], meta: { name: 'IPRExhibitionForm' } }
    /**
     * Find zero or one IPRExhibitionForm that matches the filter.
     * @param {IPRExhibitionFormFindUniqueArgs} args - Arguments to find a IPRExhibitionForm
     * @example
     * // Get one IPRExhibitionForm
     * const iPRExhibitionForm = await prisma.iPRExhibitionForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IPRExhibitionFormFindUniqueArgs>(args: SelectSubset<T, IPRExhibitionFormFindUniqueArgs<ExtArgs>>): Prisma__IPRExhibitionFormClient<$Result.GetResult<Prisma.$IPRExhibitionFormPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IPRExhibitionForm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IPRExhibitionFormFindUniqueOrThrowArgs} args - Arguments to find a IPRExhibitionForm
     * @example
     * // Get one IPRExhibitionForm
     * const iPRExhibitionForm = await prisma.iPRExhibitionForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IPRExhibitionFormFindUniqueOrThrowArgs>(args: SelectSubset<T, IPRExhibitionFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IPRExhibitionFormClient<$Result.GetResult<Prisma.$IPRExhibitionFormPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IPRExhibitionForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPRExhibitionFormFindFirstArgs} args - Arguments to find a IPRExhibitionForm
     * @example
     * // Get one IPRExhibitionForm
     * const iPRExhibitionForm = await prisma.iPRExhibitionForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IPRExhibitionFormFindFirstArgs>(args?: SelectSubset<T, IPRExhibitionFormFindFirstArgs<ExtArgs>>): Prisma__IPRExhibitionFormClient<$Result.GetResult<Prisma.$IPRExhibitionFormPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IPRExhibitionForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPRExhibitionFormFindFirstOrThrowArgs} args - Arguments to find a IPRExhibitionForm
     * @example
     * // Get one IPRExhibitionForm
     * const iPRExhibitionForm = await prisma.iPRExhibitionForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IPRExhibitionFormFindFirstOrThrowArgs>(args?: SelectSubset<T, IPRExhibitionFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__IPRExhibitionFormClient<$Result.GetResult<Prisma.$IPRExhibitionFormPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IPRExhibitionForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPRExhibitionFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IPRExhibitionForms
     * const iPRExhibitionForms = await prisma.iPRExhibitionForm.findMany()
     * 
     * // Get first 10 IPRExhibitionForms
     * const iPRExhibitionForms = await prisma.iPRExhibitionForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iPRExhibitionFormWithIdOnly = await prisma.iPRExhibitionForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IPRExhibitionFormFindManyArgs>(args?: SelectSubset<T, IPRExhibitionFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPRExhibitionFormPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IPRExhibitionForm.
     * @param {IPRExhibitionFormCreateArgs} args - Arguments to create a IPRExhibitionForm.
     * @example
     * // Create one IPRExhibitionForm
     * const IPRExhibitionForm = await prisma.iPRExhibitionForm.create({
     *   data: {
     *     // ... data to create a IPRExhibitionForm
     *   }
     * })
     * 
     */
    create<T extends IPRExhibitionFormCreateArgs>(args: SelectSubset<T, IPRExhibitionFormCreateArgs<ExtArgs>>): Prisma__IPRExhibitionFormClient<$Result.GetResult<Prisma.$IPRExhibitionFormPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IPRExhibitionForms.
     * @param {IPRExhibitionFormCreateManyArgs} args - Arguments to create many IPRExhibitionForms.
     * @example
     * // Create many IPRExhibitionForms
     * const iPRExhibitionForm = await prisma.iPRExhibitionForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IPRExhibitionFormCreateManyArgs>(args?: SelectSubset<T, IPRExhibitionFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IPRExhibitionForms and returns the data saved in the database.
     * @param {IPRExhibitionFormCreateManyAndReturnArgs} args - Arguments to create many IPRExhibitionForms.
     * @example
     * // Create many IPRExhibitionForms
     * const iPRExhibitionForm = await prisma.iPRExhibitionForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IPRExhibitionForms and only return the `id`
     * const iPRExhibitionFormWithIdOnly = await prisma.iPRExhibitionForm.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IPRExhibitionFormCreateManyAndReturnArgs>(args?: SelectSubset<T, IPRExhibitionFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPRExhibitionFormPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IPRExhibitionForm.
     * @param {IPRExhibitionFormDeleteArgs} args - Arguments to delete one IPRExhibitionForm.
     * @example
     * // Delete one IPRExhibitionForm
     * const IPRExhibitionForm = await prisma.iPRExhibitionForm.delete({
     *   where: {
     *     // ... filter to delete one IPRExhibitionForm
     *   }
     * })
     * 
     */
    delete<T extends IPRExhibitionFormDeleteArgs>(args: SelectSubset<T, IPRExhibitionFormDeleteArgs<ExtArgs>>): Prisma__IPRExhibitionFormClient<$Result.GetResult<Prisma.$IPRExhibitionFormPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IPRExhibitionForm.
     * @param {IPRExhibitionFormUpdateArgs} args - Arguments to update one IPRExhibitionForm.
     * @example
     * // Update one IPRExhibitionForm
     * const iPRExhibitionForm = await prisma.iPRExhibitionForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IPRExhibitionFormUpdateArgs>(args: SelectSubset<T, IPRExhibitionFormUpdateArgs<ExtArgs>>): Prisma__IPRExhibitionFormClient<$Result.GetResult<Prisma.$IPRExhibitionFormPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IPRExhibitionForms.
     * @param {IPRExhibitionFormDeleteManyArgs} args - Arguments to filter IPRExhibitionForms to delete.
     * @example
     * // Delete a few IPRExhibitionForms
     * const { count } = await prisma.iPRExhibitionForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IPRExhibitionFormDeleteManyArgs>(args?: SelectSubset<T, IPRExhibitionFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IPRExhibitionForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPRExhibitionFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IPRExhibitionForms
     * const iPRExhibitionForm = await prisma.iPRExhibitionForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IPRExhibitionFormUpdateManyArgs>(args: SelectSubset<T, IPRExhibitionFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IPRExhibitionForm.
     * @param {IPRExhibitionFormUpsertArgs} args - Arguments to update or create a IPRExhibitionForm.
     * @example
     * // Update or create a IPRExhibitionForm
     * const iPRExhibitionForm = await prisma.iPRExhibitionForm.upsert({
     *   create: {
     *     // ... data to create a IPRExhibitionForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IPRExhibitionForm we want to update
     *   }
     * })
     */
    upsert<T extends IPRExhibitionFormUpsertArgs>(args: SelectSubset<T, IPRExhibitionFormUpsertArgs<ExtArgs>>): Prisma__IPRExhibitionFormClient<$Result.GetResult<Prisma.$IPRExhibitionFormPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IPRExhibitionForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPRExhibitionFormCountArgs} args - Arguments to filter IPRExhibitionForms to count.
     * @example
     * // Count the number of IPRExhibitionForms
     * const count = await prisma.iPRExhibitionForm.count({
     *   where: {
     *     // ... the filter for the IPRExhibitionForms we want to count
     *   }
     * })
    **/
    count<T extends IPRExhibitionFormCountArgs>(
      args?: Subset<T, IPRExhibitionFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IPRExhibitionFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IPRExhibitionForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPRExhibitionFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IPRExhibitionFormAggregateArgs>(args: Subset<T, IPRExhibitionFormAggregateArgs>): Prisma.PrismaPromise<GetIPRExhibitionFormAggregateType<T>>

    /**
     * Group by IPRExhibitionForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPRExhibitionFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IPRExhibitionFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IPRExhibitionFormGroupByArgs['orderBy'] }
        : { orderBy?: IPRExhibitionFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IPRExhibitionFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIPRExhibitionFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IPRExhibitionForm model
   */
  readonly fields: IPRExhibitionFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IPRExhibitionForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IPRExhibitionFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IPRExhibitionForm model
   */ 
  interface IPRExhibitionFormFieldRefs {
    readonly id: FieldRef<"IPRExhibitionForm", 'Int'>
    readonly hallDimension: FieldRef<"IPRExhibitionForm", 'String'>
    readonly isEnclosedHall: FieldRef<"IPRExhibitionForm", 'String'>
    readonly canBeDarkened: FieldRef<"IPRExhibitionForm", 'String'>
    readonly hasCooling: FieldRef<"IPRExhibitionForm", 'String'>
    readonly isGroundFloor: FieldRef<"IPRExhibitionForm", 'String'>
    readonly hasStorageSpace: FieldRef<"IPRExhibitionForm", 'String'>
    readonly powerOutlets: FieldRef<"IPRExhibitionForm", 'Int'>
    readonly numTables: FieldRef<"IPRExhibitionForm", 'Int'>
    readonly vrSpace: FieldRef<"IPRExhibitionForm", 'String'>
    readonly hasWifi: FieldRef<"IPRExhibitionForm", 'String'>
    readonly lectureHallArea: FieldRef<"IPRExhibitionForm", 'String'>
    readonly seatingCapacity: FieldRef<"IPRExhibitionForm", 'Int'>
    readonly hasAVFacilities: FieldRef<"IPRExhibitionForm", 'String'>
    readonly distanceFromExhibition: FieldRef<"IPRExhibitionForm", 'String'>
    readonly accommodationProvided: FieldRef<"IPRExhibitionForm", 'String'>
    readonly localTransportation: FieldRef<"IPRExhibitionForm", 'String'>
    readonly secureParkingSpace: FieldRef<"IPRExhibitionForm", 'String'>
    readonly manpowerForLoading: FieldRef<"IPRExhibitionForm", 'String'>
    readonly contactPersonName: FieldRef<"IPRExhibitionForm", 'String'>
    readonly contactPersonMobile: FieldRef<"IPRExhibitionForm", 'String'>
    readonly contactPersonEmail: FieldRef<"IPRExhibitionForm", 'String'>
    readonly venueLocation: FieldRef<"IPRExhibitionForm", 'String'>
    readonly teacherInvitation: FieldRef<"IPRExhibitionForm", 'Int'>
    readonly teacherRegistration: FieldRef<"IPRExhibitionForm", 'Int'>
    readonly providesWritingMaterials: FieldRef<"IPRExhibitionForm", 'String'>
    readonly providesRefreshments: FieldRef<"IPRExhibitionForm", 'String'>
    readonly quizForSchoolStudents: FieldRef<"IPRExhibitionForm", 'String'>
    readonly quizTeamSelection: FieldRef<"IPRExhibitionForm", 'String'>
    readonly quizArrangements: FieldRef<"IPRExhibitionForm", 'String'>
    readonly quizRefreshments: FieldRef<"IPRExhibitionForm", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IPRExhibitionForm findUnique
   */
  export type IPRExhibitionFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPRExhibitionForm
     */
    select?: IPRExhibitionFormSelect<ExtArgs> | null
    /**
     * Filter, which IPRExhibitionForm to fetch.
     */
    where: IPRExhibitionFormWhereUniqueInput
  }

  /**
   * IPRExhibitionForm findUniqueOrThrow
   */
  export type IPRExhibitionFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPRExhibitionForm
     */
    select?: IPRExhibitionFormSelect<ExtArgs> | null
    /**
     * Filter, which IPRExhibitionForm to fetch.
     */
    where: IPRExhibitionFormWhereUniqueInput
  }

  /**
   * IPRExhibitionForm findFirst
   */
  export type IPRExhibitionFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPRExhibitionForm
     */
    select?: IPRExhibitionFormSelect<ExtArgs> | null
    /**
     * Filter, which IPRExhibitionForm to fetch.
     */
    where?: IPRExhibitionFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPRExhibitionForms to fetch.
     */
    orderBy?: IPRExhibitionFormOrderByWithRelationInput | IPRExhibitionFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IPRExhibitionForms.
     */
    cursor?: IPRExhibitionFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPRExhibitionForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPRExhibitionForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IPRExhibitionForms.
     */
    distinct?: IPRExhibitionFormScalarFieldEnum | IPRExhibitionFormScalarFieldEnum[]
  }

  /**
   * IPRExhibitionForm findFirstOrThrow
   */
  export type IPRExhibitionFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPRExhibitionForm
     */
    select?: IPRExhibitionFormSelect<ExtArgs> | null
    /**
     * Filter, which IPRExhibitionForm to fetch.
     */
    where?: IPRExhibitionFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPRExhibitionForms to fetch.
     */
    orderBy?: IPRExhibitionFormOrderByWithRelationInput | IPRExhibitionFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IPRExhibitionForms.
     */
    cursor?: IPRExhibitionFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPRExhibitionForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPRExhibitionForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IPRExhibitionForms.
     */
    distinct?: IPRExhibitionFormScalarFieldEnum | IPRExhibitionFormScalarFieldEnum[]
  }

  /**
   * IPRExhibitionForm findMany
   */
  export type IPRExhibitionFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPRExhibitionForm
     */
    select?: IPRExhibitionFormSelect<ExtArgs> | null
    /**
     * Filter, which IPRExhibitionForms to fetch.
     */
    where?: IPRExhibitionFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPRExhibitionForms to fetch.
     */
    orderBy?: IPRExhibitionFormOrderByWithRelationInput | IPRExhibitionFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IPRExhibitionForms.
     */
    cursor?: IPRExhibitionFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPRExhibitionForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPRExhibitionForms.
     */
    skip?: number
    distinct?: IPRExhibitionFormScalarFieldEnum | IPRExhibitionFormScalarFieldEnum[]
  }

  /**
   * IPRExhibitionForm create
   */
  export type IPRExhibitionFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPRExhibitionForm
     */
    select?: IPRExhibitionFormSelect<ExtArgs> | null
    /**
     * The data needed to create a IPRExhibitionForm.
     */
    data: XOR<IPRExhibitionFormCreateInput, IPRExhibitionFormUncheckedCreateInput>
  }

  /**
   * IPRExhibitionForm createMany
   */
  export type IPRExhibitionFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IPRExhibitionForms.
     */
    data: IPRExhibitionFormCreateManyInput | IPRExhibitionFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IPRExhibitionForm createManyAndReturn
   */
  export type IPRExhibitionFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPRExhibitionForm
     */
    select?: IPRExhibitionFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IPRExhibitionForms.
     */
    data: IPRExhibitionFormCreateManyInput | IPRExhibitionFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IPRExhibitionForm update
   */
  export type IPRExhibitionFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPRExhibitionForm
     */
    select?: IPRExhibitionFormSelect<ExtArgs> | null
    /**
     * The data needed to update a IPRExhibitionForm.
     */
    data: XOR<IPRExhibitionFormUpdateInput, IPRExhibitionFormUncheckedUpdateInput>
    /**
     * Choose, which IPRExhibitionForm to update.
     */
    where: IPRExhibitionFormWhereUniqueInput
  }

  /**
   * IPRExhibitionForm updateMany
   */
  export type IPRExhibitionFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IPRExhibitionForms.
     */
    data: XOR<IPRExhibitionFormUpdateManyMutationInput, IPRExhibitionFormUncheckedUpdateManyInput>
    /**
     * Filter which IPRExhibitionForms to update
     */
    where?: IPRExhibitionFormWhereInput
  }

  /**
   * IPRExhibitionForm upsert
   */
  export type IPRExhibitionFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPRExhibitionForm
     */
    select?: IPRExhibitionFormSelect<ExtArgs> | null
    /**
     * The filter to search for the IPRExhibitionForm to update in case it exists.
     */
    where: IPRExhibitionFormWhereUniqueInput
    /**
     * In case the IPRExhibitionForm found by the `where` argument doesn't exist, create a new IPRExhibitionForm with this data.
     */
    create: XOR<IPRExhibitionFormCreateInput, IPRExhibitionFormUncheckedCreateInput>
    /**
     * In case the IPRExhibitionForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IPRExhibitionFormUpdateInput, IPRExhibitionFormUncheckedUpdateInput>
  }

  /**
   * IPRExhibitionForm delete
   */
  export type IPRExhibitionFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPRExhibitionForm
     */
    select?: IPRExhibitionFormSelect<ExtArgs> | null
    /**
     * Filter which IPRExhibitionForm to delete.
     */
    where: IPRExhibitionFormWhereUniqueInput
  }

  /**
   * IPRExhibitionForm deleteMany
   */
  export type IPRExhibitionFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IPRExhibitionForms to delete
     */
    where?: IPRExhibitionFormWhereInput
  }

  /**
   * IPRExhibitionForm without action
   */
  export type IPRExhibitionFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPRExhibitionForm
     */
    select?: IPRExhibitionFormSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RatingsScalarFieldEnum: {
    id: 'id',
    iprRating: 'iprRating',
    fciptRating: 'fciptRating',
    knowledge: 'knowledge',
    explanationsIPR: 'explanationsIPR',
    explanationsFCIPT: 'explanationsFCIPT',
    knowledgeBefore: 'knowledgeBefore',
    knowledgeAfter: 'knowledgeAfter',
    technicalContents: 'technicalContents',
    easeOfUnderstanding: 'easeOfUnderstanding',
    feedbackFormId: 'feedbackFormId'
  };

  export type RatingsScalarFieldEnum = (typeof RatingsScalarFieldEnum)[keyof typeof RatingsScalarFieldEnum]


  export const FeedbackFormScalarFieldEnum: {
    id: 'id',
    institutionName: 'institutionName',
    website: 'website',
    visitDate: 'visitDate',
    staffName: 'staffName',
    staffEmail: 'staffEmail',
    staffMobile: 'staffMobile',
    totalStudents: 'totalStudents',
    accompanyingStaff: 'accompanyingStaff',
    sources: 'sources',
    campuses: 'campuses',
    best: 'best',
    worst: 'worst',
    suggestions: 'suggestions',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedbackFormScalarFieldEnum = (typeof FeedbackFormScalarFieldEnum)[keyof typeof FeedbackFormScalarFieldEnum]


  export const VisitorScalarFieldEnum: {
    id: 'id',
    institutionName: 'institutionName',
    studentBranch: 'studentBranch',
    studentSem: 'studentSem',
    numStudents: 'numStudents',
    numFaculty: 'numFaculty',
    name: 'name',
    position: 'position',
    email: 'email',
    mobile: 'mobile',
    campus: 'campus',
    ipr_time: 'ipr_time',
    fcipt_time: 'fcipt_time',
    visit_date: 'visit_date',
    visit_time: 'visit_time',
    materials: 'materials',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitorScalarFieldEnum = (typeof VisitorScalarFieldEnum)[keyof typeof VisitorScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    pincode: 'pincode',
    affiliationNumber: 'affiliationNumber',
    coordinatorTeacherName: 'coordinatorTeacherName',
    coordinatorTeacherMobile: 'coordinatorTeacherMobile',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const AccompanyingTeacherScalarFieldEnum: {
    id: 'id',
    name: 'name',
    gender: 'gender',
    requiresAccommodation: 'requiresAccommodation',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccompanyingTeacherScalarFieldEnum = (typeof AccompanyingTeacherScalarFieldEnum)[keyof typeof AccompanyingTeacherScalarFieldEnum]


  export const CompetitionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompetitionScalarFieldEnum = (typeof CompetitionScalarFieldEnum)[keyof typeof CompetitionScalarFieldEnum]


  export const StudentModel1ScalarFieldEnum: {
    id: 'id',
    participant1Name: 'participant1Name',
    participant1Gender: 'participant1Gender',
    participant1Class: 'participant1Class',
    participant1Accommodation: 'participant1Accommodation',
    participant2Name: 'participant2Name',
    participant2Gender: 'participant2Gender',
    participant2Class: 'participant2Class',
    participant2Accommodation: 'participant2Accommodation',
    additionalRequirements: 'additionalRequirements',
    declaration: 'declaration',
    writeup: 'writeup',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentModel1ScalarFieldEnum = (typeof StudentModel1ScalarFieldEnum)[keyof typeof StudentModel1ScalarFieldEnum]


  export const StudentModel2ScalarFieldEnum: {
    id: 'id',
    participant1Name: 'participant1Name',
    participant1Gender: 'participant1Gender',
    participant1Class: 'participant1Class',
    participant1Accommodation: 'participant1Accommodation',
    participant2Name: 'participant2Name',
    participant2Gender: 'participant2Gender',
    participant2Class: 'participant2Class',
    participant2Accommodation: 'participant2Accommodation',
    additionalRequirements: 'additionalRequirements',
    declaration: 'declaration',
    writeup: 'writeup',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentModel2ScalarFieldEnum = (typeof StudentModel2ScalarFieldEnum)[keyof typeof StudentModel2ScalarFieldEnum]


  export const EloquenceEnglishScalarFieldEnum: {
    id: 'id',
    participantName: 'participantName',
    participantGender: 'participantGender',
    participantClass: 'participantClass',
    accommodationRequired: 'accommodationRequired',
    declaration: 'declaration',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EloquenceEnglishScalarFieldEnum = (typeof EloquenceEnglishScalarFieldEnum)[keyof typeof EloquenceEnglishScalarFieldEnum]


  export const EloquenceHindiScalarFieldEnum: {
    id: 'id',
    participantName: 'participantName',
    participantGender: 'participantGender',
    participantClass: 'participantClass',
    accommodationRequired: 'accommodationRequired',
    declaration: 'declaration',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EloquenceHindiScalarFieldEnum = (typeof EloquenceHindiScalarFieldEnum)[keyof typeof EloquenceHindiScalarFieldEnum]


  export const EloquenceGujaratiScalarFieldEnum: {
    id: 'id',
    participantName: 'participantName',
    participantGender: 'participantGender',
    participantClass: 'participantClass',
    accommodationRequired: 'accommodationRequired',
    declaration: 'declaration',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EloquenceGujaratiScalarFieldEnum = (typeof EloquenceGujaratiScalarFieldEnum)[keyof typeof EloquenceGujaratiScalarFieldEnum]


  export const EssayEnglishScalarFieldEnum: {
    id: 'id',
    participantName: 'participantName',
    participantGender: 'participantGender',
    participantClass: 'participantClass',
    accommodationRequired: 'accommodationRequired',
    essayFileUrl: 'essayFileUrl',
    declaration: 'declaration',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EssayEnglishScalarFieldEnum = (typeof EssayEnglishScalarFieldEnum)[keyof typeof EssayEnglishScalarFieldEnum]


  export const EssayHindiScalarFieldEnum: {
    id: 'id',
    participantName: 'participantName',
    participantGender: 'participantGender',
    participantClass: 'participantClass',
    accommodationRequired: 'accommodationRequired',
    essayFileUrl: 'essayFileUrl',
    declaration: 'declaration',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EssayHindiScalarFieldEnum = (typeof EssayHindiScalarFieldEnum)[keyof typeof EssayHindiScalarFieldEnum]


  export const EssayGujaratiScalarFieldEnum: {
    id: 'id',
    participantName: 'participantName',
    participantGender: 'participantGender',
    participantClass: 'participantClass',
    accommodationRequired: 'accommodationRequired',
    essayFileUrl: 'essayFileUrl',
    declaration: 'declaration',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EssayGujaratiScalarFieldEnum = (typeof EssayGujaratiScalarFieldEnum)[keyof typeof EssayGujaratiScalarFieldEnum]


  export const PosterScalarFieldEnum: {
    id: 'id',
    participant1Name: 'participant1Name',
    participant1Gender: 'participant1Gender',
    participant1Class: 'participant1Class',
    participant1Accommodation: 'participant1Accommodation',
    participant1Declaration: 'participant1Declaration',
    participant2Name: 'participant2Name',
    participant2Gender: 'participant2Gender',
    participant2Class: 'participant2Class',
    participant2Accommodation: 'participant2Accommodation',
    participant2Declaration: 'participant2Declaration',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PosterScalarFieldEnum = (typeof PosterScalarFieldEnum)[keyof typeof PosterScalarFieldEnum]


  export const SkitScalarFieldEnum: {
    id: 'id',
    participant1Name: 'participant1Name',
    participant1Gender: 'participant1Gender',
    participant1Class: 'participant1Class',
    participant1Accommodation: 'participant1Accommodation',
    participant2Name: 'participant2Name',
    participant2Gender: 'participant2Gender',
    participant2Class: 'participant2Class',
    participant2Accommodation: 'participant2Accommodation',
    participant3Name: 'participant3Name',
    participant3Gender: 'participant3Gender',
    participant3Class: 'participant3Class',
    participant3Accommodation: 'participant3Accommodation',
    participant4Name: 'participant4Name',
    participant4Gender: 'participant4Gender',
    participant4Class: 'participant4Class',
    participant4Accommodation: 'participant4Accommodation',
    participant5Name: 'participant5Name',
    participant5Gender: 'participant5Gender',
    participant5Class: 'participant5Class',
    participant5Accommodation: 'participant5Accommodation',
    participant6Name: 'participant6Name',
    participant6Gender: 'participant6Gender',
    participant6Class: 'participant6Class',
    participant6Accommodation: 'participant6Accommodation',
    additionalRequirements: 'additionalRequirements',
    declaration: 'declaration',
    videoLink: 'videoLink',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkitScalarFieldEnum = (typeof SkitScalarFieldEnum)[keyof typeof SkitScalarFieldEnum]


  export const TeacherModelScalarFieldEnum: {
    id: 'id',
    teacherName: 'teacherName',
    teacherGender: 'teacherGender',
    accommodationRequired: 'accommodationRequired',
    additionalRequirements: 'additionalRequirements',
    declaration: 'declaration',
    writeup: 'writeup',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherModelScalarFieldEnum = (typeof TeacherModelScalarFieldEnum)[keyof typeof TeacherModelScalarFieldEnum]


  export const IPRExhibitionFormScalarFieldEnum: {
    id: 'id',
    hallDimension: 'hallDimension',
    isEnclosedHall: 'isEnclosedHall',
    canBeDarkened: 'canBeDarkened',
    hasCooling: 'hasCooling',
    isGroundFloor: 'isGroundFloor',
    hasStorageSpace: 'hasStorageSpace',
    powerOutlets: 'powerOutlets',
    numTables: 'numTables',
    vrSpace: 'vrSpace',
    hasWifi: 'hasWifi',
    lectureHallArea: 'lectureHallArea',
    seatingCapacity: 'seatingCapacity',
    hasAVFacilities: 'hasAVFacilities',
    distanceFromExhibition: 'distanceFromExhibition',
    accommodationProvided: 'accommodationProvided',
    localTransportation: 'localTransportation',
    secureParkingSpace: 'secureParkingSpace',
    manpowerForLoading: 'manpowerForLoading',
    contactPersonName: 'contactPersonName',
    contactPersonMobile: 'contactPersonMobile',
    contactPersonEmail: 'contactPersonEmail',
    venueLocation: 'venueLocation',
    teacherInvitation: 'teacherInvitation',
    teacherRegistration: 'teacherRegistration',
    providesWritingMaterials: 'providesWritingMaterials',
    providesRefreshments: 'providesRefreshments',
    quizForSchoolStudents: 'quizForSchoolStudents',
    quizTeamSelection: 'quizTeamSelection',
    quizArrangements: 'quizArrangements',
    quizRefreshments: 'quizRefreshments'
  };

  export type IPRExhibitionFormScalarFieldEnum = (typeof IPRExhibitionFormScalarFieldEnum)[keyof typeof IPRExhibitionFormScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type RatingsWhereInput = {
    AND?: RatingsWhereInput | RatingsWhereInput[]
    OR?: RatingsWhereInput[]
    NOT?: RatingsWhereInput | RatingsWhereInput[]
    id?: IntFilter<"Ratings"> | number
    iprRating?: IntFilter<"Ratings"> | number
    fciptRating?: IntFilter<"Ratings"> | number
    knowledge?: IntFilter<"Ratings"> | number
    explanationsIPR?: IntFilter<"Ratings"> | number
    explanationsFCIPT?: IntFilter<"Ratings"> | number
    knowledgeBefore?: IntFilter<"Ratings"> | number
    knowledgeAfter?: IntFilter<"Ratings"> | number
    technicalContents?: IntFilter<"Ratings"> | number
    easeOfUnderstanding?: IntFilter<"Ratings"> | number
    feedbackFormId?: IntFilter<"Ratings"> | number
    feedbackForm?: XOR<FeedbackFormRelationFilter, feedbackFormWhereInput>
  }

  export type RatingsOrderByWithRelationInput = {
    id?: SortOrder
    iprRating?: SortOrder
    fciptRating?: SortOrder
    knowledge?: SortOrder
    explanationsIPR?: SortOrder
    explanationsFCIPT?: SortOrder
    knowledgeBefore?: SortOrder
    knowledgeAfter?: SortOrder
    technicalContents?: SortOrder
    easeOfUnderstanding?: SortOrder
    feedbackFormId?: SortOrder
    feedbackForm?: feedbackFormOrderByWithRelationInput
  }

  export type RatingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    feedbackFormId?: number
    AND?: RatingsWhereInput | RatingsWhereInput[]
    OR?: RatingsWhereInput[]
    NOT?: RatingsWhereInput | RatingsWhereInput[]
    iprRating?: IntFilter<"Ratings"> | number
    fciptRating?: IntFilter<"Ratings"> | number
    knowledge?: IntFilter<"Ratings"> | number
    explanationsIPR?: IntFilter<"Ratings"> | number
    explanationsFCIPT?: IntFilter<"Ratings"> | number
    knowledgeBefore?: IntFilter<"Ratings"> | number
    knowledgeAfter?: IntFilter<"Ratings"> | number
    technicalContents?: IntFilter<"Ratings"> | number
    easeOfUnderstanding?: IntFilter<"Ratings"> | number
    feedbackForm?: XOR<FeedbackFormRelationFilter, feedbackFormWhereInput>
  }, "id" | "feedbackFormId">

  export type RatingsOrderByWithAggregationInput = {
    id?: SortOrder
    iprRating?: SortOrder
    fciptRating?: SortOrder
    knowledge?: SortOrder
    explanationsIPR?: SortOrder
    explanationsFCIPT?: SortOrder
    knowledgeBefore?: SortOrder
    knowledgeAfter?: SortOrder
    technicalContents?: SortOrder
    easeOfUnderstanding?: SortOrder
    feedbackFormId?: SortOrder
    _count?: RatingsCountOrderByAggregateInput
    _avg?: RatingsAvgOrderByAggregateInput
    _max?: RatingsMaxOrderByAggregateInput
    _min?: RatingsMinOrderByAggregateInput
    _sum?: RatingsSumOrderByAggregateInput
  }

  export type RatingsScalarWhereWithAggregatesInput = {
    AND?: RatingsScalarWhereWithAggregatesInput | RatingsScalarWhereWithAggregatesInput[]
    OR?: RatingsScalarWhereWithAggregatesInput[]
    NOT?: RatingsScalarWhereWithAggregatesInput | RatingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ratings"> | number
    iprRating?: IntWithAggregatesFilter<"Ratings"> | number
    fciptRating?: IntWithAggregatesFilter<"Ratings"> | number
    knowledge?: IntWithAggregatesFilter<"Ratings"> | number
    explanationsIPR?: IntWithAggregatesFilter<"Ratings"> | number
    explanationsFCIPT?: IntWithAggregatesFilter<"Ratings"> | number
    knowledgeBefore?: IntWithAggregatesFilter<"Ratings"> | number
    knowledgeAfter?: IntWithAggregatesFilter<"Ratings"> | number
    technicalContents?: IntWithAggregatesFilter<"Ratings"> | number
    easeOfUnderstanding?: IntWithAggregatesFilter<"Ratings"> | number
    feedbackFormId?: IntWithAggregatesFilter<"Ratings"> | number
  }

  export type feedbackFormWhereInput = {
    AND?: feedbackFormWhereInput | feedbackFormWhereInput[]
    OR?: feedbackFormWhereInput[]
    NOT?: feedbackFormWhereInput | feedbackFormWhereInput[]
    id?: IntFilter<"feedbackForm"> | number
    institutionName?: StringFilter<"feedbackForm"> | string
    website?: StringFilter<"feedbackForm"> | string
    visitDate?: DateTimeFilter<"feedbackForm"> | Date | string
    staffName?: StringFilter<"feedbackForm"> | string
    staffEmail?: StringFilter<"feedbackForm"> | string
    staffMobile?: StringFilter<"feedbackForm"> | string
    totalStudents?: IntFilter<"feedbackForm"> | number
    accompanyingStaff?: IntFilter<"feedbackForm"> | number
    sources?: StringNullableListFilter<"feedbackForm">
    campuses?: StringNullableListFilter<"feedbackForm">
    best?: StringNullableFilter<"feedbackForm"> | string | null
    worst?: StringNullableFilter<"feedbackForm"> | string | null
    suggestions?: StringNullableFilter<"feedbackForm"> | string | null
    comments?: StringNullableFilter<"feedbackForm"> | string | null
    createdAt?: DateTimeFilter<"feedbackForm"> | Date | string
    updatedAt?: DateTimeFilter<"feedbackForm"> | Date | string
    ratings?: XOR<RatingsNullableRelationFilter, RatingsWhereInput> | null
  }

  export type feedbackFormOrderByWithRelationInput = {
    id?: SortOrder
    institutionName?: SortOrder
    website?: SortOrder
    visitDate?: SortOrder
    staffName?: SortOrder
    staffEmail?: SortOrder
    staffMobile?: SortOrder
    totalStudents?: SortOrder
    accompanyingStaff?: SortOrder
    sources?: SortOrder
    campuses?: SortOrder
    best?: SortOrderInput | SortOrder
    worst?: SortOrderInput | SortOrder
    suggestions?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ratings?: RatingsOrderByWithRelationInput
  }

  export type feedbackFormWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: feedbackFormWhereInput | feedbackFormWhereInput[]
    OR?: feedbackFormWhereInput[]
    NOT?: feedbackFormWhereInput | feedbackFormWhereInput[]
    institutionName?: StringFilter<"feedbackForm"> | string
    website?: StringFilter<"feedbackForm"> | string
    visitDate?: DateTimeFilter<"feedbackForm"> | Date | string
    staffName?: StringFilter<"feedbackForm"> | string
    staffEmail?: StringFilter<"feedbackForm"> | string
    staffMobile?: StringFilter<"feedbackForm"> | string
    totalStudents?: IntFilter<"feedbackForm"> | number
    accompanyingStaff?: IntFilter<"feedbackForm"> | number
    sources?: StringNullableListFilter<"feedbackForm">
    campuses?: StringNullableListFilter<"feedbackForm">
    best?: StringNullableFilter<"feedbackForm"> | string | null
    worst?: StringNullableFilter<"feedbackForm"> | string | null
    suggestions?: StringNullableFilter<"feedbackForm"> | string | null
    comments?: StringNullableFilter<"feedbackForm"> | string | null
    createdAt?: DateTimeFilter<"feedbackForm"> | Date | string
    updatedAt?: DateTimeFilter<"feedbackForm"> | Date | string
    ratings?: XOR<RatingsNullableRelationFilter, RatingsWhereInput> | null
  }, "id">

  export type feedbackFormOrderByWithAggregationInput = {
    id?: SortOrder
    institutionName?: SortOrder
    website?: SortOrder
    visitDate?: SortOrder
    staffName?: SortOrder
    staffEmail?: SortOrder
    staffMobile?: SortOrder
    totalStudents?: SortOrder
    accompanyingStaff?: SortOrder
    sources?: SortOrder
    campuses?: SortOrder
    best?: SortOrderInput | SortOrder
    worst?: SortOrderInput | SortOrder
    suggestions?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: feedbackFormCountOrderByAggregateInput
    _avg?: feedbackFormAvgOrderByAggregateInput
    _max?: feedbackFormMaxOrderByAggregateInput
    _min?: feedbackFormMinOrderByAggregateInput
    _sum?: feedbackFormSumOrderByAggregateInput
  }

  export type feedbackFormScalarWhereWithAggregatesInput = {
    AND?: feedbackFormScalarWhereWithAggregatesInput | feedbackFormScalarWhereWithAggregatesInput[]
    OR?: feedbackFormScalarWhereWithAggregatesInput[]
    NOT?: feedbackFormScalarWhereWithAggregatesInput | feedbackFormScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"feedbackForm"> | number
    institutionName?: StringWithAggregatesFilter<"feedbackForm"> | string
    website?: StringWithAggregatesFilter<"feedbackForm"> | string
    visitDate?: DateTimeWithAggregatesFilter<"feedbackForm"> | Date | string
    staffName?: StringWithAggregatesFilter<"feedbackForm"> | string
    staffEmail?: StringWithAggregatesFilter<"feedbackForm"> | string
    staffMobile?: StringWithAggregatesFilter<"feedbackForm"> | string
    totalStudents?: IntWithAggregatesFilter<"feedbackForm"> | number
    accompanyingStaff?: IntWithAggregatesFilter<"feedbackForm"> | number
    sources?: StringNullableListFilter<"feedbackForm">
    campuses?: StringNullableListFilter<"feedbackForm">
    best?: StringNullableWithAggregatesFilter<"feedbackForm"> | string | null
    worst?: StringNullableWithAggregatesFilter<"feedbackForm"> | string | null
    suggestions?: StringNullableWithAggregatesFilter<"feedbackForm"> | string | null
    comments?: StringNullableWithAggregatesFilter<"feedbackForm"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"feedbackForm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"feedbackForm"> | Date | string
  }

  export type VisitorWhereInput = {
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    id?: IntFilter<"Visitor"> | number
    institutionName?: StringFilter<"Visitor"> | string
    studentBranch?: StringFilter<"Visitor"> | string
    studentSem?: IntFilter<"Visitor"> | number
    numStudents?: IntFilter<"Visitor"> | number
    numFaculty?: IntFilter<"Visitor"> | number
    name?: StringFilter<"Visitor"> | string
    position?: StringFilter<"Visitor"> | string
    email?: StringFilter<"Visitor"> | string
    mobile?: StringFilter<"Visitor"> | string
    campus?: StringNullableListFilter<"Visitor">
    ipr_time?: StringNullableFilter<"Visitor"> | string | null
    fcipt_time?: StringNullableFilter<"Visitor"> | string | null
    visit_date?: DateTimeFilter<"Visitor"> | Date | string
    visit_time?: StringFilter<"Visitor"> | string
    materials?: StringNullableListFilter<"Visitor">
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeFilter<"Visitor"> | Date | string
  }

  export type VisitorOrderByWithRelationInput = {
    id?: SortOrder
    institutionName?: SortOrder
    studentBranch?: SortOrder
    studentSem?: SortOrder
    numStudents?: SortOrder
    numFaculty?: SortOrder
    name?: SortOrder
    position?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    campus?: SortOrder
    ipr_time?: SortOrderInput | SortOrder
    fcipt_time?: SortOrderInput | SortOrder
    visit_date?: SortOrder
    visit_time?: SortOrder
    materials?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    institutionName?: StringFilter<"Visitor"> | string
    studentBranch?: StringFilter<"Visitor"> | string
    studentSem?: IntFilter<"Visitor"> | number
    numStudents?: IntFilter<"Visitor"> | number
    numFaculty?: IntFilter<"Visitor"> | number
    name?: StringFilter<"Visitor"> | string
    position?: StringFilter<"Visitor"> | string
    email?: StringFilter<"Visitor"> | string
    mobile?: StringFilter<"Visitor"> | string
    campus?: StringNullableListFilter<"Visitor">
    ipr_time?: StringNullableFilter<"Visitor"> | string | null
    fcipt_time?: StringNullableFilter<"Visitor"> | string | null
    visit_date?: DateTimeFilter<"Visitor"> | Date | string
    visit_time?: StringFilter<"Visitor"> | string
    materials?: StringNullableListFilter<"Visitor">
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeFilter<"Visitor"> | Date | string
  }, "id">

  export type VisitorOrderByWithAggregationInput = {
    id?: SortOrder
    institutionName?: SortOrder
    studentBranch?: SortOrder
    studentSem?: SortOrder
    numStudents?: SortOrder
    numFaculty?: SortOrder
    name?: SortOrder
    position?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    campus?: SortOrder
    ipr_time?: SortOrderInput | SortOrder
    fcipt_time?: SortOrderInput | SortOrder
    visit_date?: SortOrder
    visit_time?: SortOrder
    materials?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisitorCountOrderByAggregateInput
    _avg?: VisitorAvgOrderByAggregateInput
    _max?: VisitorMaxOrderByAggregateInput
    _min?: VisitorMinOrderByAggregateInput
    _sum?: VisitorSumOrderByAggregateInput
  }

  export type VisitorScalarWhereWithAggregatesInput = {
    AND?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    OR?: VisitorScalarWhereWithAggregatesInput[]
    NOT?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Visitor"> | number
    institutionName?: StringWithAggregatesFilter<"Visitor"> | string
    studentBranch?: StringWithAggregatesFilter<"Visitor"> | string
    studentSem?: IntWithAggregatesFilter<"Visitor"> | number
    numStudents?: IntWithAggregatesFilter<"Visitor"> | number
    numFaculty?: IntWithAggregatesFilter<"Visitor"> | number
    name?: StringWithAggregatesFilter<"Visitor"> | string
    position?: StringWithAggregatesFilter<"Visitor"> | string
    email?: StringWithAggregatesFilter<"Visitor"> | string
    mobile?: StringWithAggregatesFilter<"Visitor"> | string
    campus?: StringNullableListFilter<"Visitor">
    ipr_time?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    fcipt_time?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    visit_date?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
    visit_time?: StringWithAggregatesFilter<"Visitor"> | string
    materials?: StringNullableListFilter<"Visitor">
    createdAt?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: IntFilter<"School"> | number
    name?: StringFilter<"School"> | string
    address?: StringFilter<"School"> | string
    city?: StringFilter<"School"> | string
    pincode?: StringFilter<"School"> | string
    affiliationNumber?: StringFilter<"School"> | string
    coordinatorTeacherName?: StringFilter<"School"> | string
    coordinatorTeacherMobile?: StringFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    accompanyingTeachers?: AccompanyingTeacherListRelationFilter
    competitions?: CompetitionListRelationFilter
    StudentModel1?: StudentModel1ListRelationFilter
    StudentModel2?: StudentModel2ListRelationFilter
    EloquenceEnglish?: EloquenceEnglishListRelationFilter
    EloquenceHindi?: EloquenceHindiListRelationFilter
    EloquenceGujarati?: EloquenceGujaratiListRelationFilter
    EssayEnglish?: EssayEnglishListRelationFilter
    EssayHindi?: EssayHindiListRelationFilter
    EssayGujarati?: EssayGujaratiListRelationFilter
    Poster?: PosterListRelationFilter
    Skit?: SkitListRelationFilter
    TeacherModel?: TeacherModelListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    pincode?: SortOrder
    affiliationNumber?: SortOrder
    coordinatorTeacherName?: SortOrder
    coordinatorTeacherMobile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accompanyingTeachers?: AccompanyingTeacherOrderByRelationAggregateInput
    competitions?: CompetitionOrderByRelationAggregateInput
    StudentModel1?: StudentModel1OrderByRelationAggregateInput
    StudentModel2?: StudentModel2OrderByRelationAggregateInput
    EloquenceEnglish?: EloquenceEnglishOrderByRelationAggregateInput
    EloquenceHindi?: EloquenceHindiOrderByRelationAggregateInput
    EloquenceGujarati?: EloquenceGujaratiOrderByRelationAggregateInput
    EssayEnglish?: EssayEnglishOrderByRelationAggregateInput
    EssayHindi?: EssayHindiOrderByRelationAggregateInput
    EssayGujarati?: EssayGujaratiOrderByRelationAggregateInput
    Poster?: PosterOrderByRelationAggregateInput
    Skit?: SkitOrderByRelationAggregateInput
    TeacherModel?: TeacherModelOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    name?: StringFilter<"School"> | string
    address?: StringFilter<"School"> | string
    city?: StringFilter<"School"> | string
    pincode?: StringFilter<"School"> | string
    affiliationNumber?: StringFilter<"School"> | string
    coordinatorTeacherName?: StringFilter<"School"> | string
    coordinatorTeacherMobile?: StringFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    accompanyingTeachers?: AccompanyingTeacherListRelationFilter
    competitions?: CompetitionListRelationFilter
    StudentModel1?: StudentModel1ListRelationFilter
    StudentModel2?: StudentModel2ListRelationFilter
    EloquenceEnglish?: EloquenceEnglishListRelationFilter
    EloquenceHindi?: EloquenceHindiListRelationFilter
    EloquenceGujarati?: EloquenceGujaratiListRelationFilter
    EssayEnglish?: EssayEnglishListRelationFilter
    EssayHindi?: EssayHindiListRelationFilter
    EssayGujarati?: EssayGujaratiListRelationFilter
    Poster?: PosterListRelationFilter
    Skit?: SkitListRelationFilter
    TeacherModel?: TeacherModelListRelationFilter
  }, "id">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    pincode?: SortOrder
    affiliationNumber?: SortOrder
    coordinatorTeacherName?: SortOrder
    coordinatorTeacherMobile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _avg?: SchoolAvgOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
    _sum?: SchoolSumOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"School"> | number
    name?: StringWithAggregatesFilter<"School"> | string
    address?: StringWithAggregatesFilter<"School"> | string
    city?: StringWithAggregatesFilter<"School"> | string
    pincode?: StringWithAggregatesFilter<"School"> | string
    affiliationNumber?: StringWithAggregatesFilter<"School"> | string
    coordinatorTeacherName?: StringWithAggregatesFilter<"School"> | string
    coordinatorTeacherMobile?: StringWithAggregatesFilter<"School"> | string
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type AccompanyingTeacherWhereInput = {
    AND?: AccompanyingTeacherWhereInput | AccompanyingTeacherWhereInput[]
    OR?: AccompanyingTeacherWhereInput[]
    NOT?: AccompanyingTeacherWhereInput | AccompanyingTeacherWhereInput[]
    id?: IntFilter<"AccompanyingTeacher"> | number
    name?: StringFilter<"AccompanyingTeacher"> | string
    gender?: StringFilter<"AccompanyingTeacher"> | string
    requiresAccommodation?: BoolFilter<"AccompanyingTeacher"> | boolean
    schoolId?: IntFilter<"AccompanyingTeacher"> | number
    createdAt?: DateTimeFilter<"AccompanyingTeacher"> | Date | string
    updatedAt?: DateTimeFilter<"AccompanyingTeacher"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type AccompanyingTeacherOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    requiresAccommodation?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type AccompanyingTeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccompanyingTeacherWhereInput | AccompanyingTeacherWhereInput[]
    OR?: AccompanyingTeacherWhereInput[]
    NOT?: AccompanyingTeacherWhereInput | AccompanyingTeacherWhereInput[]
    name?: StringFilter<"AccompanyingTeacher"> | string
    gender?: StringFilter<"AccompanyingTeacher"> | string
    requiresAccommodation?: BoolFilter<"AccompanyingTeacher"> | boolean
    schoolId?: IntFilter<"AccompanyingTeacher"> | number
    createdAt?: DateTimeFilter<"AccompanyingTeacher"> | Date | string
    updatedAt?: DateTimeFilter<"AccompanyingTeacher"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type AccompanyingTeacherOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    requiresAccommodation?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccompanyingTeacherCountOrderByAggregateInput
    _avg?: AccompanyingTeacherAvgOrderByAggregateInput
    _max?: AccompanyingTeacherMaxOrderByAggregateInput
    _min?: AccompanyingTeacherMinOrderByAggregateInput
    _sum?: AccompanyingTeacherSumOrderByAggregateInput
  }

  export type AccompanyingTeacherScalarWhereWithAggregatesInput = {
    AND?: AccompanyingTeacherScalarWhereWithAggregatesInput | AccompanyingTeacherScalarWhereWithAggregatesInput[]
    OR?: AccompanyingTeacherScalarWhereWithAggregatesInput[]
    NOT?: AccompanyingTeacherScalarWhereWithAggregatesInput | AccompanyingTeacherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccompanyingTeacher"> | number
    name?: StringWithAggregatesFilter<"AccompanyingTeacher"> | string
    gender?: StringWithAggregatesFilter<"AccompanyingTeacher"> | string
    requiresAccommodation?: BoolWithAggregatesFilter<"AccompanyingTeacher"> | boolean
    schoolId?: IntWithAggregatesFilter<"AccompanyingTeacher"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AccompanyingTeacher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccompanyingTeacher"> | Date | string
  }

  export type CompetitionWhereInput = {
    AND?: CompetitionWhereInput | CompetitionWhereInput[]
    OR?: CompetitionWhereInput[]
    NOT?: CompetitionWhereInput | CompetitionWhereInput[]
    id?: IntFilter<"Competition"> | number
    title?: StringFilter<"Competition"> | string
    schoolId?: IntFilter<"Competition"> | number
    createdAt?: DateTimeFilter<"Competition"> | Date | string
    updatedAt?: DateTimeFilter<"Competition"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type CompetitionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type CompetitionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompetitionWhereInput | CompetitionWhereInput[]
    OR?: CompetitionWhereInput[]
    NOT?: CompetitionWhereInput | CompetitionWhereInput[]
    title?: StringFilter<"Competition"> | string
    schoolId?: IntFilter<"Competition"> | number
    createdAt?: DateTimeFilter<"Competition"> | Date | string
    updatedAt?: DateTimeFilter<"Competition"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type CompetitionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompetitionCountOrderByAggregateInput
    _avg?: CompetitionAvgOrderByAggregateInput
    _max?: CompetitionMaxOrderByAggregateInput
    _min?: CompetitionMinOrderByAggregateInput
    _sum?: CompetitionSumOrderByAggregateInput
  }

  export type CompetitionScalarWhereWithAggregatesInput = {
    AND?: CompetitionScalarWhereWithAggregatesInput | CompetitionScalarWhereWithAggregatesInput[]
    OR?: CompetitionScalarWhereWithAggregatesInput[]
    NOT?: CompetitionScalarWhereWithAggregatesInput | CompetitionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Competition"> | number
    title?: StringWithAggregatesFilter<"Competition"> | string
    schoolId?: IntWithAggregatesFilter<"Competition"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Competition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Competition"> | Date | string
  }

  export type StudentModel1WhereInput = {
    AND?: StudentModel1WhereInput | StudentModel1WhereInput[]
    OR?: StudentModel1WhereInput[]
    NOT?: StudentModel1WhereInput | StudentModel1WhereInput[]
    id?: IntFilter<"StudentModel1"> | number
    participant1Name?: StringFilter<"StudentModel1"> | string
    participant1Gender?: StringFilter<"StudentModel1"> | string
    participant1Class?: StringFilter<"StudentModel1"> | string
    participant1Accommodation?: StringFilter<"StudentModel1"> | string
    participant2Name?: StringFilter<"StudentModel1"> | string
    participant2Gender?: StringFilter<"StudentModel1"> | string
    participant2Class?: StringFilter<"StudentModel1"> | string
    participant2Accommodation?: StringFilter<"StudentModel1"> | string
    additionalRequirements?: StringNullableFilter<"StudentModel1"> | string | null
    declaration?: BoolFilter<"StudentModel1"> | boolean
    writeup?: StringFilter<"StudentModel1"> | string
    schoolId?: IntFilter<"StudentModel1"> | number
    createdAt?: DateTimeFilter<"StudentModel1"> | Date | string
    updatedAt?: DateTimeFilter<"StudentModel1"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type StudentModel1OrderByWithRelationInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    additionalRequirements?: SortOrderInput | SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type StudentModel1WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentModel1WhereInput | StudentModel1WhereInput[]
    OR?: StudentModel1WhereInput[]
    NOT?: StudentModel1WhereInput | StudentModel1WhereInput[]
    participant1Name?: StringFilter<"StudentModel1"> | string
    participant1Gender?: StringFilter<"StudentModel1"> | string
    participant1Class?: StringFilter<"StudentModel1"> | string
    participant1Accommodation?: StringFilter<"StudentModel1"> | string
    participant2Name?: StringFilter<"StudentModel1"> | string
    participant2Gender?: StringFilter<"StudentModel1"> | string
    participant2Class?: StringFilter<"StudentModel1"> | string
    participant2Accommodation?: StringFilter<"StudentModel1"> | string
    additionalRequirements?: StringNullableFilter<"StudentModel1"> | string | null
    declaration?: BoolFilter<"StudentModel1"> | boolean
    writeup?: StringFilter<"StudentModel1"> | string
    schoolId?: IntFilter<"StudentModel1"> | number
    createdAt?: DateTimeFilter<"StudentModel1"> | Date | string
    updatedAt?: DateTimeFilter<"StudentModel1"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type StudentModel1OrderByWithAggregationInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    additionalRequirements?: SortOrderInput | SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentModel1CountOrderByAggregateInput
    _avg?: StudentModel1AvgOrderByAggregateInput
    _max?: StudentModel1MaxOrderByAggregateInput
    _min?: StudentModel1MinOrderByAggregateInput
    _sum?: StudentModel1SumOrderByAggregateInput
  }

  export type StudentModel1ScalarWhereWithAggregatesInput = {
    AND?: StudentModel1ScalarWhereWithAggregatesInput | StudentModel1ScalarWhereWithAggregatesInput[]
    OR?: StudentModel1ScalarWhereWithAggregatesInput[]
    NOT?: StudentModel1ScalarWhereWithAggregatesInput | StudentModel1ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentModel1"> | number
    participant1Name?: StringWithAggregatesFilter<"StudentModel1"> | string
    participant1Gender?: StringWithAggregatesFilter<"StudentModel1"> | string
    participant1Class?: StringWithAggregatesFilter<"StudentModel1"> | string
    participant1Accommodation?: StringWithAggregatesFilter<"StudentModel1"> | string
    participant2Name?: StringWithAggregatesFilter<"StudentModel1"> | string
    participant2Gender?: StringWithAggregatesFilter<"StudentModel1"> | string
    participant2Class?: StringWithAggregatesFilter<"StudentModel1"> | string
    participant2Accommodation?: StringWithAggregatesFilter<"StudentModel1"> | string
    additionalRequirements?: StringNullableWithAggregatesFilter<"StudentModel1"> | string | null
    declaration?: BoolWithAggregatesFilter<"StudentModel1"> | boolean
    writeup?: StringWithAggregatesFilter<"StudentModel1"> | string
    schoolId?: IntWithAggregatesFilter<"StudentModel1"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StudentModel1"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentModel1"> | Date | string
  }

  export type StudentModel2WhereInput = {
    AND?: StudentModel2WhereInput | StudentModel2WhereInput[]
    OR?: StudentModel2WhereInput[]
    NOT?: StudentModel2WhereInput | StudentModel2WhereInput[]
    id?: IntFilter<"StudentModel2"> | number
    participant1Name?: StringFilter<"StudentModel2"> | string
    participant1Gender?: StringFilter<"StudentModel2"> | string
    participant1Class?: StringFilter<"StudentModel2"> | string
    participant1Accommodation?: StringFilter<"StudentModel2"> | string
    participant2Name?: StringFilter<"StudentModel2"> | string
    participant2Gender?: StringFilter<"StudentModel2"> | string
    participant2Class?: StringFilter<"StudentModel2"> | string
    participant2Accommodation?: StringFilter<"StudentModel2"> | string
    additionalRequirements?: StringNullableFilter<"StudentModel2"> | string | null
    declaration?: BoolFilter<"StudentModel2"> | boolean
    writeup?: StringFilter<"StudentModel2"> | string
    schoolId?: IntFilter<"StudentModel2"> | number
    createdAt?: DateTimeFilter<"StudentModel2"> | Date | string
    updatedAt?: DateTimeFilter<"StudentModel2"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type StudentModel2OrderByWithRelationInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    additionalRequirements?: SortOrderInput | SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type StudentModel2WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentModel2WhereInput | StudentModel2WhereInput[]
    OR?: StudentModel2WhereInput[]
    NOT?: StudentModel2WhereInput | StudentModel2WhereInput[]
    participant1Name?: StringFilter<"StudentModel2"> | string
    participant1Gender?: StringFilter<"StudentModel2"> | string
    participant1Class?: StringFilter<"StudentModel2"> | string
    participant1Accommodation?: StringFilter<"StudentModel2"> | string
    participant2Name?: StringFilter<"StudentModel2"> | string
    participant2Gender?: StringFilter<"StudentModel2"> | string
    participant2Class?: StringFilter<"StudentModel2"> | string
    participant2Accommodation?: StringFilter<"StudentModel2"> | string
    additionalRequirements?: StringNullableFilter<"StudentModel2"> | string | null
    declaration?: BoolFilter<"StudentModel2"> | boolean
    writeup?: StringFilter<"StudentModel2"> | string
    schoolId?: IntFilter<"StudentModel2"> | number
    createdAt?: DateTimeFilter<"StudentModel2"> | Date | string
    updatedAt?: DateTimeFilter<"StudentModel2"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type StudentModel2OrderByWithAggregationInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    additionalRequirements?: SortOrderInput | SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentModel2CountOrderByAggregateInput
    _avg?: StudentModel2AvgOrderByAggregateInput
    _max?: StudentModel2MaxOrderByAggregateInput
    _min?: StudentModel2MinOrderByAggregateInput
    _sum?: StudentModel2SumOrderByAggregateInput
  }

  export type StudentModel2ScalarWhereWithAggregatesInput = {
    AND?: StudentModel2ScalarWhereWithAggregatesInput | StudentModel2ScalarWhereWithAggregatesInput[]
    OR?: StudentModel2ScalarWhereWithAggregatesInput[]
    NOT?: StudentModel2ScalarWhereWithAggregatesInput | StudentModel2ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentModel2"> | number
    participant1Name?: StringWithAggregatesFilter<"StudentModel2"> | string
    participant1Gender?: StringWithAggregatesFilter<"StudentModel2"> | string
    participant1Class?: StringWithAggregatesFilter<"StudentModel2"> | string
    participant1Accommodation?: StringWithAggregatesFilter<"StudentModel2"> | string
    participant2Name?: StringWithAggregatesFilter<"StudentModel2"> | string
    participant2Gender?: StringWithAggregatesFilter<"StudentModel2"> | string
    participant2Class?: StringWithAggregatesFilter<"StudentModel2"> | string
    participant2Accommodation?: StringWithAggregatesFilter<"StudentModel2"> | string
    additionalRequirements?: StringNullableWithAggregatesFilter<"StudentModel2"> | string | null
    declaration?: BoolWithAggregatesFilter<"StudentModel2"> | boolean
    writeup?: StringWithAggregatesFilter<"StudentModel2"> | string
    schoolId?: IntWithAggregatesFilter<"StudentModel2"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StudentModel2"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentModel2"> | Date | string
  }

  export type EloquenceEnglishWhereInput = {
    AND?: EloquenceEnglishWhereInput | EloquenceEnglishWhereInput[]
    OR?: EloquenceEnglishWhereInput[]
    NOT?: EloquenceEnglishWhereInput | EloquenceEnglishWhereInput[]
    id?: IntFilter<"EloquenceEnglish"> | number
    participantName?: StringFilter<"EloquenceEnglish"> | string
    participantGender?: StringFilter<"EloquenceEnglish"> | string
    participantClass?: StringFilter<"EloquenceEnglish"> | string
    accommodationRequired?: StringFilter<"EloquenceEnglish"> | string
    declaration?: BoolFilter<"EloquenceEnglish"> | boolean
    schoolId?: IntFilter<"EloquenceEnglish"> | number
    createdAt?: DateTimeFilter<"EloquenceEnglish"> | Date | string
    updatedAt?: DateTimeFilter<"EloquenceEnglish"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type EloquenceEnglishOrderByWithRelationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type EloquenceEnglishWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EloquenceEnglishWhereInput | EloquenceEnglishWhereInput[]
    OR?: EloquenceEnglishWhereInput[]
    NOT?: EloquenceEnglishWhereInput | EloquenceEnglishWhereInput[]
    participantName?: StringFilter<"EloquenceEnglish"> | string
    participantGender?: StringFilter<"EloquenceEnglish"> | string
    participantClass?: StringFilter<"EloquenceEnglish"> | string
    accommodationRequired?: StringFilter<"EloquenceEnglish"> | string
    declaration?: BoolFilter<"EloquenceEnglish"> | boolean
    schoolId?: IntFilter<"EloquenceEnglish"> | number
    createdAt?: DateTimeFilter<"EloquenceEnglish"> | Date | string
    updatedAt?: DateTimeFilter<"EloquenceEnglish"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type EloquenceEnglishOrderByWithAggregationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EloquenceEnglishCountOrderByAggregateInput
    _avg?: EloquenceEnglishAvgOrderByAggregateInput
    _max?: EloquenceEnglishMaxOrderByAggregateInput
    _min?: EloquenceEnglishMinOrderByAggregateInput
    _sum?: EloquenceEnglishSumOrderByAggregateInput
  }

  export type EloquenceEnglishScalarWhereWithAggregatesInput = {
    AND?: EloquenceEnglishScalarWhereWithAggregatesInput | EloquenceEnglishScalarWhereWithAggregatesInput[]
    OR?: EloquenceEnglishScalarWhereWithAggregatesInput[]
    NOT?: EloquenceEnglishScalarWhereWithAggregatesInput | EloquenceEnglishScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EloquenceEnglish"> | number
    participantName?: StringWithAggregatesFilter<"EloquenceEnglish"> | string
    participantGender?: StringWithAggregatesFilter<"EloquenceEnglish"> | string
    participantClass?: StringWithAggregatesFilter<"EloquenceEnglish"> | string
    accommodationRequired?: StringWithAggregatesFilter<"EloquenceEnglish"> | string
    declaration?: BoolWithAggregatesFilter<"EloquenceEnglish"> | boolean
    schoolId?: IntWithAggregatesFilter<"EloquenceEnglish"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EloquenceEnglish"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EloquenceEnglish"> | Date | string
  }

  export type EloquenceHindiWhereInput = {
    AND?: EloquenceHindiWhereInput | EloquenceHindiWhereInput[]
    OR?: EloquenceHindiWhereInput[]
    NOT?: EloquenceHindiWhereInput | EloquenceHindiWhereInput[]
    id?: IntFilter<"EloquenceHindi"> | number
    participantName?: StringFilter<"EloquenceHindi"> | string
    participantGender?: StringFilter<"EloquenceHindi"> | string
    participantClass?: StringFilter<"EloquenceHindi"> | string
    accommodationRequired?: StringFilter<"EloquenceHindi"> | string
    declaration?: BoolFilter<"EloquenceHindi"> | boolean
    schoolId?: IntFilter<"EloquenceHindi"> | number
    createdAt?: DateTimeFilter<"EloquenceHindi"> | Date | string
    updatedAt?: DateTimeFilter<"EloquenceHindi"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type EloquenceHindiOrderByWithRelationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type EloquenceHindiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EloquenceHindiWhereInput | EloquenceHindiWhereInput[]
    OR?: EloquenceHindiWhereInput[]
    NOT?: EloquenceHindiWhereInput | EloquenceHindiWhereInput[]
    participantName?: StringFilter<"EloquenceHindi"> | string
    participantGender?: StringFilter<"EloquenceHindi"> | string
    participantClass?: StringFilter<"EloquenceHindi"> | string
    accommodationRequired?: StringFilter<"EloquenceHindi"> | string
    declaration?: BoolFilter<"EloquenceHindi"> | boolean
    schoolId?: IntFilter<"EloquenceHindi"> | number
    createdAt?: DateTimeFilter<"EloquenceHindi"> | Date | string
    updatedAt?: DateTimeFilter<"EloquenceHindi"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type EloquenceHindiOrderByWithAggregationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EloquenceHindiCountOrderByAggregateInput
    _avg?: EloquenceHindiAvgOrderByAggregateInput
    _max?: EloquenceHindiMaxOrderByAggregateInput
    _min?: EloquenceHindiMinOrderByAggregateInput
    _sum?: EloquenceHindiSumOrderByAggregateInput
  }

  export type EloquenceHindiScalarWhereWithAggregatesInput = {
    AND?: EloquenceHindiScalarWhereWithAggregatesInput | EloquenceHindiScalarWhereWithAggregatesInput[]
    OR?: EloquenceHindiScalarWhereWithAggregatesInput[]
    NOT?: EloquenceHindiScalarWhereWithAggregatesInput | EloquenceHindiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EloquenceHindi"> | number
    participantName?: StringWithAggregatesFilter<"EloquenceHindi"> | string
    participantGender?: StringWithAggregatesFilter<"EloquenceHindi"> | string
    participantClass?: StringWithAggregatesFilter<"EloquenceHindi"> | string
    accommodationRequired?: StringWithAggregatesFilter<"EloquenceHindi"> | string
    declaration?: BoolWithAggregatesFilter<"EloquenceHindi"> | boolean
    schoolId?: IntWithAggregatesFilter<"EloquenceHindi"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EloquenceHindi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EloquenceHindi"> | Date | string
  }

  export type EloquenceGujaratiWhereInput = {
    AND?: EloquenceGujaratiWhereInput | EloquenceGujaratiWhereInput[]
    OR?: EloquenceGujaratiWhereInput[]
    NOT?: EloquenceGujaratiWhereInput | EloquenceGujaratiWhereInput[]
    id?: IntFilter<"EloquenceGujarati"> | number
    participantName?: StringFilter<"EloquenceGujarati"> | string
    participantGender?: StringFilter<"EloquenceGujarati"> | string
    participantClass?: StringFilter<"EloquenceGujarati"> | string
    accommodationRequired?: StringFilter<"EloquenceGujarati"> | string
    declaration?: BoolFilter<"EloquenceGujarati"> | boolean
    schoolId?: IntFilter<"EloquenceGujarati"> | number
    createdAt?: DateTimeFilter<"EloquenceGujarati"> | Date | string
    updatedAt?: DateTimeFilter<"EloquenceGujarati"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type EloquenceGujaratiOrderByWithRelationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type EloquenceGujaratiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EloquenceGujaratiWhereInput | EloquenceGujaratiWhereInput[]
    OR?: EloquenceGujaratiWhereInput[]
    NOT?: EloquenceGujaratiWhereInput | EloquenceGujaratiWhereInput[]
    participantName?: StringFilter<"EloquenceGujarati"> | string
    participantGender?: StringFilter<"EloquenceGujarati"> | string
    participantClass?: StringFilter<"EloquenceGujarati"> | string
    accommodationRequired?: StringFilter<"EloquenceGujarati"> | string
    declaration?: BoolFilter<"EloquenceGujarati"> | boolean
    schoolId?: IntFilter<"EloquenceGujarati"> | number
    createdAt?: DateTimeFilter<"EloquenceGujarati"> | Date | string
    updatedAt?: DateTimeFilter<"EloquenceGujarati"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type EloquenceGujaratiOrderByWithAggregationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EloquenceGujaratiCountOrderByAggregateInput
    _avg?: EloquenceGujaratiAvgOrderByAggregateInput
    _max?: EloquenceGujaratiMaxOrderByAggregateInput
    _min?: EloquenceGujaratiMinOrderByAggregateInput
    _sum?: EloquenceGujaratiSumOrderByAggregateInput
  }

  export type EloquenceGujaratiScalarWhereWithAggregatesInput = {
    AND?: EloquenceGujaratiScalarWhereWithAggregatesInput | EloquenceGujaratiScalarWhereWithAggregatesInput[]
    OR?: EloquenceGujaratiScalarWhereWithAggregatesInput[]
    NOT?: EloquenceGujaratiScalarWhereWithAggregatesInput | EloquenceGujaratiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EloquenceGujarati"> | number
    participantName?: StringWithAggregatesFilter<"EloquenceGujarati"> | string
    participantGender?: StringWithAggregatesFilter<"EloquenceGujarati"> | string
    participantClass?: StringWithAggregatesFilter<"EloquenceGujarati"> | string
    accommodationRequired?: StringWithAggregatesFilter<"EloquenceGujarati"> | string
    declaration?: BoolWithAggregatesFilter<"EloquenceGujarati"> | boolean
    schoolId?: IntWithAggregatesFilter<"EloquenceGujarati"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EloquenceGujarati"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EloquenceGujarati"> | Date | string
  }

  export type EssayEnglishWhereInput = {
    AND?: EssayEnglishWhereInput | EssayEnglishWhereInput[]
    OR?: EssayEnglishWhereInput[]
    NOT?: EssayEnglishWhereInput | EssayEnglishWhereInput[]
    id?: IntFilter<"EssayEnglish"> | number
    participantName?: StringFilter<"EssayEnglish"> | string
    participantGender?: StringFilter<"EssayEnglish"> | string
    participantClass?: StringFilter<"EssayEnglish"> | string
    accommodationRequired?: StringFilter<"EssayEnglish"> | string
    essayFileUrl?: StringFilter<"EssayEnglish"> | string
    declaration?: BoolFilter<"EssayEnglish"> | boolean
    schoolId?: IntFilter<"EssayEnglish"> | number
    createdAt?: DateTimeFilter<"EssayEnglish"> | Date | string
    updatedAt?: DateTimeFilter<"EssayEnglish"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type EssayEnglishOrderByWithRelationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type EssayEnglishWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EssayEnglishWhereInput | EssayEnglishWhereInput[]
    OR?: EssayEnglishWhereInput[]
    NOT?: EssayEnglishWhereInput | EssayEnglishWhereInput[]
    participantName?: StringFilter<"EssayEnglish"> | string
    participantGender?: StringFilter<"EssayEnglish"> | string
    participantClass?: StringFilter<"EssayEnglish"> | string
    accommodationRequired?: StringFilter<"EssayEnglish"> | string
    essayFileUrl?: StringFilter<"EssayEnglish"> | string
    declaration?: BoolFilter<"EssayEnglish"> | boolean
    schoolId?: IntFilter<"EssayEnglish"> | number
    createdAt?: DateTimeFilter<"EssayEnglish"> | Date | string
    updatedAt?: DateTimeFilter<"EssayEnglish"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type EssayEnglishOrderByWithAggregationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EssayEnglishCountOrderByAggregateInput
    _avg?: EssayEnglishAvgOrderByAggregateInput
    _max?: EssayEnglishMaxOrderByAggregateInput
    _min?: EssayEnglishMinOrderByAggregateInput
    _sum?: EssayEnglishSumOrderByAggregateInput
  }

  export type EssayEnglishScalarWhereWithAggregatesInput = {
    AND?: EssayEnglishScalarWhereWithAggregatesInput | EssayEnglishScalarWhereWithAggregatesInput[]
    OR?: EssayEnglishScalarWhereWithAggregatesInput[]
    NOT?: EssayEnglishScalarWhereWithAggregatesInput | EssayEnglishScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EssayEnglish"> | number
    participantName?: StringWithAggregatesFilter<"EssayEnglish"> | string
    participantGender?: StringWithAggregatesFilter<"EssayEnglish"> | string
    participantClass?: StringWithAggregatesFilter<"EssayEnglish"> | string
    accommodationRequired?: StringWithAggregatesFilter<"EssayEnglish"> | string
    essayFileUrl?: StringWithAggregatesFilter<"EssayEnglish"> | string
    declaration?: BoolWithAggregatesFilter<"EssayEnglish"> | boolean
    schoolId?: IntWithAggregatesFilter<"EssayEnglish"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EssayEnglish"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EssayEnglish"> | Date | string
  }

  export type EssayHindiWhereInput = {
    AND?: EssayHindiWhereInput | EssayHindiWhereInput[]
    OR?: EssayHindiWhereInput[]
    NOT?: EssayHindiWhereInput | EssayHindiWhereInput[]
    id?: IntFilter<"EssayHindi"> | number
    participantName?: StringFilter<"EssayHindi"> | string
    participantGender?: StringFilter<"EssayHindi"> | string
    participantClass?: StringFilter<"EssayHindi"> | string
    accommodationRequired?: StringFilter<"EssayHindi"> | string
    essayFileUrl?: StringFilter<"EssayHindi"> | string
    declaration?: BoolFilter<"EssayHindi"> | boolean
    schoolId?: IntFilter<"EssayHindi"> | number
    createdAt?: DateTimeFilter<"EssayHindi"> | Date | string
    updatedAt?: DateTimeFilter<"EssayHindi"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type EssayHindiOrderByWithRelationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type EssayHindiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EssayHindiWhereInput | EssayHindiWhereInput[]
    OR?: EssayHindiWhereInput[]
    NOT?: EssayHindiWhereInput | EssayHindiWhereInput[]
    participantName?: StringFilter<"EssayHindi"> | string
    participantGender?: StringFilter<"EssayHindi"> | string
    participantClass?: StringFilter<"EssayHindi"> | string
    accommodationRequired?: StringFilter<"EssayHindi"> | string
    essayFileUrl?: StringFilter<"EssayHindi"> | string
    declaration?: BoolFilter<"EssayHindi"> | boolean
    schoolId?: IntFilter<"EssayHindi"> | number
    createdAt?: DateTimeFilter<"EssayHindi"> | Date | string
    updatedAt?: DateTimeFilter<"EssayHindi"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type EssayHindiOrderByWithAggregationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EssayHindiCountOrderByAggregateInput
    _avg?: EssayHindiAvgOrderByAggregateInput
    _max?: EssayHindiMaxOrderByAggregateInput
    _min?: EssayHindiMinOrderByAggregateInput
    _sum?: EssayHindiSumOrderByAggregateInput
  }

  export type EssayHindiScalarWhereWithAggregatesInput = {
    AND?: EssayHindiScalarWhereWithAggregatesInput | EssayHindiScalarWhereWithAggregatesInput[]
    OR?: EssayHindiScalarWhereWithAggregatesInput[]
    NOT?: EssayHindiScalarWhereWithAggregatesInput | EssayHindiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EssayHindi"> | number
    participantName?: StringWithAggregatesFilter<"EssayHindi"> | string
    participantGender?: StringWithAggregatesFilter<"EssayHindi"> | string
    participantClass?: StringWithAggregatesFilter<"EssayHindi"> | string
    accommodationRequired?: StringWithAggregatesFilter<"EssayHindi"> | string
    essayFileUrl?: StringWithAggregatesFilter<"EssayHindi"> | string
    declaration?: BoolWithAggregatesFilter<"EssayHindi"> | boolean
    schoolId?: IntWithAggregatesFilter<"EssayHindi"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EssayHindi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EssayHindi"> | Date | string
  }

  export type EssayGujaratiWhereInput = {
    AND?: EssayGujaratiWhereInput | EssayGujaratiWhereInput[]
    OR?: EssayGujaratiWhereInput[]
    NOT?: EssayGujaratiWhereInput | EssayGujaratiWhereInput[]
    id?: IntFilter<"EssayGujarati"> | number
    participantName?: StringFilter<"EssayGujarati"> | string
    participantGender?: StringFilter<"EssayGujarati"> | string
    participantClass?: StringFilter<"EssayGujarati"> | string
    accommodationRequired?: StringFilter<"EssayGujarati"> | string
    essayFileUrl?: StringFilter<"EssayGujarati"> | string
    declaration?: BoolFilter<"EssayGujarati"> | boolean
    schoolId?: IntFilter<"EssayGujarati"> | number
    createdAt?: DateTimeFilter<"EssayGujarati"> | Date | string
    updatedAt?: DateTimeFilter<"EssayGujarati"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type EssayGujaratiOrderByWithRelationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type EssayGujaratiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EssayGujaratiWhereInput | EssayGujaratiWhereInput[]
    OR?: EssayGujaratiWhereInput[]
    NOT?: EssayGujaratiWhereInput | EssayGujaratiWhereInput[]
    participantName?: StringFilter<"EssayGujarati"> | string
    participantGender?: StringFilter<"EssayGujarati"> | string
    participantClass?: StringFilter<"EssayGujarati"> | string
    accommodationRequired?: StringFilter<"EssayGujarati"> | string
    essayFileUrl?: StringFilter<"EssayGujarati"> | string
    declaration?: BoolFilter<"EssayGujarati"> | boolean
    schoolId?: IntFilter<"EssayGujarati"> | number
    createdAt?: DateTimeFilter<"EssayGujarati"> | Date | string
    updatedAt?: DateTimeFilter<"EssayGujarati"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type EssayGujaratiOrderByWithAggregationInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EssayGujaratiCountOrderByAggregateInput
    _avg?: EssayGujaratiAvgOrderByAggregateInput
    _max?: EssayGujaratiMaxOrderByAggregateInput
    _min?: EssayGujaratiMinOrderByAggregateInput
    _sum?: EssayGujaratiSumOrderByAggregateInput
  }

  export type EssayGujaratiScalarWhereWithAggregatesInput = {
    AND?: EssayGujaratiScalarWhereWithAggregatesInput | EssayGujaratiScalarWhereWithAggregatesInput[]
    OR?: EssayGujaratiScalarWhereWithAggregatesInput[]
    NOT?: EssayGujaratiScalarWhereWithAggregatesInput | EssayGujaratiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EssayGujarati"> | number
    participantName?: StringWithAggregatesFilter<"EssayGujarati"> | string
    participantGender?: StringWithAggregatesFilter<"EssayGujarati"> | string
    participantClass?: StringWithAggregatesFilter<"EssayGujarati"> | string
    accommodationRequired?: StringWithAggregatesFilter<"EssayGujarati"> | string
    essayFileUrl?: StringWithAggregatesFilter<"EssayGujarati"> | string
    declaration?: BoolWithAggregatesFilter<"EssayGujarati"> | boolean
    schoolId?: IntWithAggregatesFilter<"EssayGujarati"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EssayGujarati"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EssayGujarati"> | Date | string
  }

  export type PosterWhereInput = {
    AND?: PosterWhereInput | PosterWhereInput[]
    OR?: PosterWhereInput[]
    NOT?: PosterWhereInput | PosterWhereInput[]
    id?: IntFilter<"Poster"> | number
    participant1Name?: StringFilter<"Poster"> | string
    participant1Gender?: StringFilter<"Poster"> | string
    participant1Class?: StringFilter<"Poster"> | string
    participant1Accommodation?: StringFilter<"Poster"> | string
    participant1Declaration?: BoolFilter<"Poster"> | boolean
    participant2Name?: StringNullableFilter<"Poster"> | string | null
    participant2Gender?: StringNullableFilter<"Poster"> | string | null
    participant2Class?: StringNullableFilter<"Poster"> | string | null
    participant2Accommodation?: StringNullableFilter<"Poster"> | string | null
    participant2Declaration?: BoolNullableFilter<"Poster"> | boolean | null
    schoolId?: IntFilter<"Poster"> | number
    createdAt?: DateTimeFilter<"Poster"> | Date | string
    updatedAt?: DateTimeFilter<"Poster"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type PosterOrderByWithRelationInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant1Declaration?: SortOrder
    participant2Name?: SortOrderInput | SortOrder
    participant2Gender?: SortOrderInput | SortOrder
    participant2Class?: SortOrderInput | SortOrder
    participant2Accommodation?: SortOrderInput | SortOrder
    participant2Declaration?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type PosterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PosterWhereInput | PosterWhereInput[]
    OR?: PosterWhereInput[]
    NOT?: PosterWhereInput | PosterWhereInput[]
    participant1Name?: StringFilter<"Poster"> | string
    participant1Gender?: StringFilter<"Poster"> | string
    participant1Class?: StringFilter<"Poster"> | string
    participant1Accommodation?: StringFilter<"Poster"> | string
    participant1Declaration?: BoolFilter<"Poster"> | boolean
    participant2Name?: StringNullableFilter<"Poster"> | string | null
    participant2Gender?: StringNullableFilter<"Poster"> | string | null
    participant2Class?: StringNullableFilter<"Poster"> | string | null
    participant2Accommodation?: StringNullableFilter<"Poster"> | string | null
    participant2Declaration?: BoolNullableFilter<"Poster"> | boolean | null
    schoolId?: IntFilter<"Poster"> | number
    createdAt?: DateTimeFilter<"Poster"> | Date | string
    updatedAt?: DateTimeFilter<"Poster"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type PosterOrderByWithAggregationInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant1Declaration?: SortOrder
    participant2Name?: SortOrderInput | SortOrder
    participant2Gender?: SortOrderInput | SortOrder
    participant2Class?: SortOrderInput | SortOrder
    participant2Accommodation?: SortOrderInput | SortOrder
    participant2Declaration?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PosterCountOrderByAggregateInput
    _avg?: PosterAvgOrderByAggregateInput
    _max?: PosterMaxOrderByAggregateInput
    _min?: PosterMinOrderByAggregateInput
    _sum?: PosterSumOrderByAggregateInput
  }

  export type PosterScalarWhereWithAggregatesInput = {
    AND?: PosterScalarWhereWithAggregatesInput | PosterScalarWhereWithAggregatesInput[]
    OR?: PosterScalarWhereWithAggregatesInput[]
    NOT?: PosterScalarWhereWithAggregatesInput | PosterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Poster"> | number
    participant1Name?: StringWithAggregatesFilter<"Poster"> | string
    participant1Gender?: StringWithAggregatesFilter<"Poster"> | string
    participant1Class?: StringWithAggregatesFilter<"Poster"> | string
    participant1Accommodation?: StringWithAggregatesFilter<"Poster"> | string
    participant1Declaration?: BoolWithAggregatesFilter<"Poster"> | boolean
    participant2Name?: StringNullableWithAggregatesFilter<"Poster"> | string | null
    participant2Gender?: StringNullableWithAggregatesFilter<"Poster"> | string | null
    participant2Class?: StringNullableWithAggregatesFilter<"Poster"> | string | null
    participant2Accommodation?: StringNullableWithAggregatesFilter<"Poster"> | string | null
    participant2Declaration?: BoolNullableWithAggregatesFilter<"Poster"> | boolean | null
    schoolId?: IntWithAggregatesFilter<"Poster"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Poster"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Poster"> | Date | string
  }

  export type SkitWhereInput = {
    AND?: SkitWhereInput | SkitWhereInput[]
    OR?: SkitWhereInput[]
    NOT?: SkitWhereInput | SkitWhereInput[]
    id?: IntFilter<"Skit"> | number
    participant1Name?: StringFilter<"Skit"> | string
    participant1Gender?: StringFilter<"Skit"> | string
    participant1Class?: StringFilter<"Skit"> | string
    participant1Accommodation?: StringFilter<"Skit"> | string
    participant2Name?: StringNullableFilter<"Skit"> | string | null
    participant2Gender?: StringNullableFilter<"Skit"> | string | null
    participant2Class?: StringNullableFilter<"Skit"> | string | null
    participant2Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant3Name?: StringNullableFilter<"Skit"> | string | null
    participant3Gender?: StringNullableFilter<"Skit"> | string | null
    participant3Class?: StringNullableFilter<"Skit"> | string | null
    participant3Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant4Name?: StringNullableFilter<"Skit"> | string | null
    participant4Gender?: StringNullableFilter<"Skit"> | string | null
    participant4Class?: StringNullableFilter<"Skit"> | string | null
    participant4Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant5Name?: StringNullableFilter<"Skit"> | string | null
    participant5Gender?: StringNullableFilter<"Skit"> | string | null
    participant5Class?: StringNullableFilter<"Skit"> | string | null
    participant5Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant6Name?: StringNullableFilter<"Skit"> | string | null
    participant6Gender?: StringNullableFilter<"Skit"> | string | null
    participant6Class?: StringNullableFilter<"Skit"> | string | null
    participant6Accommodation?: StringNullableFilter<"Skit"> | string | null
    additionalRequirements?: StringNullableFilter<"Skit"> | string | null
    declaration?: BoolFilter<"Skit"> | boolean
    videoLink?: StringFilter<"Skit"> | string
    schoolId?: IntFilter<"Skit"> | number
    createdAt?: DateTimeFilter<"Skit"> | Date | string
    updatedAt?: DateTimeFilter<"Skit"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type SkitOrderByWithRelationInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrderInput | SortOrder
    participant2Gender?: SortOrderInput | SortOrder
    participant2Class?: SortOrderInput | SortOrder
    participant2Accommodation?: SortOrderInput | SortOrder
    participant3Name?: SortOrderInput | SortOrder
    participant3Gender?: SortOrderInput | SortOrder
    participant3Class?: SortOrderInput | SortOrder
    participant3Accommodation?: SortOrderInput | SortOrder
    participant4Name?: SortOrderInput | SortOrder
    participant4Gender?: SortOrderInput | SortOrder
    participant4Class?: SortOrderInput | SortOrder
    participant4Accommodation?: SortOrderInput | SortOrder
    participant5Name?: SortOrderInput | SortOrder
    participant5Gender?: SortOrderInput | SortOrder
    participant5Class?: SortOrderInput | SortOrder
    participant5Accommodation?: SortOrderInput | SortOrder
    participant6Name?: SortOrderInput | SortOrder
    participant6Gender?: SortOrderInput | SortOrder
    participant6Class?: SortOrderInput | SortOrder
    participant6Accommodation?: SortOrderInput | SortOrder
    additionalRequirements?: SortOrderInput | SortOrder
    declaration?: SortOrder
    videoLink?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type SkitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SkitWhereInput | SkitWhereInput[]
    OR?: SkitWhereInput[]
    NOT?: SkitWhereInput | SkitWhereInput[]
    participant1Name?: StringFilter<"Skit"> | string
    participant1Gender?: StringFilter<"Skit"> | string
    participant1Class?: StringFilter<"Skit"> | string
    participant1Accommodation?: StringFilter<"Skit"> | string
    participant2Name?: StringNullableFilter<"Skit"> | string | null
    participant2Gender?: StringNullableFilter<"Skit"> | string | null
    participant2Class?: StringNullableFilter<"Skit"> | string | null
    participant2Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant3Name?: StringNullableFilter<"Skit"> | string | null
    participant3Gender?: StringNullableFilter<"Skit"> | string | null
    participant3Class?: StringNullableFilter<"Skit"> | string | null
    participant3Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant4Name?: StringNullableFilter<"Skit"> | string | null
    participant4Gender?: StringNullableFilter<"Skit"> | string | null
    participant4Class?: StringNullableFilter<"Skit"> | string | null
    participant4Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant5Name?: StringNullableFilter<"Skit"> | string | null
    participant5Gender?: StringNullableFilter<"Skit"> | string | null
    participant5Class?: StringNullableFilter<"Skit"> | string | null
    participant5Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant6Name?: StringNullableFilter<"Skit"> | string | null
    participant6Gender?: StringNullableFilter<"Skit"> | string | null
    participant6Class?: StringNullableFilter<"Skit"> | string | null
    participant6Accommodation?: StringNullableFilter<"Skit"> | string | null
    additionalRequirements?: StringNullableFilter<"Skit"> | string | null
    declaration?: BoolFilter<"Skit"> | boolean
    videoLink?: StringFilter<"Skit"> | string
    schoolId?: IntFilter<"Skit"> | number
    createdAt?: DateTimeFilter<"Skit"> | Date | string
    updatedAt?: DateTimeFilter<"Skit"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type SkitOrderByWithAggregationInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrderInput | SortOrder
    participant2Gender?: SortOrderInput | SortOrder
    participant2Class?: SortOrderInput | SortOrder
    participant2Accommodation?: SortOrderInput | SortOrder
    participant3Name?: SortOrderInput | SortOrder
    participant3Gender?: SortOrderInput | SortOrder
    participant3Class?: SortOrderInput | SortOrder
    participant3Accommodation?: SortOrderInput | SortOrder
    participant4Name?: SortOrderInput | SortOrder
    participant4Gender?: SortOrderInput | SortOrder
    participant4Class?: SortOrderInput | SortOrder
    participant4Accommodation?: SortOrderInput | SortOrder
    participant5Name?: SortOrderInput | SortOrder
    participant5Gender?: SortOrderInput | SortOrder
    participant5Class?: SortOrderInput | SortOrder
    participant5Accommodation?: SortOrderInput | SortOrder
    participant6Name?: SortOrderInput | SortOrder
    participant6Gender?: SortOrderInput | SortOrder
    participant6Class?: SortOrderInput | SortOrder
    participant6Accommodation?: SortOrderInput | SortOrder
    additionalRequirements?: SortOrderInput | SortOrder
    declaration?: SortOrder
    videoLink?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkitCountOrderByAggregateInput
    _avg?: SkitAvgOrderByAggregateInput
    _max?: SkitMaxOrderByAggregateInput
    _min?: SkitMinOrderByAggregateInput
    _sum?: SkitSumOrderByAggregateInput
  }

  export type SkitScalarWhereWithAggregatesInput = {
    AND?: SkitScalarWhereWithAggregatesInput | SkitScalarWhereWithAggregatesInput[]
    OR?: SkitScalarWhereWithAggregatesInput[]
    NOT?: SkitScalarWhereWithAggregatesInput | SkitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Skit"> | number
    participant1Name?: StringWithAggregatesFilter<"Skit"> | string
    participant1Gender?: StringWithAggregatesFilter<"Skit"> | string
    participant1Class?: StringWithAggregatesFilter<"Skit"> | string
    participant1Accommodation?: StringWithAggregatesFilter<"Skit"> | string
    participant2Name?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant2Gender?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant2Class?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant2Accommodation?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant3Name?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant3Gender?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant3Class?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant3Accommodation?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant4Name?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant4Gender?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant4Class?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant4Accommodation?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant5Name?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant5Gender?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant5Class?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant5Accommodation?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant6Name?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant6Gender?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant6Class?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    participant6Accommodation?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    additionalRequirements?: StringNullableWithAggregatesFilter<"Skit"> | string | null
    declaration?: BoolWithAggregatesFilter<"Skit"> | boolean
    videoLink?: StringWithAggregatesFilter<"Skit"> | string
    schoolId?: IntWithAggregatesFilter<"Skit"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Skit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Skit"> | Date | string
  }

  export type TeacherModelWhereInput = {
    AND?: TeacherModelWhereInput | TeacherModelWhereInput[]
    OR?: TeacherModelWhereInput[]
    NOT?: TeacherModelWhereInput | TeacherModelWhereInput[]
    id?: IntFilter<"TeacherModel"> | number
    teacherName?: StringFilter<"TeacherModel"> | string
    teacherGender?: StringFilter<"TeacherModel"> | string
    accommodationRequired?: StringFilter<"TeacherModel"> | string
    additionalRequirements?: StringNullableFilter<"TeacherModel"> | string | null
    declaration?: BoolFilter<"TeacherModel"> | boolean
    writeup?: StringFilter<"TeacherModel"> | string
    schoolId?: IntFilter<"TeacherModel"> | number
    createdAt?: DateTimeFilter<"TeacherModel"> | Date | string
    updatedAt?: DateTimeFilter<"TeacherModel"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type TeacherModelOrderByWithRelationInput = {
    id?: SortOrder
    teacherName?: SortOrder
    teacherGender?: SortOrder
    accommodationRequired?: SortOrder
    additionalRequirements?: SortOrderInput | SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type TeacherModelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeacherModelWhereInput | TeacherModelWhereInput[]
    OR?: TeacherModelWhereInput[]
    NOT?: TeacherModelWhereInput | TeacherModelWhereInput[]
    teacherName?: StringFilter<"TeacherModel"> | string
    teacherGender?: StringFilter<"TeacherModel"> | string
    accommodationRequired?: StringFilter<"TeacherModel"> | string
    additionalRequirements?: StringNullableFilter<"TeacherModel"> | string | null
    declaration?: BoolFilter<"TeacherModel"> | boolean
    writeup?: StringFilter<"TeacherModel"> | string
    schoolId?: IntFilter<"TeacherModel"> | number
    createdAt?: DateTimeFilter<"TeacherModel"> | Date | string
    updatedAt?: DateTimeFilter<"TeacherModel"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type TeacherModelOrderByWithAggregationInput = {
    id?: SortOrder
    teacherName?: SortOrder
    teacherGender?: SortOrder
    accommodationRequired?: SortOrder
    additionalRequirements?: SortOrderInput | SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherModelCountOrderByAggregateInput
    _avg?: TeacherModelAvgOrderByAggregateInput
    _max?: TeacherModelMaxOrderByAggregateInput
    _min?: TeacherModelMinOrderByAggregateInput
    _sum?: TeacherModelSumOrderByAggregateInput
  }

  export type TeacherModelScalarWhereWithAggregatesInput = {
    AND?: TeacherModelScalarWhereWithAggregatesInput | TeacherModelScalarWhereWithAggregatesInput[]
    OR?: TeacherModelScalarWhereWithAggregatesInput[]
    NOT?: TeacherModelScalarWhereWithAggregatesInput | TeacherModelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeacherModel"> | number
    teacherName?: StringWithAggregatesFilter<"TeacherModel"> | string
    teacherGender?: StringWithAggregatesFilter<"TeacherModel"> | string
    accommodationRequired?: StringWithAggregatesFilter<"TeacherModel"> | string
    additionalRequirements?: StringNullableWithAggregatesFilter<"TeacherModel"> | string | null
    declaration?: BoolWithAggregatesFilter<"TeacherModel"> | boolean
    writeup?: StringWithAggregatesFilter<"TeacherModel"> | string
    schoolId?: IntWithAggregatesFilter<"TeacherModel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TeacherModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeacherModel"> | Date | string
  }

  export type IPRExhibitionFormWhereInput = {
    AND?: IPRExhibitionFormWhereInput | IPRExhibitionFormWhereInput[]
    OR?: IPRExhibitionFormWhereInput[]
    NOT?: IPRExhibitionFormWhereInput | IPRExhibitionFormWhereInput[]
    id?: IntFilter<"IPRExhibitionForm"> | number
    hallDimension?: StringFilter<"IPRExhibitionForm"> | string
    isEnclosedHall?: StringFilter<"IPRExhibitionForm"> | string
    canBeDarkened?: StringFilter<"IPRExhibitionForm"> | string
    hasCooling?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    isGroundFloor?: StringFilter<"IPRExhibitionForm"> | string
    hasStorageSpace?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    powerOutlets?: IntFilter<"IPRExhibitionForm"> | number
    numTables?: IntNullableFilter<"IPRExhibitionForm"> | number | null
    vrSpace?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    hasWifi?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    lectureHallArea?: StringFilter<"IPRExhibitionForm"> | string
    seatingCapacity?: IntFilter<"IPRExhibitionForm"> | number
    hasAVFacilities?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    distanceFromExhibition?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    accommodationProvided?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    localTransportation?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    secureParkingSpace?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    manpowerForLoading?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    contactPersonName?: StringFilter<"IPRExhibitionForm"> | string
    contactPersonMobile?: StringFilter<"IPRExhibitionForm"> | string
    contactPersonEmail?: StringFilter<"IPRExhibitionForm"> | string
    venueLocation?: StringFilter<"IPRExhibitionForm"> | string
    teacherInvitation?: IntFilter<"IPRExhibitionForm"> | number
    teacherRegistration?: IntFilter<"IPRExhibitionForm"> | number
    providesWritingMaterials?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    providesRefreshments?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    quizForSchoolStudents?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    quizTeamSelection?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    quizArrangements?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    quizRefreshments?: StringNullableFilter<"IPRExhibitionForm"> | string | null
  }

  export type IPRExhibitionFormOrderByWithRelationInput = {
    id?: SortOrder
    hallDimension?: SortOrder
    isEnclosedHall?: SortOrder
    canBeDarkened?: SortOrder
    hasCooling?: SortOrderInput | SortOrder
    isGroundFloor?: SortOrder
    hasStorageSpace?: SortOrderInput | SortOrder
    powerOutlets?: SortOrder
    numTables?: SortOrderInput | SortOrder
    vrSpace?: SortOrderInput | SortOrder
    hasWifi?: SortOrderInput | SortOrder
    lectureHallArea?: SortOrder
    seatingCapacity?: SortOrder
    hasAVFacilities?: SortOrderInput | SortOrder
    distanceFromExhibition?: SortOrderInput | SortOrder
    accommodationProvided?: SortOrderInput | SortOrder
    localTransportation?: SortOrderInput | SortOrder
    secureParkingSpace?: SortOrderInput | SortOrder
    manpowerForLoading?: SortOrderInput | SortOrder
    contactPersonName?: SortOrder
    contactPersonMobile?: SortOrder
    contactPersonEmail?: SortOrder
    venueLocation?: SortOrder
    teacherInvitation?: SortOrder
    teacherRegistration?: SortOrder
    providesWritingMaterials?: SortOrderInput | SortOrder
    providesRefreshments?: SortOrderInput | SortOrder
    quizForSchoolStudents?: SortOrderInput | SortOrder
    quizTeamSelection?: SortOrderInput | SortOrder
    quizArrangements?: SortOrderInput | SortOrder
    quizRefreshments?: SortOrderInput | SortOrder
  }

  export type IPRExhibitionFormWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IPRExhibitionFormWhereInput | IPRExhibitionFormWhereInput[]
    OR?: IPRExhibitionFormWhereInput[]
    NOT?: IPRExhibitionFormWhereInput | IPRExhibitionFormWhereInput[]
    hallDimension?: StringFilter<"IPRExhibitionForm"> | string
    isEnclosedHall?: StringFilter<"IPRExhibitionForm"> | string
    canBeDarkened?: StringFilter<"IPRExhibitionForm"> | string
    hasCooling?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    isGroundFloor?: StringFilter<"IPRExhibitionForm"> | string
    hasStorageSpace?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    powerOutlets?: IntFilter<"IPRExhibitionForm"> | number
    numTables?: IntNullableFilter<"IPRExhibitionForm"> | number | null
    vrSpace?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    hasWifi?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    lectureHallArea?: StringFilter<"IPRExhibitionForm"> | string
    seatingCapacity?: IntFilter<"IPRExhibitionForm"> | number
    hasAVFacilities?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    distanceFromExhibition?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    accommodationProvided?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    localTransportation?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    secureParkingSpace?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    manpowerForLoading?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    contactPersonName?: StringFilter<"IPRExhibitionForm"> | string
    contactPersonMobile?: StringFilter<"IPRExhibitionForm"> | string
    contactPersonEmail?: StringFilter<"IPRExhibitionForm"> | string
    venueLocation?: StringFilter<"IPRExhibitionForm"> | string
    teacherInvitation?: IntFilter<"IPRExhibitionForm"> | number
    teacherRegistration?: IntFilter<"IPRExhibitionForm"> | number
    providesWritingMaterials?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    providesRefreshments?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    quizForSchoolStudents?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    quizTeamSelection?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    quizArrangements?: StringNullableFilter<"IPRExhibitionForm"> | string | null
    quizRefreshments?: StringNullableFilter<"IPRExhibitionForm"> | string | null
  }, "id">

  export type IPRExhibitionFormOrderByWithAggregationInput = {
    id?: SortOrder
    hallDimension?: SortOrder
    isEnclosedHall?: SortOrder
    canBeDarkened?: SortOrder
    hasCooling?: SortOrderInput | SortOrder
    isGroundFloor?: SortOrder
    hasStorageSpace?: SortOrderInput | SortOrder
    powerOutlets?: SortOrder
    numTables?: SortOrderInput | SortOrder
    vrSpace?: SortOrderInput | SortOrder
    hasWifi?: SortOrderInput | SortOrder
    lectureHallArea?: SortOrder
    seatingCapacity?: SortOrder
    hasAVFacilities?: SortOrderInput | SortOrder
    distanceFromExhibition?: SortOrderInput | SortOrder
    accommodationProvided?: SortOrderInput | SortOrder
    localTransportation?: SortOrderInput | SortOrder
    secureParkingSpace?: SortOrderInput | SortOrder
    manpowerForLoading?: SortOrderInput | SortOrder
    contactPersonName?: SortOrder
    contactPersonMobile?: SortOrder
    contactPersonEmail?: SortOrder
    venueLocation?: SortOrder
    teacherInvitation?: SortOrder
    teacherRegistration?: SortOrder
    providesWritingMaterials?: SortOrderInput | SortOrder
    providesRefreshments?: SortOrderInput | SortOrder
    quizForSchoolStudents?: SortOrderInput | SortOrder
    quizTeamSelection?: SortOrderInput | SortOrder
    quizArrangements?: SortOrderInput | SortOrder
    quizRefreshments?: SortOrderInput | SortOrder
    _count?: IPRExhibitionFormCountOrderByAggregateInput
    _avg?: IPRExhibitionFormAvgOrderByAggregateInput
    _max?: IPRExhibitionFormMaxOrderByAggregateInput
    _min?: IPRExhibitionFormMinOrderByAggregateInput
    _sum?: IPRExhibitionFormSumOrderByAggregateInput
  }

  export type IPRExhibitionFormScalarWhereWithAggregatesInput = {
    AND?: IPRExhibitionFormScalarWhereWithAggregatesInput | IPRExhibitionFormScalarWhereWithAggregatesInput[]
    OR?: IPRExhibitionFormScalarWhereWithAggregatesInput[]
    NOT?: IPRExhibitionFormScalarWhereWithAggregatesInput | IPRExhibitionFormScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IPRExhibitionForm"> | number
    hallDimension?: StringWithAggregatesFilter<"IPRExhibitionForm"> | string
    isEnclosedHall?: StringWithAggregatesFilter<"IPRExhibitionForm"> | string
    canBeDarkened?: StringWithAggregatesFilter<"IPRExhibitionForm"> | string
    hasCooling?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    isGroundFloor?: StringWithAggregatesFilter<"IPRExhibitionForm"> | string
    hasStorageSpace?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    powerOutlets?: IntWithAggregatesFilter<"IPRExhibitionForm"> | number
    numTables?: IntNullableWithAggregatesFilter<"IPRExhibitionForm"> | number | null
    vrSpace?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    hasWifi?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    lectureHallArea?: StringWithAggregatesFilter<"IPRExhibitionForm"> | string
    seatingCapacity?: IntWithAggregatesFilter<"IPRExhibitionForm"> | number
    hasAVFacilities?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    distanceFromExhibition?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    accommodationProvided?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    localTransportation?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    secureParkingSpace?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    manpowerForLoading?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    contactPersonName?: StringWithAggregatesFilter<"IPRExhibitionForm"> | string
    contactPersonMobile?: StringWithAggregatesFilter<"IPRExhibitionForm"> | string
    contactPersonEmail?: StringWithAggregatesFilter<"IPRExhibitionForm"> | string
    venueLocation?: StringWithAggregatesFilter<"IPRExhibitionForm"> | string
    teacherInvitation?: IntWithAggregatesFilter<"IPRExhibitionForm"> | number
    teacherRegistration?: IntWithAggregatesFilter<"IPRExhibitionForm"> | number
    providesWritingMaterials?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    providesRefreshments?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    quizForSchoolStudents?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    quizTeamSelection?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    quizArrangements?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
    quizRefreshments?: StringNullableWithAggregatesFilter<"IPRExhibitionForm"> | string | null
  }

  export type RatingsCreateInput = {
    iprRating: number
    fciptRating: number
    knowledge: number
    explanationsIPR: number
    explanationsFCIPT: number
    knowledgeBefore: number
    knowledgeAfter: number
    technicalContents: number
    easeOfUnderstanding: number
    feedbackForm: feedbackFormCreateNestedOneWithoutRatingsInput
  }

  export type RatingsUncheckedCreateInput = {
    id?: number
    iprRating: number
    fciptRating: number
    knowledge: number
    explanationsIPR: number
    explanationsFCIPT: number
    knowledgeBefore: number
    knowledgeAfter: number
    technicalContents: number
    easeOfUnderstanding: number
    feedbackFormId: number
  }

  export type RatingsUpdateInput = {
    iprRating?: IntFieldUpdateOperationsInput | number
    fciptRating?: IntFieldUpdateOperationsInput | number
    knowledge?: IntFieldUpdateOperationsInput | number
    explanationsIPR?: IntFieldUpdateOperationsInput | number
    explanationsFCIPT?: IntFieldUpdateOperationsInput | number
    knowledgeBefore?: IntFieldUpdateOperationsInput | number
    knowledgeAfter?: IntFieldUpdateOperationsInput | number
    technicalContents?: IntFieldUpdateOperationsInput | number
    easeOfUnderstanding?: IntFieldUpdateOperationsInput | number
    feedbackForm?: feedbackFormUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    iprRating?: IntFieldUpdateOperationsInput | number
    fciptRating?: IntFieldUpdateOperationsInput | number
    knowledge?: IntFieldUpdateOperationsInput | number
    explanationsIPR?: IntFieldUpdateOperationsInput | number
    explanationsFCIPT?: IntFieldUpdateOperationsInput | number
    knowledgeBefore?: IntFieldUpdateOperationsInput | number
    knowledgeAfter?: IntFieldUpdateOperationsInput | number
    technicalContents?: IntFieldUpdateOperationsInput | number
    easeOfUnderstanding?: IntFieldUpdateOperationsInput | number
    feedbackFormId?: IntFieldUpdateOperationsInput | number
  }

  export type RatingsCreateManyInput = {
    id?: number
    iprRating: number
    fciptRating: number
    knowledge: number
    explanationsIPR: number
    explanationsFCIPT: number
    knowledgeBefore: number
    knowledgeAfter: number
    technicalContents: number
    easeOfUnderstanding: number
    feedbackFormId: number
  }

  export type RatingsUpdateManyMutationInput = {
    iprRating?: IntFieldUpdateOperationsInput | number
    fciptRating?: IntFieldUpdateOperationsInput | number
    knowledge?: IntFieldUpdateOperationsInput | number
    explanationsIPR?: IntFieldUpdateOperationsInput | number
    explanationsFCIPT?: IntFieldUpdateOperationsInput | number
    knowledgeBefore?: IntFieldUpdateOperationsInput | number
    knowledgeAfter?: IntFieldUpdateOperationsInput | number
    technicalContents?: IntFieldUpdateOperationsInput | number
    easeOfUnderstanding?: IntFieldUpdateOperationsInput | number
  }

  export type RatingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    iprRating?: IntFieldUpdateOperationsInput | number
    fciptRating?: IntFieldUpdateOperationsInput | number
    knowledge?: IntFieldUpdateOperationsInput | number
    explanationsIPR?: IntFieldUpdateOperationsInput | number
    explanationsFCIPT?: IntFieldUpdateOperationsInput | number
    knowledgeBefore?: IntFieldUpdateOperationsInput | number
    knowledgeAfter?: IntFieldUpdateOperationsInput | number
    technicalContents?: IntFieldUpdateOperationsInput | number
    easeOfUnderstanding?: IntFieldUpdateOperationsInput | number
    feedbackFormId?: IntFieldUpdateOperationsInput | number
  }

  export type feedbackFormCreateInput = {
    institutionName: string
    website: string
    visitDate: Date | string
    staffName: string
    staffEmail: string
    staffMobile: string
    totalStudents: number
    accompanyingStaff: number
    sources?: feedbackFormCreatesourcesInput | string[]
    campuses?: feedbackFormCreatecampusesInput | string[]
    best?: string | null
    worst?: string | null
    suggestions?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ratings?: RatingsCreateNestedOneWithoutFeedbackFormInput
  }

  export type feedbackFormUncheckedCreateInput = {
    id?: number
    institutionName: string
    website: string
    visitDate: Date | string
    staffName: string
    staffEmail: string
    staffMobile: string
    totalStudents: number
    accompanyingStaff: number
    sources?: feedbackFormCreatesourcesInput | string[]
    campuses?: feedbackFormCreatecampusesInput | string[]
    best?: string | null
    worst?: string | null
    suggestions?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ratings?: RatingsUncheckedCreateNestedOneWithoutFeedbackFormInput
  }

  export type feedbackFormUpdateInput = {
    institutionName?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffName?: StringFieldUpdateOperationsInput | string
    staffEmail?: StringFieldUpdateOperationsInput | string
    staffMobile?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    accompanyingStaff?: IntFieldUpdateOperationsInput | number
    sources?: feedbackFormUpdatesourcesInput | string[]
    campuses?: feedbackFormUpdatecampusesInput | string[]
    best?: NullableStringFieldUpdateOperationsInput | string | null
    worst?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: RatingsUpdateOneWithoutFeedbackFormNestedInput
  }

  export type feedbackFormUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    institutionName?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffName?: StringFieldUpdateOperationsInput | string
    staffEmail?: StringFieldUpdateOperationsInput | string
    staffMobile?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    accompanyingStaff?: IntFieldUpdateOperationsInput | number
    sources?: feedbackFormUpdatesourcesInput | string[]
    campuses?: feedbackFormUpdatecampusesInput | string[]
    best?: NullableStringFieldUpdateOperationsInput | string | null
    worst?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: RatingsUncheckedUpdateOneWithoutFeedbackFormNestedInput
  }

  export type feedbackFormCreateManyInput = {
    id?: number
    institutionName: string
    website: string
    visitDate: Date | string
    staffName: string
    staffEmail: string
    staffMobile: string
    totalStudents: number
    accompanyingStaff: number
    sources?: feedbackFormCreatesourcesInput | string[]
    campuses?: feedbackFormCreatecampusesInput | string[]
    best?: string | null
    worst?: string | null
    suggestions?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbackFormUpdateManyMutationInput = {
    institutionName?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffName?: StringFieldUpdateOperationsInput | string
    staffEmail?: StringFieldUpdateOperationsInput | string
    staffMobile?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    accompanyingStaff?: IntFieldUpdateOperationsInput | number
    sources?: feedbackFormUpdatesourcesInput | string[]
    campuses?: feedbackFormUpdatecampusesInput | string[]
    best?: NullableStringFieldUpdateOperationsInput | string | null
    worst?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbackFormUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    institutionName?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffName?: StringFieldUpdateOperationsInput | string
    staffEmail?: StringFieldUpdateOperationsInput | string
    staffMobile?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    accompanyingStaff?: IntFieldUpdateOperationsInput | number
    sources?: feedbackFormUpdatesourcesInput | string[]
    campuses?: feedbackFormUpdatecampusesInput | string[]
    best?: NullableStringFieldUpdateOperationsInput | string | null
    worst?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateInput = {
    institutionName: string
    studentBranch: string
    studentSem: number
    numStudents: number
    numFaculty: number
    name: string
    position: string
    email: string
    mobile: string
    campus?: VisitorCreatecampusInput | string[]
    ipr_time?: string | null
    fcipt_time?: string | null
    visit_date: Date | string
    visit_time: string
    materials?: VisitorCreatematerialsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorUncheckedCreateInput = {
    id?: number
    institutionName: string
    studentBranch: string
    studentSem: number
    numStudents: number
    numFaculty: number
    name: string
    position: string
    email: string
    mobile: string
    campus?: VisitorCreatecampusInput | string[]
    ipr_time?: string | null
    fcipt_time?: string | null
    visit_date: Date | string
    visit_time: string
    materials?: VisitorCreatematerialsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorUpdateInput = {
    institutionName?: StringFieldUpdateOperationsInput | string
    studentBranch?: StringFieldUpdateOperationsInput | string
    studentSem?: IntFieldUpdateOperationsInput | number
    numStudents?: IntFieldUpdateOperationsInput | number
    numFaculty?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    campus?: VisitorUpdatecampusInput | string[]
    ipr_time?: NullableStringFieldUpdateOperationsInput | string | null
    fcipt_time?: NullableStringFieldUpdateOperationsInput | string | null
    visit_date?: DateTimeFieldUpdateOperationsInput | Date | string
    visit_time?: StringFieldUpdateOperationsInput | string
    materials?: VisitorUpdatematerialsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    institutionName?: StringFieldUpdateOperationsInput | string
    studentBranch?: StringFieldUpdateOperationsInput | string
    studentSem?: IntFieldUpdateOperationsInput | number
    numStudents?: IntFieldUpdateOperationsInput | number
    numFaculty?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    campus?: VisitorUpdatecampusInput | string[]
    ipr_time?: NullableStringFieldUpdateOperationsInput | string | null
    fcipt_time?: NullableStringFieldUpdateOperationsInput | string | null
    visit_date?: DateTimeFieldUpdateOperationsInput | Date | string
    visit_time?: StringFieldUpdateOperationsInput | string
    materials?: VisitorUpdatematerialsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateManyInput = {
    id?: number
    institutionName: string
    studentBranch: string
    studentSem: number
    numStudents: number
    numFaculty: number
    name: string
    position: string
    email: string
    mobile: string
    campus?: VisitorCreatecampusInput | string[]
    ipr_time?: string | null
    fcipt_time?: string | null
    visit_date: Date | string
    visit_time: string
    materials?: VisitorCreatematerialsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitorUpdateManyMutationInput = {
    institutionName?: StringFieldUpdateOperationsInput | string
    studentBranch?: StringFieldUpdateOperationsInput | string
    studentSem?: IntFieldUpdateOperationsInput | number
    numStudents?: IntFieldUpdateOperationsInput | number
    numFaculty?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    campus?: VisitorUpdatecampusInput | string[]
    ipr_time?: NullableStringFieldUpdateOperationsInput | string | null
    fcipt_time?: NullableStringFieldUpdateOperationsInput | string | null
    visit_date?: DateTimeFieldUpdateOperationsInput | Date | string
    visit_time?: StringFieldUpdateOperationsInput | string
    materials?: VisitorUpdatematerialsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    institutionName?: StringFieldUpdateOperationsInput | string
    studentBranch?: StringFieldUpdateOperationsInput | string
    studentSem?: IntFieldUpdateOperationsInput | number
    numStudents?: IntFieldUpdateOperationsInput | number
    numFaculty?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    campus?: VisitorUpdatecampusInput | string[]
    ipr_time?: NullableStringFieldUpdateOperationsInput | string | null
    fcipt_time?: NullableStringFieldUpdateOperationsInput | string | null
    visit_date?: DateTimeFieldUpdateOperationsInput | Date | string
    visit_time?: StringFieldUpdateOperationsInput | string
    materials?: VisitorUpdatematerialsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanyingTeacherCreateInput = {
    name: string
    gender: string
    requiresAccommodation: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutAccompanyingTeachersInput
  }

  export type AccompanyingTeacherUncheckedCreateInput = {
    id?: number
    name: string
    gender: string
    requiresAccommodation: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccompanyingTeacherUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    requiresAccommodation?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutAccompanyingTeachersNestedInput
  }

  export type AccompanyingTeacherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    requiresAccommodation?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanyingTeacherCreateManyInput = {
    id?: number
    name: string
    gender: string
    requiresAccommodation: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccompanyingTeacherUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    requiresAccommodation?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanyingTeacherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    requiresAccommodation?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitionCreateInput = {
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutCompetitionsInput
  }

  export type CompetitionUncheckedCreateInput = {
    id?: number
    title: string
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutCompetitionsNestedInput
  }

  export type CompetitionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitionCreateManyInput = {
    id?: number
    title: string
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel1CreateInput = {
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutStudentModel1Input
  }

  export type StudentModel1UncheckedCreateInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentModel1UpdateInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutStudentModel1NestedInput
  }

  export type StudentModel1UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel1CreateManyInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentModel1UpdateManyMutationInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel1UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel2CreateInput = {
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutStudentModel2Input
  }

  export type StudentModel2UncheckedCreateInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentModel2UpdateInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutStudentModel2NestedInput
  }

  export type StudentModel2UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel2CreateManyInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentModel2UpdateManyMutationInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel2UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceEnglishCreateInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutEloquenceEnglishInput
  }

  export type EloquenceEnglishUncheckedCreateInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceEnglishUpdateInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutEloquenceEnglishNestedInput
  }

  export type EloquenceEnglishUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceEnglishCreateManyInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceEnglishUpdateManyMutationInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceEnglishUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceHindiCreateInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutEloquenceHindiInput
  }

  export type EloquenceHindiUncheckedCreateInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceHindiUpdateInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutEloquenceHindiNestedInput
  }

  export type EloquenceHindiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceHindiCreateManyInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceHindiUpdateManyMutationInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceHindiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceGujaratiCreateInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutEloquenceGujaratiInput
  }

  export type EloquenceGujaratiUncheckedCreateInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceGujaratiUpdateInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutEloquenceGujaratiNestedInput
  }

  export type EloquenceGujaratiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceGujaratiCreateManyInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceGujaratiUpdateManyMutationInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceGujaratiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayEnglishCreateInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutEssayEnglishInput
  }

  export type EssayEnglishUncheckedCreateInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayEnglishUpdateInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutEssayEnglishNestedInput
  }

  export type EssayEnglishUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayEnglishCreateManyInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayEnglishUpdateManyMutationInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayEnglishUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayHindiCreateInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutEssayHindiInput
  }

  export type EssayHindiUncheckedCreateInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayHindiUpdateInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutEssayHindiNestedInput
  }

  export type EssayHindiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayHindiCreateManyInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayHindiUpdateManyMutationInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayHindiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayGujaratiCreateInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutEssayGujaratiInput
  }

  export type EssayGujaratiUncheckedCreateInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayGujaratiUpdateInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutEssayGujaratiNestedInput
  }

  export type EssayGujaratiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayGujaratiCreateManyInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayGujaratiUpdateManyMutationInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayGujaratiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosterCreateInput = {
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant1Declaration: boolean
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant2Declaration?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutPosterInput
  }

  export type PosterUncheckedCreateInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant1Declaration: boolean
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant2Declaration?: boolean | null
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosterUpdateInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant1Declaration?: BoolFieldUpdateOperationsInput | boolean
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Declaration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutPosterNestedInput
  }

  export type PosterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant1Declaration?: BoolFieldUpdateOperationsInput | boolean
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Declaration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosterCreateManyInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant1Declaration: boolean
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant2Declaration?: boolean | null
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosterUpdateManyMutationInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant1Declaration?: BoolFieldUpdateOperationsInput | boolean
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Declaration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant1Declaration?: BoolFieldUpdateOperationsInput | boolean
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Declaration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkitCreateInput = {
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant3Name?: string | null
    participant3Gender?: string | null
    participant3Class?: string | null
    participant3Accommodation?: string | null
    participant4Name?: string | null
    participant4Gender?: string | null
    participant4Class?: string | null
    participant4Accommodation?: string | null
    participant5Name?: string | null
    participant5Gender?: string | null
    participant5Class?: string | null
    participant5Accommodation?: string | null
    participant6Name?: string | null
    participant6Gender?: string | null
    participant6Class?: string | null
    participant6Accommodation?: string | null
    additionalRequirements?: string | null
    declaration: boolean
    videoLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSkitInput
  }

  export type SkitUncheckedCreateInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant3Name?: string | null
    participant3Gender?: string | null
    participant3Class?: string | null
    participant3Accommodation?: string | null
    participant4Name?: string | null
    participant4Gender?: string | null
    participant4Class?: string | null
    participant4Accommodation?: string | null
    participant5Name?: string | null
    participant5Gender?: string | null
    participant5Class?: string | null
    participant5Accommodation?: string | null
    participant6Name?: string | null
    participant6Gender?: string | null
    participant6Class?: string | null
    participant6Accommodation?: string | null
    additionalRequirements?: string | null
    declaration: boolean
    videoLink: string
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkitUpdateInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    videoLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSkitNestedInput
  }

  export type SkitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    videoLink?: StringFieldUpdateOperationsInput | string
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkitCreateManyInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant3Name?: string | null
    participant3Gender?: string | null
    participant3Class?: string | null
    participant3Accommodation?: string | null
    participant4Name?: string | null
    participant4Gender?: string | null
    participant4Class?: string | null
    participant4Accommodation?: string | null
    participant5Name?: string | null
    participant5Gender?: string | null
    participant5Class?: string | null
    participant5Accommodation?: string | null
    participant6Name?: string | null
    participant6Gender?: string | null
    participant6Class?: string | null
    participant6Accommodation?: string | null
    additionalRequirements?: string | null
    declaration: boolean
    videoLink: string
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkitUpdateManyMutationInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    videoLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    videoLink?: StringFieldUpdateOperationsInput | string
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherModelCreateInput = {
    teacherName: string
    teacherGender: string
    accommodationRequired: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTeacherModelInput
  }

  export type TeacherModelUncheckedCreateInput = {
    id?: number
    teacherName: string
    teacherGender: string
    accommodationRequired: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherModelUpdateInput = {
    teacherName?: StringFieldUpdateOperationsInput | string
    teacherGender?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTeacherModelNestedInput
  }

  export type TeacherModelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherName?: StringFieldUpdateOperationsInput | string
    teacherGender?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherModelCreateManyInput = {
    id?: number
    teacherName: string
    teacherGender: string
    accommodationRequired: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    schoolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherModelUpdateManyMutationInput = {
    teacherName?: StringFieldUpdateOperationsInput | string
    teacherGender?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherModelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherName?: StringFieldUpdateOperationsInput | string
    teacherGender?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    schoolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IPRExhibitionFormCreateInput = {
    hallDimension: string
    isEnclosedHall: string
    canBeDarkened: string
    hasCooling?: string | null
    isGroundFloor: string
    hasStorageSpace?: string | null
    powerOutlets: number
    numTables?: number | null
    vrSpace?: string | null
    hasWifi?: string | null
    lectureHallArea: string
    seatingCapacity: number
    hasAVFacilities?: string | null
    distanceFromExhibition?: string | null
    accommodationProvided?: string | null
    localTransportation?: string | null
    secureParkingSpace?: string | null
    manpowerForLoading?: string | null
    contactPersonName: string
    contactPersonMobile: string
    contactPersonEmail: string
    venueLocation: string
    teacherInvitation: number
    teacherRegistration: number
    providesWritingMaterials?: string | null
    providesRefreshments?: string | null
    quizForSchoolStudents?: string | null
    quizTeamSelection?: string | null
    quizArrangements?: string | null
    quizRefreshments?: string | null
  }

  export type IPRExhibitionFormUncheckedCreateInput = {
    id?: number
    hallDimension: string
    isEnclosedHall: string
    canBeDarkened: string
    hasCooling?: string | null
    isGroundFloor: string
    hasStorageSpace?: string | null
    powerOutlets: number
    numTables?: number | null
    vrSpace?: string | null
    hasWifi?: string | null
    lectureHallArea: string
    seatingCapacity: number
    hasAVFacilities?: string | null
    distanceFromExhibition?: string | null
    accommodationProvided?: string | null
    localTransportation?: string | null
    secureParkingSpace?: string | null
    manpowerForLoading?: string | null
    contactPersonName: string
    contactPersonMobile: string
    contactPersonEmail: string
    venueLocation: string
    teacherInvitation: number
    teacherRegistration: number
    providesWritingMaterials?: string | null
    providesRefreshments?: string | null
    quizForSchoolStudents?: string | null
    quizTeamSelection?: string | null
    quizArrangements?: string | null
    quizRefreshments?: string | null
  }

  export type IPRExhibitionFormUpdateInput = {
    hallDimension?: StringFieldUpdateOperationsInput | string
    isEnclosedHall?: StringFieldUpdateOperationsInput | string
    canBeDarkened?: StringFieldUpdateOperationsInput | string
    hasCooling?: NullableStringFieldUpdateOperationsInput | string | null
    isGroundFloor?: StringFieldUpdateOperationsInput | string
    hasStorageSpace?: NullableStringFieldUpdateOperationsInput | string | null
    powerOutlets?: IntFieldUpdateOperationsInput | number
    numTables?: NullableIntFieldUpdateOperationsInput | number | null
    vrSpace?: NullableStringFieldUpdateOperationsInput | string | null
    hasWifi?: NullableStringFieldUpdateOperationsInput | string | null
    lectureHallArea?: StringFieldUpdateOperationsInput | string
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    hasAVFacilities?: NullableStringFieldUpdateOperationsInput | string | null
    distanceFromExhibition?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationProvided?: NullableStringFieldUpdateOperationsInput | string | null
    localTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    secureParkingSpace?: NullableStringFieldUpdateOperationsInput | string | null
    manpowerForLoading?: NullableStringFieldUpdateOperationsInput | string | null
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonMobile?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    venueLocation?: StringFieldUpdateOperationsInput | string
    teacherInvitation?: IntFieldUpdateOperationsInput | number
    teacherRegistration?: IntFieldUpdateOperationsInput | number
    providesWritingMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    providesRefreshments?: NullableStringFieldUpdateOperationsInput | string | null
    quizForSchoolStudents?: NullableStringFieldUpdateOperationsInput | string | null
    quizTeamSelection?: NullableStringFieldUpdateOperationsInput | string | null
    quizArrangements?: NullableStringFieldUpdateOperationsInput | string | null
    quizRefreshments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IPRExhibitionFormUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hallDimension?: StringFieldUpdateOperationsInput | string
    isEnclosedHall?: StringFieldUpdateOperationsInput | string
    canBeDarkened?: StringFieldUpdateOperationsInput | string
    hasCooling?: NullableStringFieldUpdateOperationsInput | string | null
    isGroundFloor?: StringFieldUpdateOperationsInput | string
    hasStorageSpace?: NullableStringFieldUpdateOperationsInput | string | null
    powerOutlets?: IntFieldUpdateOperationsInput | number
    numTables?: NullableIntFieldUpdateOperationsInput | number | null
    vrSpace?: NullableStringFieldUpdateOperationsInput | string | null
    hasWifi?: NullableStringFieldUpdateOperationsInput | string | null
    lectureHallArea?: StringFieldUpdateOperationsInput | string
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    hasAVFacilities?: NullableStringFieldUpdateOperationsInput | string | null
    distanceFromExhibition?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationProvided?: NullableStringFieldUpdateOperationsInput | string | null
    localTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    secureParkingSpace?: NullableStringFieldUpdateOperationsInput | string | null
    manpowerForLoading?: NullableStringFieldUpdateOperationsInput | string | null
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonMobile?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    venueLocation?: StringFieldUpdateOperationsInput | string
    teacherInvitation?: IntFieldUpdateOperationsInput | number
    teacherRegistration?: IntFieldUpdateOperationsInput | number
    providesWritingMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    providesRefreshments?: NullableStringFieldUpdateOperationsInput | string | null
    quizForSchoolStudents?: NullableStringFieldUpdateOperationsInput | string | null
    quizTeamSelection?: NullableStringFieldUpdateOperationsInput | string | null
    quizArrangements?: NullableStringFieldUpdateOperationsInput | string | null
    quizRefreshments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IPRExhibitionFormCreateManyInput = {
    id?: number
    hallDimension: string
    isEnclosedHall: string
    canBeDarkened: string
    hasCooling?: string | null
    isGroundFloor: string
    hasStorageSpace?: string | null
    powerOutlets: number
    numTables?: number | null
    vrSpace?: string | null
    hasWifi?: string | null
    lectureHallArea: string
    seatingCapacity: number
    hasAVFacilities?: string | null
    distanceFromExhibition?: string | null
    accommodationProvided?: string | null
    localTransportation?: string | null
    secureParkingSpace?: string | null
    manpowerForLoading?: string | null
    contactPersonName: string
    contactPersonMobile: string
    contactPersonEmail: string
    venueLocation: string
    teacherInvitation: number
    teacherRegistration: number
    providesWritingMaterials?: string | null
    providesRefreshments?: string | null
    quizForSchoolStudents?: string | null
    quizTeamSelection?: string | null
    quizArrangements?: string | null
    quizRefreshments?: string | null
  }

  export type IPRExhibitionFormUpdateManyMutationInput = {
    hallDimension?: StringFieldUpdateOperationsInput | string
    isEnclosedHall?: StringFieldUpdateOperationsInput | string
    canBeDarkened?: StringFieldUpdateOperationsInput | string
    hasCooling?: NullableStringFieldUpdateOperationsInput | string | null
    isGroundFloor?: StringFieldUpdateOperationsInput | string
    hasStorageSpace?: NullableStringFieldUpdateOperationsInput | string | null
    powerOutlets?: IntFieldUpdateOperationsInput | number
    numTables?: NullableIntFieldUpdateOperationsInput | number | null
    vrSpace?: NullableStringFieldUpdateOperationsInput | string | null
    hasWifi?: NullableStringFieldUpdateOperationsInput | string | null
    lectureHallArea?: StringFieldUpdateOperationsInput | string
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    hasAVFacilities?: NullableStringFieldUpdateOperationsInput | string | null
    distanceFromExhibition?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationProvided?: NullableStringFieldUpdateOperationsInput | string | null
    localTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    secureParkingSpace?: NullableStringFieldUpdateOperationsInput | string | null
    manpowerForLoading?: NullableStringFieldUpdateOperationsInput | string | null
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonMobile?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    venueLocation?: StringFieldUpdateOperationsInput | string
    teacherInvitation?: IntFieldUpdateOperationsInput | number
    teacherRegistration?: IntFieldUpdateOperationsInput | number
    providesWritingMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    providesRefreshments?: NullableStringFieldUpdateOperationsInput | string | null
    quizForSchoolStudents?: NullableStringFieldUpdateOperationsInput | string | null
    quizTeamSelection?: NullableStringFieldUpdateOperationsInput | string | null
    quizArrangements?: NullableStringFieldUpdateOperationsInput | string | null
    quizRefreshments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IPRExhibitionFormUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hallDimension?: StringFieldUpdateOperationsInput | string
    isEnclosedHall?: StringFieldUpdateOperationsInput | string
    canBeDarkened?: StringFieldUpdateOperationsInput | string
    hasCooling?: NullableStringFieldUpdateOperationsInput | string | null
    isGroundFloor?: StringFieldUpdateOperationsInput | string
    hasStorageSpace?: NullableStringFieldUpdateOperationsInput | string | null
    powerOutlets?: IntFieldUpdateOperationsInput | number
    numTables?: NullableIntFieldUpdateOperationsInput | number | null
    vrSpace?: NullableStringFieldUpdateOperationsInput | string | null
    hasWifi?: NullableStringFieldUpdateOperationsInput | string | null
    lectureHallArea?: StringFieldUpdateOperationsInput | string
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    hasAVFacilities?: NullableStringFieldUpdateOperationsInput | string | null
    distanceFromExhibition?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationProvided?: NullableStringFieldUpdateOperationsInput | string | null
    localTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    secureParkingSpace?: NullableStringFieldUpdateOperationsInput | string | null
    manpowerForLoading?: NullableStringFieldUpdateOperationsInput | string | null
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonMobile?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    venueLocation?: StringFieldUpdateOperationsInput | string
    teacherInvitation?: IntFieldUpdateOperationsInput | number
    teacherRegistration?: IntFieldUpdateOperationsInput | number
    providesWritingMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    providesRefreshments?: NullableStringFieldUpdateOperationsInput | string | null
    quizForSchoolStudents?: NullableStringFieldUpdateOperationsInput | string | null
    quizTeamSelection?: NullableStringFieldUpdateOperationsInput | string | null
    quizArrangements?: NullableStringFieldUpdateOperationsInput | string | null
    quizRefreshments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FeedbackFormRelationFilter = {
    is?: feedbackFormWhereInput
    isNot?: feedbackFormWhereInput
  }

  export type RatingsCountOrderByAggregateInput = {
    id?: SortOrder
    iprRating?: SortOrder
    fciptRating?: SortOrder
    knowledge?: SortOrder
    explanationsIPR?: SortOrder
    explanationsFCIPT?: SortOrder
    knowledgeBefore?: SortOrder
    knowledgeAfter?: SortOrder
    technicalContents?: SortOrder
    easeOfUnderstanding?: SortOrder
    feedbackFormId?: SortOrder
  }

  export type RatingsAvgOrderByAggregateInput = {
    id?: SortOrder
    iprRating?: SortOrder
    fciptRating?: SortOrder
    knowledge?: SortOrder
    explanationsIPR?: SortOrder
    explanationsFCIPT?: SortOrder
    knowledgeBefore?: SortOrder
    knowledgeAfter?: SortOrder
    technicalContents?: SortOrder
    easeOfUnderstanding?: SortOrder
    feedbackFormId?: SortOrder
  }

  export type RatingsMaxOrderByAggregateInput = {
    id?: SortOrder
    iprRating?: SortOrder
    fciptRating?: SortOrder
    knowledge?: SortOrder
    explanationsIPR?: SortOrder
    explanationsFCIPT?: SortOrder
    knowledgeBefore?: SortOrder
    knowledgeAfter?: SortOrder
    technicalContents?: SortOrder
    easeOfUnderstanding?: SortOrder
    feedbackFormId?: SortOrder
  }

  export type RatingsMinOrderByAggregateInput = {
    id?: SortOrder
    iprRating?: SortOrder
    fciptRating?: SortOrder
    knowledge?: SortOrder
    explanationsIPR?: SortOrder
    explanationsFCIPT?: SortOrder
    knowledgeBefore?: SortOrder
    knowledgeAfter?: SortOrder
    technicalContents?: SortOrder
    easeOfUnderstanding?: SortOrder
    feedbackFormId?: SortOrder
  }

  export type RatingsSumOrderByAggregateInput = {
    id?: SortOrder
    iprRating?: SortOrder
    fciptRating?: SortOrder
    knowledge?: SortOrder
    explanationsIPR?: SortOrder
    explanationsFCIPT?: SortOrder
    knowledgeBefore?: SortOrder
    knowledgeAfter?: SortOrder
    technicalContents?: SortOrder
    easeOfUnderstanding?: SortOrder
    feedbackFormId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type RatingsNullableRelationFilter = {
    is?: RatingsWhereInput | null
    isNot?: RatingsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type feedbackFormCountOrderByAggregateInput = {
    id?: SortOrder
    institutionName?: SortOrder
    website?: SortOrder
    visitDate?: SortOrder
    staffName?: SortOrder
    staffEmail?: SortOrder
    staffMobile?: SortOrder
    totalStudents?: SortOrder
    accompanyingStaff?: SortOrder
    sources?: SortOrder
    campuses?: SortOrder
    best?: SortOrder
    worst?: SortOrder
    suggestions?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbackFormAvgOrderByAggregateInput = {
    id?: SortOrder
    totalStudents?: SortOrder
    accompanyingStaff?: SortOrder
  }

  export type feedbackFormMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionName?: SortOrder
    website?: SortOrder
    visitDate?: SortOrder
    staffName?: SortOrder
    staffEmail?: SortOrder
    staffMobile?: SortOrder
    totalStudents?: SortOrder
    accompanyingStaff?: SortOrder
    best?: SortOrder
    worst?: SortOrder
    suggestions?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbackFormMinOrderByAggregateInput = {
    id?: SortOrder
    institutionName?: SortOrder
    website?: SortOrder
    visitDate?: SortOrder
    staffName?: SortOrder
    staffEmail?: SortOrder
    staffMobile?: SortOrder
    totalStudents?: SortOrder
    accompanyingStaff?: SortOrder
    best?: SortOrder
    worst?: SortOrder
    suggestions?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbackFormSumOrderByAggregateInput = {
    id?: SortOrder
    totalStudents?: SortOrder
    accompanyingStaff?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type VisitorCountOrderByAggregateInput = {
    id?: SortOrder
    institutionName?: SortOrder
    studentBranch?: SortOrder
    studentSem?: SortOrder
    numStudents?: SortOrder
    numFaculty?: SortOrder
    name?: SortOrder
    position?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    campus?: SortOrder
    ipr_time?: SortOrder
    fcipt_time?: SortOrder
    visit_date?: SortOrder
    visit_time?: SortOrder
    materials?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorAvgOrderByAggregateInput = {
    id?: SortOrder
    studentSem?: SortOrder
    numStudents?: SortOrder
    numFaculty?: SortOrder
  }

  export type VisitorMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionName?: SortOrder
    studentBranch?: SortOrder
    studentSem?: SortOrder
    numStudents?: SortOrder
    numFaculty?: SortOrder
    name?: SortOrder
    position?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    ipr_time?: SortOrder
    fcipt_time?: SortOrder
    visit_date?: SortOrder
    visit_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorMinOrderByAggregateInput = {
    id?: SortOrder
    institutionName?: SortOrder
    studentBranch?: SortOrder
    studentSem?: SortOrder
    numStudents?: SortOrder
    numFaculty?: SortOrder
    name?: SortOrder
    position?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    ipr_time?: SortOrder
    fcipt_time?: SortOrder
    visit_date?: SortOrder
    visit_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitorSumOrderByAggregateInput = {
    id?: SortOrder
    studentSem?: SortOrder
    numStudents?: SortOrder
    numFaculty?: SortOrder
  }

  export type AccompanyingTeacherListRelationFilter = {
    every?: AccompanyingTeacherWhereInput
    some?: AccompanyingTeacherWhereInput
    none?: AccompanyingTeacherWhereInput
  }

  export type CompetitionListRelationFilter = {
    every?: CompetitionWhereInput
    some?: CompetitionWhereInput
    none?: CompetitionWhereInput
  }

  export type StudentModel1ListRelationFilter = {
    every?: StudentModel1WhereInput
    some?: StudentModel1WhereInput
    none?: StudentModel1WhereInput
  }

  export type StudentModel2ListRelationFilter = {
    every?: StudentModel2WhereInput
    some?: StudentModel2WhereInput
    none?: StudentModel2WhereInput
  }

  export type EloquenceEnglishListRelationFilter = {
    every?: EloquenceEnglishWhereInput
    some?: EloquenceEnglishWhereInput
    none?: EloquenceEnglishWhereInput
  }

  export type EloquenceHindiListRelationFilter = {
    every?: EloquenceHindiWhereInput
    some?: EloquenceHindiWhereInput
    none?: EloquenceHindiWhereInput
  }

  export type EloquenceGujaratiListRelationFilter = {
    every?: EloquenceGujaratiWhereInput
    some?: EloquenceGujaratiWhereInput
    none?: EloquenceGujaratiWhereInput
  }

  export type EssayEnglishListRelationFilter = {
    every?: EssayEnglishWhereInput
    some?: EssayEnglishWhereInput
    none?: EssayEnglishWhereInput
  }

  export type EssayHindiListRelationFilter = {
    every?: EssayHindiWhereInput
    some?: EssayHindiWhereInput
    none?: EssayHindiWhereInput
  }

  export type EssayGujaratiListRelationFilter = {
    every?: EssayGujaratiWhereInput
    some?: EssayGujaratiWhereInput
    none?: EssayGujaratiWhereInput
  }

  export type PosterListRelationFilter = {
    every?: PosterWhereInput
    some?: PosterWhereInput
    none?: PosterWhereInput
  }

  export type SkitListRelationFilter = {
    every?: SkitWhereInput
    some?: SkitWhereInput
    none?: SkitWhereInput
  }

  export type TeacherModelListRelationFilter = {
    every?: TeacherModelWhereInput
    some?: TeacherModelWhereInput
    none?: TeacherModelWhereInput
  }

  export type AccompanyingTeacherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompetitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentModel1OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentModel2OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EloquenceEnglishOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EloquenceHindiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EloquenceGujaratiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EssayEnglishOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EssayHindiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EssayGujaratiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PosterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    pincode?: SortOrder
    affiliationNumber?: SortOrder
    coordinatorTeacherName?: SortOrder
    coordinatorTeacherMobile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    pincode?: SortOrder
    affiliationNumber?: SortOrder
    coordinatorTeacherName?: SortOrder
    coordinatorTeacherMobile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    pincode?: SortOrder
    affiliationNumber?: SortOrder
    coordinatorTeacherName?: SortOrder
    coordinatorTeacherMobile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SchoolRelationFilter = {
    is?: SchoolWhereInput
    isNot?: SchoolWhereInput
  }

  export type AccompanyingTeacherCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    requiresAccommodation?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccompanyingTeacherAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type AccompanyingTeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    requiresAccommodation?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccompanyingTeacherMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    requiresAccommodation?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccompanyingTeacherSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CompetitionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetitionAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type CompetitionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetitionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetitionSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type StudentModel1CountOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentModel1AvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type StudentModel1MaxOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentModel1MinOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentModel1SumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type StudentModel2CountOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentModel2AvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type StudentModel2MaxOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentModel2MinOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentModel2SumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EloquenceEnglishCountOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EloquenceEnglishAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EloquenceEnglishMaxOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EloquenceEnglishMinOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EloquenceEnglishSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EloquenceHindiCountOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EloquenceHindiAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EloquenceHindiMaxOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EloquenceHindiMinOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EloquenceHindiSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EloquenceGujaratiCountOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EloquenceGujaratiAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EloquenceGujaratiMaxOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EloquenceGujaratiMinOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EloquenceGujaratiSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EssayEnglishCountOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EssayEnglishAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EssayEnglishMaxOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EssayEnglishMinOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EssayEnglishSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EssayHindiCountOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EssayHindiAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EssayHindiMaxOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EssayHindiMinOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EssayHindiSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EssayGujaratiCountOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EssayGujaratiAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type EssayGujaratiMaxOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EssayGujaratiMinOrderByAggregateInput = {
    id?: SortOrder
    participantName?: SortOrder
    participantGender?: SortOrder
    participantClass?: SortOrder
    accommodationRequired?: SortOrder
    essayFileUrl?: SortOrder
    declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EssayGujaratiSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type PosterCountOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant1Declaration?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    participant2Declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PosterAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type PosterMaxOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant1Declaration?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    participant2Declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PosterMinOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant1Declaration?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    participant2Declaration?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PosterSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type SkitCountOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    participant3Name?: SortOrder
    participant3Gender?: SortOrder
    participant3Class?: SortOrder
    participant3Accommodation?: SortOrder
    participant4Name?: SortOrder
    participant4Gender?: SortOrder
    participant4Class?: SortOrder
    participant4Accommodation?: SortOrder
    participant5Name?: SortOrder
    participant5Gender?: SortOrder
    participant5Class?: SortOrder
    participant5Accommodation?: SortOrder
    participant6Name?: SortOrder
    participant6Gender?: SortOrder
    participant6Class?: SortOrder
    participant6Accommodation?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    videoLink?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkitAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type SkitMaxOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    participant3Name?: SortOrder
    participant3Gender?: SortOrder
    participant3Class?: SortOrder
    participant3Accommodation?: SortOrder
    participant4Name?: SortOrder
    participant4Gender?: SortOrder
    participant4Class?: SortOrder
    participant4Accommodation?: SortOrder
    participant5Name?: SortOrder
    participant5Gender?: SortOrder
    participant5Class?: SortOrder
    participant5Accommodation?: SortOrder
    participant6Name?: SortOrder
    participant6Gender?: SortOrder
    participant6Class?: SortOrder
    participant6Accommodation?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    videoLink?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkitMinOrderByAggregateInput = {
    id?: SortOrder
    participant1Name?: SortOrder
    participant1Gender?: SortOrder
    participant1Class?: SortOrder
    participant1Accommodation?: SortOrder
    participant2Name?: SortOrder
    participant2Gender?: SortOrder
    participant2Class?: SortOrder
    participant2Accommodation?: SortOrder
    participant3Name?: SortOrder
    participant3Gender?: SortOrder
    participant3Class?: SortOrder
    participant3Accommodation?: SortOrder
    participant4Name?: SortOrder
    participant4Gender?: SortOrder
    participant4Class?: SortOrder
    participant4Accommodation?: SortOrder
    participant5Name?: SortOrder
    participant5Gender?: SortOrder
    participant5Class?: SortOrder
    participant5Accommodation?: SortOrder
    participant6Name?: SortOrder
    participant6Gender?: SortOrder
    participant6Class?: SortOrder
    participant6Accommodation?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    videoLink?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkitSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type TeacherModelCountOrderByAggregateInput = {
    id?: SortOrder
    teacherName?: SortOrder
    teacherGender?: SortOrder
    accommodationRequired?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherModelAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type TeacherModelMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherName?: SortOrder
    teacherGender?: SortOrder
    accommodationRequired?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherModelMinOrderByAggregateInput = {
    id?: SortOrder
    teacherName?: SortOrder
    teacherGender?: SortOrder
    accommodationRequired?: SortOrder
    additionalRequirements?: SortOrder
    declaration?: SortOrder
    writeup?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherModelSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IPRExhibitionFormCountOrderByAggregateInput = {
    id?: SortOrder
    hallDimension?: SortOrder
    isEnclosedHall?: SortOrder
    canBeDarkened?: SortOrder
    hasCooling?: SortOrder
    isGroundFloor?: SortOrder
    hasStorageSpace?: SortOrder
    powerOutlets?: SortOrder
    numTables?: SortOrder
    vrSpace?: SortOrder
    hasWifi?: SortOrder
    lectureHallArea?: SortOrder
    seatingCapacity?: SortOrder
    hasAVFacilities?: SortOrder
    distanceFromExhibition?: SortOrder
    accommodationProvided?: SortOrder
    localTransportation?: SortOrder
    secureParkingSpace?: SortOrder
    manpowerForLoading?: SortOrder
    contactPersonName?: SortOrder
    contactPersonMobile?: SortOrder
    contactPersonEmail?: SortOrder
    venueLocation?: SortOrder
    teacherInvitation?: SortOrder
    teacherRegistration?: SortOrder
    providesWritingMaterials?: SortOrder
    providesRefreshments?: SortOrder
    quizForSchoolStudents?: SortOrder
    quizTeamSelection?: SortOrder
    quizArrangements?: SortOrder
    quizRefreshments?: SortOrder
  }

  export type IPRExhibitionFormAvgOrderByAggregateInput = {
    id?: SortOrder
    powerOutlets?: SortOrder
    numTables?: SortOrder
    seatingCapacity?: SortOrder
    teacherInvitation?: SortOrder
    teacherRegistration?: SortOrder
  }

  export type IPRExhibitionFormMaxOrderByAggregateInput = {
    id?: SortOrder
    hallDimension?: SortOrder
    isEnclosedHall?: SortOrder
    canBeDarkened?: SortOrder
    hasCooling?: SortOrder
    isGroundFloor?: SortOrder
    hasStorageSpace?: SortOrder
    powerOutlets?: SortOrder
    numTables?: SortOrder
    vrSpace?: SortOrder
    hasWifi?: SortOrder
    lectureHallArea?: SortOrder
    seatingCapacity?: SortOrder
    hasAVFacilities?: SortOrder
    distanceFromExhibition?: SortOrder
    accommodationProvided?: SortOrder
    localTransportation?: SortOrder
    secureParkingSpace?: SortOrder
    manpowerForLoading?: SortOrder
    contactPersonName?: SortOrder
    contactPersonMobile?: SortOrder
    contactPersonEmail?: SortOrder
    venueLocation?: SortOrder
    teacherInvitation?: SortOrder
    teacherRegistration?: SortOrder
    providesWritingMaterials?: SortOrder
    providesRefreshments?: SortOrder
    quizForSchoolStudents?: SortOrder
    quizTeamSelection?: SortOrder
    quizArrangements?: SortOrder
    quizRefreshments?: SortOrder
  }

  export type IPRExhibitionFormMinOrderByAggregateInput = {
    id?: SortOrder
    hallDimension?: SortOrder
    isEnclosedHall?: SortOrder
    canBeDarkened?: SortOrder
    hasCooling?: SortOrder
    isGroundFloor?: SortOrder
    hasStorageSpace?: SortOrder
    powerOutlets?: SortOrder
    numTables?: SortOrder
    vrSpace?: SortOrder
    hasWifi?: SortOrder
    lectureHallArea?: SortOrder
    seatingCapacity?: SortOrder
    hasAVFacilities?: SortOrder
    distanceFromExhibition?: SortOrder
    accommodationProvided?: SortOrder
    localTransportation?: SortOrder
    secureParkingSpace?: SortOrder
    manpowerForLoading?: SortOrder
    contactPersonName?: SortOrder
    contactPersonMobile?: SortOrder
    contactPersonEmail?: SortOrder
    venueLocation?: SortOrder
    teacherInvitation?: SortOrder
    teacherRegistration?: SortOrder
    providesWritingMaterials?: SortOrder
    providesRefreshments?: SortOrder
    quizForSchoolStudents?: SortOrder
    quizTeamSelection?: SortOrder
    quizArrangements?: SortOrder
    quizRefreshments?: SortOrder
  }

  export type IPRExhibitionFormSumOrderByAggregateInput = {
    id?: SortOrder
    powerOutlets?: SortOrder
    numTables?: SortOrder
    seatingCapacity?: SortOrder
    teacherInvitation?: SortOrder
    teacherRegistration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type feedbackFormCreateNestedOneWithoutRatingsInput = {
    create?: XOR<feedbackFormCreateWithoutRatingsInput, feedbackFormUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: feedbackFormCreateOrConnectWithoutRatingsInput
    connect?: feedbackFormWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type feedbackFormUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<feedbackFormCreateWithoutRatingsInput, feedbackFormUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: feedbackFormCreateOrConnectWithoutRatingsInput
    upsert?: feedbackFormUpsertWithoutRatingsInput
    connect?: feedbackFormWhereUniqueInput
    update?: XOR<XOR<feedbackFormUpdateToOneWithWhereWithoutRatingsInput, feedbackFormUpdateWithoutRatingsInput>, feedbackFormUncheckedUpdateWithoutRatingsInput>
  }

  export type feedbackFormCreatesourcesInput = {
    set: string[]
  }

  export type feedbackFormCreatecampusesInput = {
    set: string[]
  }

  export type RatingsCreateNestedOneWithoutFeedbackFormInput = {
    create?: XOR<RatingsCreateWithoutFeedbackFormInput, RatingsUncheckedCreateWithoutFeedbackFormInput>
    connectOrCreate?: RatingsCreateOrConnectWithoutFeedbackFormInput
    connect?: RatingsWhereUniqueInput
  }

  export type RatingsUncheckedCreateNestedOneWithoutFeedbackFormInput = {
    create?: XOR<RatingsCreateWithoutFeedbackFormInput, RatingsUncheckedCreateWithoutFeedbackFormInput>
    connectOrCreate?: RatingsCreateOrConnectWithoutFeedbackFormInput
    connect?: RatingsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type feedbackFormUpdatesourcesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type feedbackFormUpdatecampusesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type RatingsUpdateOneWithoutFeedbackFormNestedInput = {
    create?: XOR<RatingsCreateWithoutFeedbackFormInput, RatingsUncheckedCreateWithoutFeedbackFormInput>
    connectOrCreate?: RatingsCreateOrConnectWithoutFeedbackFormInput
    upsert?: RatingsUpsertWithoutFeedbackFormInput
    disconnect?: RatingsWhereInput | boolean
    delete?: RatingsWhereInput | boolean
    connect?: RatingsWhereUniqueInput
    update?: XOR<XOR<RatingsUpdateToOneWithWhereWithoutFeedbackFormInput, RatingsUpdateWithoutFeedbackFormInput>, RatingsUncheckedUpdateWithoutFeedbackFormInput>
  }

  export type RatingsUncheckedUpdateOneWithoutFeedbackFormNestedInput = {
    create?: XOR<RatingsCreateWithoutFeedbackFormInput, RatingsUncheckedCreateWithoutFeedbackFormInput>
    connectOrCreate?: RatingsCreateOrConnectWithoutFeedbackFormInput
    upsert?: RatingsUpsertWithoutFeedbackFormInput
    disconnect?: RatingsWhereInput | boolean
    delete?: RatingsWhereInput | boolean
    connect?: RatingsWhereUniqueInput
    update?: XOR<XOR<RatingsUpdateToOneWithWhereWithoutFeedbackFormInput, RatingsUpdateWithoutFeedbackFormInput>, RatingsUncheckedUpdateWithoutFeedbackFormInput>
  }

  export type VisitorCreatecampusInput = {
    set: string[]
  }

  export type VisitorCreatematerialsInput = {
    set: string[]
  }

  export type VisitorUpdatecampusInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VisitorUpdatematerialsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AccompanyingTeacherCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AccompanyingTeacherCreateWithoutSchoolInput, AccompanyingTeacherUncheckedCreateWithoutSchoolInput> | AccompanyingTeacherCreateWithoutSchoolInput[] | AccompanyingTeacherUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AccompanyingTeacherCreateOrConnectWithoutSchoolInput | AccompanyingTeacherCreateOrConnectWithoutSchoolInput[]
    createMany?: AccompanyingTeacherCreateManySchoolInputEnvelope
    connect?: AccompanyingTeacherWhereUniqueInput | AccompanyingTeacherWhereUniqueInput[]
  }

  export type CompetitionCreateNestedManyWithoutSchoolInput = {
    create?: XOR<CompetitionCreateWithoutSchoolInput, CompetitionUncheckedCreateWithoutSchoolInput> | CompetitionCreateWithoutSchoolInput[] | CompetitionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: CompetitionCreateOrConnectWithoutSchoolInput | CompetitionCreateOrConnectWithoutSchoolInput[]
    createMany?: CompetitionCreateManySchoolInputEnvelope
    connect?: CompetitionWhereUniqueInput | CompetitionWhereUniqueInput[]
  }

  export type StudentModel1CreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentModel1CreateWithoutSchoolInput, StudentModel1UncheckedCreateWithoutSchoolInput> | StudentModel1CreateWithoutSchoolInput[] | StudentModel1UncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentModel1CreateOrConnectWithoutSchoolInput | StudentModel1CreateOrConnectWithoutSchoolInput[]
    createMany?: StudentModel1CreateManySchoolInputEnvelope
    connect?: StudentModel1WhereUniqueInput | StudentModel1WhereUniqueInput[]
  }

  export type StudentModel2CreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentModel2CreateWithoutSchoolInput, StudentModel2UncheckedCreateWithoutSchoolInput> | StudentModel2CreateWithoutSchoolInput[] | StudentModel2UncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentModel2CreateOrConnectWithoutSchoolInput | StudentModel2CreateOrConnectWithoutSchoolInput[]
    createMany?: StudentModel2CreateManySchoolInputEnvelope
    connect?: StudentModel2WhereUniqueInput | StudentModel2WhereUniqueInput[]
  }

  export type EloquenceEnglishCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EloquenceEnglishCreateWithoutSchoolInput, EloquenceEnglishUncheckedCreateWithoutSchoolInput> | EloquenceEnglishCreateWithoutSchoolInput[] | EloquenceEnglishUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceEnglishCreateOrConnectWithoutSchoolInput | EloquenceEnglishCreateOrConnectWithoutSchoolInput[]
    createMany?: EloquenceEnglishCreateManySchoolInputEnvelope
    connect?: EloquenceEnglishWhereUniqueInput | EloquenceEnglishWhereUniqueInput[]
  }

  export type EloquenceHindiCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EloquenceHindiCreateWithoutSchoolInput, EloquenceHindiUncheckedCreateWithoutSchoolInput> | EloquenceHindiCreateWithoutSchoolInput[] | EloquenceHindiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceHindiCreateOrConnectWithoutSchoolInput | EloquenceHindiCreateOrConnectWithoutSchoolInput[]
    createMany?: EloquenceHindiCreateManySchoolInputEnvelope
    connect?: EloquenceHindiWhereUniqueInput | EloquenceHindiWhereUniqueInput[]
  }

  export type EloquenceGujaratiCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EloquenceGujaratiCreateWithoutSchoolInput, EloquenceGujaratiUncheckedCreateWithoutSchoolInput> | EloquenceGujaratiCreateWithoutSchoolInput[] | EloquenceGujaratiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceGujaratiCreateOrConnectWithoutSchoolInput | EloquenceGujaratiCreateOrConnectWithoutSchoolInput[]
    createMany?: EloquenceGujaratiCreateManySchoolInputEnvelope
    connect?: EloquenceGujaratiWhereUniqueInput | EloquenceGujaratiWhereUniqueInput[]
  }

  export type EssayEnglishCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EssayEnglishCreateWithoutSchoolInput, EssayEnglishUncheckedCreateWithoutSchoolInput> | EssayEnglishCreateWithoutSchoolInput[] | EssayEnglishUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayEnglishCreateOrConnectWithoutSchoolInput | EssayEnglishCreateOrConnectWithoutSchoolInput[]
    createMany?: EssayEnglishCreateManySchoolInputEnvelope
    connect?: EssayEnglishWhereUniqueInput | EssayEnglishWhereUniqueInput[]
  }

  export type EssayHindiCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EssayHindiCreateWithoutSchoolInput, EssayHindiUncheckedCreateWithoutSchoolInput> | EssayHindiCreateWithoutSchoolInput[] | EssayHindiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayHindiCreateOrConnectWithoutSchoolInput | EssayHindiCreateOrConnectWithoutSchoolInput[]
    createMany?: EssayHindiCreateManySchoolInputEnvelope
    connect?: EssayHindiWhereUniqueInput | EssayHindiWhereUniqueInput[]
  }

  export type EssayGujaratiCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EssayGujaratiCreateWithoutSchoolInput, EssayGujaratiUncheckedCreateWithoutSchoolInput> | EssayGujaratiCreateWithoutSchoolInput[] | EssayGujaratiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayGujaratiCreateOrConnectWithoutSchoolInput | EssayGujaratiCreateOrConnectWithoutSchoolInput[]
    createMany?: EssayGujaratiCreateManySchoolInputEnvelope
    connect?: EssayGujaratiWhereUniqueInput | EssayGujaratiWhereUniqueInput[]
  }

  export type PosterCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PosterCreateWithoutSchoolInput, PosterUncheckedCreateWithoutSchoolInput> | PosterCreateWithoutSchoolInput[] | PosterUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PosterCreateOrConnectWithoutSchoolInput | PosterCreateOrConnectWithoutSchoolInput[]
    createMany?: PosterCreateManySchoolInputEnvelope
    connect?: PosterWhereUniqueInput | PosterWhereUniqueInput[]
  }

  export type SkitCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SkitCreateWithoutSchoolInput, SkitUncheckedCreateWithoutSchoolInput> | SkitCreateWithoutSchoolInput[] | SkitUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SkitCreateOrConnectWithoutSchoolInput | SkitCreateOrConnectWithoutSchoolInput[]
    createMany?: SkitCreateManySchoolInputEnvelope
    connect?: SkitWhereUniqueInput | SkitWhereUniqueInput[]
  }

  export type TeacherModelCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TeacherModelCreateWithoutSchoolInput, TeacherModelUncheckedCreateWithoutSchoolInput> | TeacherModelCreateWithoutSchoolInput[] | TeacherModelUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherModelCreateOrConnectWithoutSchoolInput | TeacherModelCreateOrConnectWithoutSchoolInput[]
    createMany?: TeacherModelCreateManySchoolInputEnvelope
    connect?: TeacherModelWhereUniqueInput | TeacherModelWhereUniqueInput[]
  }

  export type AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AccompanyingTeacherCreateWithoutSchoolInput, AccompanyingTeacherUncheckedCreateWithoutSchoolInput> | AccompanyingTeacherCreateWithoutSchoolInput[] | AccompanyingTeacherUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AccompanyingTeacherCreateOrConnectWithoutSchoolInput | AccompanyingTeacherCreateOrConnectWithoutSchoolInput[]
    createMany?: AccompanyingTeacherCreateManySchoolInputEnvelope
    connect?: AccompanyingTeacherWhereUniqueInput | AccompanyingTeacherWhereUniqueInput[]
  }

  export type CompetitionUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<CompetitionCreateWithoutSchoolInput, CompetitionUncheckedCreateWithoutSchoolInput> | CompetitionCreateWithoutSchoolInput[] | CompetitionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: CompetitionCreateOrConnectWithoutSchoolInput | CompetitionCreateOrConnectWithoutSchoolInput[]
    createMany?: CompetitionCreateManySchoolInputEnvelope
    connect?: CompetitionWhereUniqueInput | CompetitionWhereUniqueInput[]
  }

  export type StudentModel1UncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentModel1CreateWithoutSchoolInput, StudentModel1UncheckedCreateWithoutSchoolInput> | StudentModel1CreateWithoutSchoolInput[] | StudentModel1UncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentModel1CreateOrConnectWithoutSchoolInput | StudentModel1CreateOrConnectWithoutSchoolInput[]
    createMany?: StudentModel1CreateManySchoolInputEnvelope
    connect?: StudentModel1WhereUniqueInput | StudentModel1WhereUniqueInput[]
  }

  export type StudentModel2UncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentModel2CreateWithoutSchoolInput, StudentModel2UncheckedCreateWithoutSchoolInput> | StudentModel2CreateWithoutSchoolInput[] | StudentModel2UncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentModel2CreateOrConnectWithoutSchoolInput | StudentModel2CreateOrConnectWithoutSchoolInput[]
    createMany?: StudentModel2CreateManySchoolInputEnvelope
    connect?: StudentModel2WhereUniqueInput | StudentModel2WhereUniqueInput[]
  }

  export type EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EloquenceEnglishCreateWithoutSchoolInput, EloquenceEnglishUncheckedCreateWithoutSchoolInput> | EloquenceEnglishCreateWithoutSchoolInput[] | EloquenceEnglishUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceEnglishCreateOrConnectWithoutSchoolInput | EloquenceEnglishCreateOrConnectWithoutSchoolInput[]
    createMany?: EloquenceEnglishCreateManySchoolInputEnvelope
    connect?: EloquenceEnglishWhereUniqueInput | EloquenceEnglishWhereUniqueInput[]
  }

  export type EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EloquenceHindiCreateWithoutSchoolInput, EloquenceHindiUncheckedCreateWithoutSchoolInput> | EloquenceHindiCreateWithoutSchoolInput[] | EloquenceHindiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceHindiCreateOrConnectWithoutSchoolInput | EloquenceHindiCreateOrConnectWithoutSchoolInput[]
    createMany?: EloquenceHindiCreateManySchoolInputEnvelope
    connect?: EloquenceHindiWhereUniqueInput | EloquenceHindiWhereUniqueInput[]
  }

  export type EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EloquenceGujaratiCreateWithoutSchoolInput, EloquenceGujaratiUncheckedCreateWithoutSchoolInput> | EloquenceGujaratiCreateWithoutSchoolInput[] | EloquenceGujaratiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceGujaratiCreateOrConnectWithoutSchoolInput | EloquenceGujaratiCreateOrConnectWithoutSchoolInput[]
    createMany?: EloquenceGujaratiCreateManySchoolInputEnvelope
    connect?: EloquenceGujaratiWhereUniqueInput | EloquenceGujaratiWhereUniqueInput[]
  }

  export type EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EssayEnglishCreateWithoutSchoolInput, EssayEnglishUncheckedCreateWithoutSchoolInput> | EssayEnglishCreateWithoutSchoolInput[] | EssayEnglishUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayEnglishCreateOrConnectWithoutSchoolInput | EssayEnglishCreateOrConnectWithoutSchoolInput[]
    createMany?: EssayEnglishCreateManySchoolInputEnvelope
    connect?: EssayEnglishWhereUniqueInput | EssayEnglishWhereUniqueInput[]
  }

  export type EssayHindiUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EssayHindiCreateWithoutSchoolInput, EssayHindiUncheckedCreateWithoutSchoolInput> | EssayHindiCreateWithoutSchoolInput[] | EssayHindiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayHindiCreateOrConnectWithoutSchoolInput | EssayHindiCreateOrConnectWithoutSchoolInput[]
    createMany?: EssayHindiCreateManySchoolInputEnvelope
    connect?: EssayHindiWhereUniqueInput | EssayHindiWhereUniqueInput[]
  }

  export type EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EssayGujaratiCreateWithoutSchoolInput, EssayGujaratiUncheckedCreateWithoutSchoolInput> | EssayGujaratiCreateWithoutSchoolInput[] | EssayGujaratiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayGujaratiCreateOrConnectWithoutSchoolInput | EssayGujaratiCreateOrConnectWithoutSchoolInput[]
    createMany?: EssayGujaratiCreateManySchoolInputEnvelope
    connect?: EssayGujaratiWhereUniqueInput | EssayGujaratiWhereUniqueInput[]
  }

  export type PosterUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PosterCreateWithoutSchoolInput, PosterUncheckedCreateWithoutSchoolInput> | PosterCreateWithoutSchoolInput[] | PosterUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PosterCreateOrConnectWithoutSchoolInput | PosterCreateOrConnectWithoutSchoolInput[]
    createMany?: PosterCreateManySchoolInputEnvelope
    connect?: PosterWhereUniqueInput | PosterWhereUniqueInput[]
  }

  export type SkitUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SkitCreateWithoutSchoolInput, SkitUncheckedCreateWithoutSchoolInput> | SkitCreateWithoutSchoolInput[] | SkitUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SkitCreateOrConnectWithoutSchoolInput | SkitCreateOrConnectWithoutSchoolInput[]
    createMany?: SkitCreateManySchoolInputEnvelope
    connect?: SkitWhereUniqueInput | SkitWhereUniqueInput[]
  }

  export type TeacherModelUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TeacherModelCreateWithoutSchoolInput, TeacherModelUncheckedCreateWithoutSchoolInput> | TeacherModelCreateWithoutSchoolInput[] | TeacherModelUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherModelCreateOrConnectWithoutSchoolInput | TeacherModelCreateOrConnectWithoutSchoolInput[]
    createMany?: TeacherModelCreateManySchoolInputEnvelope
    connect?: TeacherModelWhereUniqueInput | TeacherModelWhereUniqueInput[]
  }

  export type AccompanyingTeacherUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AccompanyingTeacherCreateWithoutSchoolInput, AccompanyingTeacherUncheckedCreateWithoutSchoolInput> | AccompanyingTeacherCreateWithoutSchoolInput[] | AccompanyingTeacherUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AccompanyingTeacherCreateOrConnectWithoutSchoolInput | AccompanyingTeacherCreateOrConnectWithoutSchoolInput[]
    upsert?: AccompanyingTeacherUpsertWithWhereUniqueWithoutSchoolInput | AccompanyingTeacherUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AccompanyingTeacherCreateManySchoolInputEnvelope
    set?: AccompanyingTeacherWhereUniqueInput | AccompanyingTeacherWhereUniqueInput[]
    disconnect?: AccompanyingTeacherWhereUniqueInput | AccompanyingTeacherWhereUniqueInput[]
    delete?: AccompanyingTeacherWhereUniqueInput | AccompanyingTeacherWhereUniqueInput[]
    connect?: AccompanyingTeacherWhereUniqueInput | AccompanyingTeacherWhereUniqueInput[]
    update?: AccompanyingTeacherUpdateWithWhereUniqueWithoutSchoolInput | AccompanyingTeacherUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AccompanyingTeacherUpdateManyWithWhereWithoutSchoolInput | AccompanyingTeacherUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AccompanyingTeacherScalarWhereInput | AccompanyingTeacherScalarWhereInput[]
  }

  export type CompetitionUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<CompetitionCreateWithoutSchoolInput, CompetitionUncheckedCreateWithoutSchoolInput> | CompetitionCreateWithoutSchoolInput[] | CompetitionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: CompetitionCreateOrConnectWithoutSchoolInput | CompetitionCreateOrConnectWithoutSchoolInput[]
    upsert?: CompetitionUpsertWithWhereUniqueWithoutSchoolInput | CompetitionUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: CompetitionCreateManySchoolInputEnvelope
    set?: CompetitionWhereUniqueInput | CompetitionWhereUniqueInput[]
    disconnect?: CompetitionWhereUniqueInput | CompetitionWhereUniqueInput[]
    delete?: CompetitionWhereUniqueInput | CompetitionWhereUniqueInput[]
    connect?: CompetitionWhereUniqueInput | CompetitionWhereUniqueInput[]
    update?: CompetitionUpdateWithWhereUniqueWithoutSchoolInput | CompetitionUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: CompetitionUpdateManyWithWhereWithoutSchoolInput | CompetitionUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: CompetitionScalarWhereInput | CompetitionScalarWhereInput[]
  }

  export type StudentModel1UpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentModel1CreateWithoutSchoolInput, StudentModel1UncheckedCreateWithoutSchoolInput> | StudentModel1CreateWithoutSchoolInput[] | StudentModel1UncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentModel1CreateOrConnectWithoutSchoolInput | StudentModel1CreateOrConnectWithoutSchoolInput[]
    upsert?: StudentModel1UpsertWithWhereUniqueWithoutSchoolInput | StudentModel1UpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentModel1CreateManySchoolInputEnvelope
    set?: StudentModel1WhereUniqueInput | StudentModel1WhereUniqueInput[]
    disconnect?: StudentModel1WhereUniqueInput | StudentModel1WhereUniqueInput[]
    delete?: StudentModel1WhereUniqueInput | StudentModel1WhereUniqueInput[]
    connect?: StudentModel1WhereUniqueInput | StudentModel1WhereUniqueInput[]
    update?: StudentModel1UpdateWithWhereUniqueWithoutSchoolInput | StudentModel1UpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentModel1UpdateManyWithWhereWithoutSchoolInput | StudentModel1UpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentModel1ScalarWhereInput | StudentModel1ScalarWhereInput[]
  }

  export type StudentModel2UpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentModel2CreateWithoutSchoolInput, StudentModel2UncheckedCreateWithoutSchoolInput> | StudentModel2CreateWithoutSchoolInput[] | StudentModel2UncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentModel2CreateOrConnectWithoutSchoolInput | StudentModel2CreateOrConnectWithoutSchoolInput[]
    upsert?: StudentModel2UpsertWithWhereUniqueWithoutSchoolInput | StudentModel2UpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentModel2CreateManySchoolInputEnvelope
    set?: StudentModel2WhereUniqueInput | StudentModel2WhereUniqueInput[]
    disconnect?: StudentModel2WhereUniqueInput | StudentModel2WhereUniqueInput[]
    delete?: StudentModel2WhereUniqueInput | StudentModel2WhereUniqueInput[]
    connect?: StudentModel2WhereUniqueInput | StudentModel2WhereUniqueInput[]
    update?: StudentModel2UpdateWithWhereUniqueWithoutSchoolInput | StudentModel2UpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentModel2UpdateManyWithWhereWithoutSchoolInput | StudentModel2UpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentModel2ScalarWhereInput | StudentModel2ScalarWhereInput[]
  }

  export type EloquenceEnglishUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EloquenceEnglishCreateWithoutSchoolInput, EloquenceEnglishUncheckedCreateWithoutSchoolInput> | EloquenceEnglishCreateWithoutSchoolInput[] | EloquenceEnglishUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceEnglishCreateOrConnectWithoutSchoolInput | EloquenceEnglishCreateOrConnectWithoutSchoolInput[]
    upsert?: EloquenceEnglishUpsertWithWhereUniqueWithoutSchoolInput | EloquenceEnglishUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EloquenceEnglishCreateManySchoolInputEnvelope
    set?: EloquenceEnglishWhereUniqueInput | EloquenceEnglishWhereUniqueInput[]
    disconnect?: EloquenceEnglishWhereUniqueInput | EloquenceEnglishWhereUniqueInput[]
    delete?: EloquenceEnglishWhereUniqueInput | EloquenceEnglishWhereUniqueInput[]
    connect?: EloquenceEnglishWhereUniqueInput | EloquenceEnglishWhereUniqueInput[]
    update?: EloquenceEnglishUpdateWithWhereUniqueWithoutSchoolInput | EloquenceEnglishUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EloquenceEnglishUpdateManyWithWhereWithoutSchoolInput | EloquenceEnglishUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EloquenceEnglishScalarWhereInput | EloquenceEnglishScalarWhereInput[]
  }

  export type EloquenceHindiUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EloquenceHindiCreateWithoutSchoolInput, EloquenceHindiUncheckedCreateWithoutSchoolInput> | EloquenceHindiCreateWithoutSchoolInput[] | EloquenceHindiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceHindiCreateOrConnectWithoutSchoolInput | EloquenceHindiCreateOrConnectWithoutSchoolInput[]
    upsert?: EloquenceHindiUpsertWithWhereUniqueWithoutSchoolInput | EloquenceHindiUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EloquenceHindiCreateManySchoolInputEnvelope
    set?: EloquenceHindiWhereUniqueInput | EloquenceHindiWhereUniqueInput[]
    disconnect?: EloquenceHindiWhereUniqueInput | EloquenceHindiWhereUniqueInput[]
    delete?: EloquenceHindiWhereUniqueInput | EloquenceHindiWhereUniqueInput[]
    connect?: EloquenceHindiWhereUniqueInput | EloquenceHindiWhereUniqueInput[]
    update?: EloquenceHindiUpdateWithWhereUniqueWithoutSchoolInput | EloquenceHindiUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EloquenceHindiUpdateManyWithWhereWithoutSchoolInput | EloquenceHindiUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EloquenceHindiScalarWhereInput | EloquenceHindiScalarWhereInput[]
  }

  export type EloquenceGujaratiUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EloquenceGujaratiCreateWithoutSchoolInput, EloquenceGujaratiUncheckedCreateWithoutSchoolInput> | EloquenceGujaratiCreateWithoutSchoolInput[] | EloquenceGujaratiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceGujaratiCreateOrConnectWithoutSchoolInput | EloquenceGujaratiCreateOrConnectWithoutSchoolInput[]
    upsert?: EloquenceGujaratiUpsertWithWhereUniqueWithoutSchoolInput | EloquenceGujaratiUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EloquenceGujaratiCreateManySchoolInputEnvelope
    set?: EloquenceGujaratiWhereUniqueInput | EloquenceGujaratiWhereUniqueInput[]
    disconnect?: EloquenceGujaratiWhereUniqueInput | EloquenceGujaratiWhereUniqueInput[]
    delete?: EloquenceGujaratiWhereUniqueInput | EloquenceGujaratiWhereUniqueInput[]
    connect?: EloquenceGujaratiWhereUniqueInput | EloquenceGujaratiWhereUniqueInput[]
    update?: EloquenceGujaratiUpdateWithWhereUniqueWithoutSchoolInput | EloquenceGujaratiUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EloquenceGujaratiUpdateManyWithWhereWithoutSchoolInput | EloquenceGujaratiUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EloquenceGujaratiScalarWhereInput | EloquenceGujaratiScalarWhereInput[]
  }

  export type EssayEnglishUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EssayEnglishCreateWithoutSchoolInput, EssayEnglishUncheckedCreateWithoutSchoolInput> | EssayEnglishCreateWithoutSchoolInput[] | EssayEnglishUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayEnglishCreateOrConnectWithoutSchoolInput | EssayEnglishCreateOrConnectWithoutSchoolInput[]
    upsert?: EssayEnglishUpsertWithWhereUniqueWithoutSchoolInput | EssayEnglishUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EssayEnglishCreateManySchoolInputEnvelope
    set?: EssayEnglishWhereUniqueInput | EssayEnglishWhereUniqueInput[]
    disconnect?: EssayEnglishWhereUniqueInput | EssayEnglishWhereUniqueInput[]
    delete?: EssayEnglishWhereUniqueInput | EssayEnglishWhereUniqueInput[]
    connect?: EssayEnglishWhereUniqueInput | EssayEnglishWhereUniqueInput[]
    update?: EssayEnglishUpdateWithWhereUniqueWithoutSchoolInput | EssayEnglishUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EssayEnglishUpdateManyWithWhereWithoutSchoolInput | EssayEnglishUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EssayEnglishScalarWhereInput | EssayEnglishScalarWhereInput[]
  }

  export type EssayHindiUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EssayHindiCreateWithoutSchoolInput, EssayHindiUncheckedCreateWithoutSchoolInput> | EssayHindiCreateWithoutSchoolInput[] | EssayHindiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayHindiCreateOrConnectWithoutSchoolInput | EssayHindiCreateOrConnectWithoutSchoolInput[]
    upsert?: EssayHindiUpsertWithWhereUniqueWithoutSchoolInput | EssayHindiUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EssayHindiCreateManySchoolInputEnvelope
    set?: EssayHindiWhereUniqueInput | EssayHindiWhereUniqueInput[]
    disconnect?: EssayHindiWhereUniqueInput | EssayHindiWhereUniqueInput[]
    delete?: EssayHindiWhereUniqueInput | EssayHindiWhereUniqueInput[]
    connect?: EssayHindiWhereUniqueInput | EssayHindiWhereUniqueInput[]
    update?: EssayHindiUpdateWithWhereUniqueWithoutSchoolInput | EssayHindiUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EssayHindiUpdateManyWithWhereWithoutSchoolInput | EssayHindiUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EssayHindiScalarWhereInput | EssayHindiScalarWhereInput[]
  }

  export type EssayGujaratiUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EssayGujaratiCreateWithoutSchoolInput, EssayGujaratiUncheckedCreateWithoutSchoolInput> | EssayGujaratiCreateWithoutSchoolInput[] | EssayGujaratiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayGujaratiCreateOrConnectWithoutSchoolInput | EssayGujaratiCreateOrConnectWithoutSchoolInput[]
    upsert?: EssayGujaratiUpsertWithWhereUniqueWithoutSchoolInput | EssayGujaratiUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EssayGujaratiCreateManySchoolInputEnvelope
    set?: EssayGujaratiWhereUniqueInput | EssayGujaratiWhereUniqueInput[]
    disconnect?: EssayGujaratiWhereUniqueInput | EssayGujaratiWhereUniqueInput[]
    delete?: EssayGujaratiWhereUniqueInput | EssayGujaratiWhereUniqueInput[]
    connect?: EssayGujaratiWhereUniqueInput | EssayGujaratiWhereUniqueInput[]
    update?: EssayGujaratiUpdateWithWhereUniqueWithoutSchoolInput | EssayGujaratiUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EssayGujaratiUpdateManyWithWhereWithoutSchoolInput | EssayGujaratiUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EssayGujaratiScalarWhereInput | EssayGujaratiScalarWhereInput[]
  }

  export type PosterUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PosterCreateWithoutSchoolInput, PosterUncheckedCreateWithoutSchoolInput> | PosterCreateWithoutSchoolInput[] | PosterUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PosterCreateOrConnectWithoutSchoolInput | PosterCreateOrConnectWithoutSchoolInput[]
    upsert?: PosterUpsertWithWhereUniqueWithoutSchoolInput | PosterUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PosterCreateManySchoolInputEnvelope
    set?: PosterWhereUniqueInput | PosterWhereUniqueInput[]
    disconnect?: PosterWhereUniqueInput | PosterWhereUniqueInput[]
    delete?: PosterWhereUniqueInput | PosterWhereUniqueInput[]
    connect?: PosterWhereUniqueInput | PosterWhereUniqueInput[]
    update?: PosterUpdateWithWhereUniqueWithoutSchoolInput | PosterUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PosterUpdateManyWithWhereWithoutSchoolInput | PosterUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PosterScalarWhereInput | PosterScalarWhereInput[]
  }

  export type SkitUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SkitCreateWithoutSchoolInput, SkitUncheckedCreateWithoutSchoolInput> | SkitCreateWithoutSchoolInput[] | SkitUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SkitCreateOrConnectWithoutSchoolInput | SkitCreateOrConnectWithoutSchoolInput[]
    upsert?: SkitUpsertWithWhereUniqueWithoutSchoolInput | SkitUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SkitCreateManySchoolInputEnvelope
    set?: SkitWhereUniqueInput | SkitWhereUniqueInput[]
    disconnect?: SkitWhereUniqueInput | SkitWhereUniqueInput[]
    delete?: SkitWhereUniqueInput | SkitWhereUniqueInput[]
    connect?: SkitWhereUniqueInput | SkitWhereUniqueInput[]
    update?: SkitUpdateWithWhereUniqueWithoutSchoolInput | SkitUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SkitUpdateManyWithWhereWithoutSchoolInput | SkitUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SkitScalarWhereInput | SkitScalarWhereInput[]
  }

  export type TeacherModelUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TeacherModelCreateWithoutSchoolInput, TeacherModelUncheckedCreateWithoutSchoolInput> | TeacherModelCreateWithoutSchoolInput[] | TeacherModelUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherModelCreateOrConnectWithoutSchoolInput | TeacherModelCreateOrConnectWithoutSchoolInput[]
    upsert?: TeacherModelUpsertWithWhereUniqueWithoutSchoolInput | TeacherModelUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TeacherModelCreateManySchoolInputEnvelope
    set?: TeacherModelWhereUniqueInput | TeacherModelWhereUniqueInput[]
    disconnect?: TeacherModelWhereUniqueInput | TeacherModelWhereUniqueInput[]
    delete?: TeacherModelWhereUniqueInput | TeacherModelWhereUniqueInput[]
    connect?: TeacherModelWhereUniqueInput | TeacherModelWhereUniqueInput[]
    update?: TeacherModelUpdateWithWhereUniqueWithoutSchoolInput | TeacherModelUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TeacherModelUpdateManyWithWhereWithoutSchoolInput | TeacherModelUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TeacherModelScalarWhereInput | TeacherModelScalarWhereInput[]
  }

  export type AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AccompanyingTeacherCreateWithoutSchoolInput, AccompanyingTeacherUncheckedCreateWithoutSchoolInput> | AccompanyingTeacherCreateWithoutSchoolInput[] | AccompanyingTeacherUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AccompanyingTeacherCreateOrConnectWithoutSchoolInput | AccompanyingTeacherCreateOrConnectWithoutSchoolInput[]
    upsert?: AccompanyingTeacherUpsertWithWhereUniqueWithoutSchoolInput | AccompanyingTeacherUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AccompanyingTeacherCreateManySchoolInputEnvelope
    set?: AccompanyingTeacherWhereUniqueInput | AccompanyingTeacherWhereUniqueInput[]
    disconnect?: AccompanyingTeacherWhereUniqueInput | AccompanyingTeacherWhereUniqueInput[]
    delete?: AccompanyingTeacherWhereUniqueInput | AccompanyingTeacherWhereUniqueInput[]
    connect?: AccompanyingTeacherWhereUniqueInput | AccompanyingTeacherWhereUniqueInput[]
    update?: AccompanyingTeacherUpdateWithWhereUniqueWithoutSchoolInput | AccompanyingTeacherUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AccompanyingTeacherUpdateManyWithWhereWithoutSchoolInput | AccompanyingTeacherUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AccompanyingTeacherScalarWhereInput | AccompanyingTeacherScalarWhereInput[]
  }

  export type CompetitionUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<CompetitionCreateWithoutSchoolInput, CompetitionUncheckedCreateWithoutSchoolInput> | CompetitionCreateWithoutSchoolInput[] | CompetitionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: CompetitionCreateOrConnectWithoutSchoolInput | CompetitionCreateOrConnectWithoutSchoolInput[]
    upsert?: CompetitionUpsertWithWhereUniqueWithoutSchoolInput | CompetitionUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: CompetitionCreateManySchoolInputEnvelope
    set?: CompetitionWhereUniqueInput | CompetitionWhereUniqueInput[]
    disconnect?: CompetitionWhereUniqueInput | CompetitionWhereUniqueInput[]
    delete?: CompetitionWhereUniqueInput | CompetitionWhereUniqueInput[]
    connect?: CompetitionWhereUniqueInput | CompetitionWhereUniqueInput[]
    update?: CompetitionUpdateWithWhereUniqueWithoutSchoolInput | CompetitionUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: CompetitionUpdateManyWithWhereWithoutSchoolInput | CompetitionUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: CompetitionScalarWhereInput | CompetitionScalarWhereInput[]
  }

  export type StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentModel1CreateWithoutSchoolInput, StudentModel1UncheckedCreateWithoutSchoolInput> | StudentModel1CreateWithoutSchoolInput[] | StudentModel1UncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentModel1CreateOrConnectWithoutSchoolInput | StudentModel1CreateOrConnectWithoutSchoolInput[]
    upsert?: StudentModel1UpsertWithWhereUniqueWithoutSchoolInput | StudentModel1UpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentModel1CreateManySchoolInputEnvelope
    set?: StudentModel1WhereUniqueInput | StudentModel1WhereUniqueInput[]
    disconnect?: StudentModel1WhereUniqueInput | StudentModel1WhereUniqueInput[]
    delete?: StudentModel1WhereUniqueInput | StudentModel1WhereUniqueInput[]
    connect?: StudentModel1WhereUniqueInput | StudentModel1WhereUniqueInput[]
    update?: StudentModel1UpdateWithWhereUniqueWithoutSchoolInput | StudentModel1UpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentModel1UpdateManyWithWhereWithoutSchoolInput | StudentModel1UpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentModel1ScalarWhereInput | StudentModel1ScalarWhereInput[]
  }

  export type StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentModel2CreateWithoutSchoolInput, StudentModel2UncheckedCreateWithoutSchoolInput> | StudentModel2CreateWithoutSchoolInput[] | StudentModel2UncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentModel2CreateOrConnectWithoutSchoolInput | StudentModel2CreateOrConnectWithoutSchoolInput[]
    upsert?: StudentModel2UpsertWithWhereUniqueWithoutSchoolInput | StudentModel2UpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentModel2CreateManySchoolInputEnvelope
    set?: StudentModel2WhereUniqueInput | StudentModel2WhereUniqueInput[]
    disconnect?: StudentModel2WhereUniqueInput | StudentModel2WhereUniqueInput[]
    delete?: StudentModel2WhereUniqueInput | StudentModel2WhereUniqueInput[]
    connect?: StudentModel2WhereUniqueInput | StudentModel2WhereUniqueInput[]
    update?: StudentModel2UpdateWithWhereUniqueWithoutSchoolInput | StudentModel2UpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentModel2UpdateManyWithWhereWithoutSchoolInput | StudentModel2UpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentModel2ScalarWhereInput | StudentModel2ScalarWhereInput[]
  }

  export type EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EloquenceEnglishCreateWithoutSchoolInput, EloquenceEnglishUncheckedCreateWithoutSchoolInput> | EloquenceEnglishCreateWithoutSchoolInput[] | EloquenceEnglishUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceEnglishCreateOrConnectWithoutSchoolInput | EloquenceEnglishCreateOrConnectWithoutSchoolInput[]
    upsert?: EloquenceEnglishUpsertWithWhereUniqueWithoutSchoolInput | EloquenceEnglishUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EloquenceEnglishCreateManySchoolInputEnvelope
    set?: EloquenceEnglishWhereUniqueInput | EloquenceEnglishWhereUniqueInput[]
    disconnect?: EloquenceEnglishWhereUniqueInput | EloquenceEnglishWhereUniqueInput[]
    delete?: EloquenceEnglishWhereUniqueInput | EloquenceEnglishWhereUniqueInput[]
    connect?: EloquenceEnglishWhereUniqueInput | EloquenceEnglishWhereUniqueInput[]
    update?: EloquenceEnglishUpdateWithWhereUniqueWithoutSchoolInput | EloquenceEnglishUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EloquenceEnglishUpdateManyWithWhereWithoutSchoolInput | EloquenceEnglishUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EloquenceEnglishScalarWhereInput | EloquenceEnglishScalarWhereInput[]
  }

  export type EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EloquenceHindiCreateWithoutSchoolInput, EloquenceHindiUncheckedCreateWithoutSchoolInput> | EloquenceHindiCreateWithoutSchoolInput[] | EloquenceHindiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceHindiCreateOrConnectWithoutSchoolInput | EloquenceHindiCreateOrConnectWithoutSchoolInput[]
    upsert?: EloquenceHindiUpsertWithWhereUniqueWithoutSchoolInput | EloquenceHindiUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EloquenceHindiCreateManySchoolInputEnvelope
    set?: EloquenceHindiWhereUniqueInput | EloquenceHindiWhereUniqueInput[]
    disconnect?: EloquenceHindiWhereUniqueInput | EloquenceHindiWhereUniqueInput[]
    delete?: EloquenceHindiWhereUniqueInput | EloquenceHindiWhereUniqueInput[]
    connect?: EloquenceHindiWhereUniqueInput | EloquenceHindiWhereUniqueInput[]
    update?: EloquenceHindiUpdateWithWhereUniqueWithoutSchoolInput | EloquenceHindiUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EloquenceHindiUpdateManyWithWhereWithoutSchoolInput | EloquenceHindiUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EloquenceHindiScalarWhereInput | EloquenceHindiScalarWhereInput[]
  }

  export type EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EloquenceGujaratiCreateWithoutSchoolInput, EloquenceGujaratiUncheckedCreateWithoutSchoolInput> | EloquenceGujaratiCreateWithoutSchoolInput[] | EloquenceGujaratiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EloquenceGujaratiCreateOrConnectWithoutSchoolInput | EloquenceGujaratiCreateOrConnectWithoutSchoolInput[]
    upsert?: EloquenceGujaratiUpsertWithWhereUniqueWithoutSchoolInput | EloquenceGujaratiUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EloquenceGujaratiCreateManySchoolInputEnvelope
    set?: EloquenceGujaratiWhereUniqueInput | EloquenceGujaratiWhereUniqueInput[]
    disconnect?: EloquenceGujaratiWhereUniqueInput | EloquenceGujaratiWhereUniqueInput[]
    delete?: EloquenceGujaratiWhereUniqueInput | EloquenceGujaratiWhereUniqueInput[]
    connect?: EloquenceGujaratiWhereUniqueInput | EloquenceGujaratiWhereUniqueInput[]
    update?: EloquenceGujaratiUpdateWithWhereUniqueWithoutSchoolInput | EloquenceGujaratiUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EloquenceGujaratiUpdateManyWithWhereWithoutSchoolInput | EloquenceGujaratiUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EloquenceGujaratiScalarWhereInput | EloquenceGujaratiScalarWhereInput[]
  }

  export type EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EssayEnglishCreateWithoutSchoolInput, EssayEnglishUncheckedCreateWithoutSchoolInput> | EssayEnglishCreateWithoutSchoolInput[] | EssayEnglishUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayEnglishCreateOrConnectWithoutSchoolInput | EssayEnglishCreateOrConnectWithoutSchoolInput[]
    upsert?: EssayEnglishUpsertWithWhereUniqueWithoutSchoolInput | EssayEnglishUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EssayEnglishCreateManySchoolInputEnvelope
    set?: EssayEnglishWhereUniqueInput | EssayEnglishWhereUniqueInput[]
    disconnect?: EssayEnglishWhereUniqueInput | EssayEnglishWhereUniqueInput[]
    delete?: EssayEnglishWhereUniqueInput | EssayEnglishWhereUniqueInput[]
    connect?: EssayEnglishWhereUniqueInput | EssayEnglishWhereUniqueInput[]
    update?: EssayEnglishUpdateWithWhereUniqueWithoutSchoolInput | EssayEnglishUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EssayEnglishUpdateManyWithWhereWithoutSchoolInput | EssayEnglishUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EssayEnglishScalarWhereInput | EssayEnglishScalarWhereInput[]
  }

  export type EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EssayHindiCreateWithoutSchoolInput, EssayHindiUncheckedCreateWithoutSchoolInput> | EssayHindiCreateWithoutSchoolInput[] | EssayHindiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayHindiCreateOrConnectWithoutSchoolInput | EssayHindiCreateOrConnectWithoutSchoolInput[]
    upsert?: EssayHindiUpsertWithWhereUniqueWithoutSchoolInput | EssayHindiUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EssayHindiCreateManySchoolInputEnvelope
    set?: EssayHindiWhereUniqueInput | EssayHindiWhereUniqueInput[]
    disconnect?: EssayHindiWhereUniqueInput | EssayHindiWhereUniqueInput[]
    delete?: EssayHindiWhereUniqueInput | EssayHindiWhereUniqueInput[]
    connect?: EssayHindiWhereUniqueInput | EssayHindiWhereUniqueInput[]
    update?: EssayHindiUpdateWithWhereUniqueWithoutSchoolInput | EssayHindiUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EssayHindiUpdateManyWithWhereWithoutSchoolInput | EssayHindiUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EssayHindiScalarWhereInput | EssayHindiScalarWhereInput[]
  }

  export type EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EssayGujaratiCreateWithoutSchoolInput, EssayGujaratiUncheckedCreateWithoutSchoolInput> | EssayGujaratiCreateWithoutSchoolInput[] | EssayGujaratiUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EssayGujaratiCreateOrConnectWithoutSchoolInput | EssayGujaratiCreateOrConnectWithoutSchoolInput[]
    upsert?: EssayGujaratiUpsertWithWhereUniqueWithoutSchoolInput | EssayGujaratiUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EssayGujaratiCreateManySchoolInputEnvelope
    set?: EssayGujaratiWhereUniqueInput | EssayGujaratiWhereUniqueInput[]
    disconnect?: EssayGujaratiWhereUniqueInput | EssayGujaratiWhereUniqueInput[]
    delete?: EssayGujaratiWhereUniqueInput | EssayGujaratiWhereUniqueInput[]
    connect?: EssayGujaratiWhereUniqueInput | EssayGujaratiWhereUniqueInput[]
    update?: EssayGujaratiUpdateWithWhereUniqueWithoutSchoolInput | EssayGujaratiUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EssayGujaratiUpdateManyWithWhereWithoutSchoolInput | EssayGujaratiUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EssayGujaratiScalarWhereInput | EssayGujaratiScalarWhereInput[]
  }

  export type PosterUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PosterCreateWithoutSchoolInput, PosterUncheckedCreateWithoutSchoolInput> | PosterCreateWithoutSchoolInput[] | PosterUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PosterCreateOrConnectWithoutSchoolInput | PosterCreateOrConnectWithoutSchoolInput[]
    upsert?: PosterUpsertWithWhereUniqueWithoutSchoolInput | PosterUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PosterCreateManySchoolInputEnvelope
    set?: PosterWhereUniqueInput | PosterWhereUniqueInput[]
    disconnect?: PosterWhereUniqueInput | PosterWhereUniqueInput[]
    delete?: PosterWhereUniqueInput | PosterWhereUniqueInput[]
    connect?: PosterWhereUniqueInput | PosterWhereUniqueInput[]
    update?: PosterUpdateWithWhereUniqueWithoutSchoolInput | PosterUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PosterUpdateManyWithWhereWithoutSchoolInput | PosterUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PosterScalarWhereInput | PosterScalarWhereInput[]
  }

  export type SkitUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SkitCreateWithoutSchoolInput, SkitUncheckedCreateWithoutSchoolInput> | SkitCreateWithoutSchoolInput[] | SkitUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SkitCreateOrConnectWithoutSchoolInput | SkitCreateOrConnectWithoutSchoolInput[]
    upsert?: SkitUpsertWithWhereUniqueWithoutSchoolInput | SkitUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SkitCreateManySchoolInputEnvelope
    set?: SkitWhereUniqueInput | SkitWhereUniqueInput[]
    disconnect?: SkitWhereUniqueInput | SkitWhereUniqueInput[]
    delete?: SkitWhereUniqueInput | SkitWhereUniqueInput[]
    connect?: SkitWhereUniqueInput | SkitWhereUniqueInput[]
    update?: SkitUpdateWithWhereUniqueWithoutSchoolInput | SkitUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SkitUpdateManyWithWhereWithoutSchoolInput | SkitUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SkitScalarWhereInput | SkitScalarWhereInput[]
  }

  export type TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TeacherModelCreateWithoutSchoolInput, TeacherModelUncheckedCreateWithoutSchoolInput> | TeacherModelCreateWithoutSchoolInput[] | TeacherModelUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherModelCreateOrConnectWithoutSchoolInput | TeacherModelCreateOrConnectWithoutSchoolInput[]
    upsert?: TeacherModelUpsertWithWhereUniqueWithoutSchoolInput | TeacherModelUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TeacherModelCreateManySchoolInputEnvelope
    set?: TeacherModelWhereUniqueInput | TeacherModelWhereUniqueInput[]
    disconnect?: TeacherModelWhereUniqueInput | TeacherModelWhereUniqueInput[]
    delete?: TeacherModelWhereUniqueInput | TeacherModelWhereUniqueInput[]
    connect?: TeacherModelWhereUniqueInput | TeacherModelWhereUniqueInput[]
    update?: TeacherModelUpdateWithWhereUniqueWithoutSchoolInput | TeacherModelUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TeacherModelUpdateManyWithWhereWithoutSchoolInput | TeacherModelUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TeacherModelScalarWhereInput | TeacherModelScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutAccompanyingTeachersInput = {
    create?: XOR<SchoolCreateWithoutAccompanyingTeachersInput, SchoolUncheckedCreateWithoutAccompanyingTeachersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAccompanyingTeachersInput
    connect?: SchoolWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SchoolUpdateOneRequiredWithoutAccompanyingTeachersNestedInput = {
    create?: XOR<SchoolCreateWithoutAccompanyingTeachersInput, SchoolUncheckedCreateWithoutAccompanyingTeachersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAccompanyingTeachersInput
    upsert?: SchoolUpsertWithoutAccompanyingTeachersInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutAccompanyingTeachersInput, SchoolUpdateWithoutAccompanyingTeachersInput>, SchoolUncheckedUpdateWithoutAccompanyingTeachersInput>
  }

  export type SchoolCreateNestedOneWithoutCompetitionsInput = {
    create?: XOR<SchoolCreateWithoutCompetitionsInput, SchoolUncheckedCreateWithoutCompetitionsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutCompetitionsInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutCompetitionsNestedInput = {
    create?: XOR<SchoolCreateWithoutCompetitionsInput, SchoolUncheckedCreateWithoutCompetitionsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutCompetitionsInput
    upsert?: SchoolUpsertWithoutCompetitionsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutCompetitionsInput, SchoolUpdateWithoutCompetitionsInput>, SchoolUncheckedUpdateWithoutCompetitionsInput>
  }

  export type SchoolCreateNestedOneWithoutStudentModel1Input = {
    create?: XOR<SchoolCreateWithoutStudentModel1Input, SchoolUncheckedCreateWithoutStudentModel1Input>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentModel1Input
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutStudentModel1NestedInput = {
    create?: XOR<SchoolCreateWithoutStudentModel1Input, SchoolUncheckedCreateWithoutStudentModel1Input>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentModel1Input
    upsert?: SchoolUpsertWithoutStudentModel1Input
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutStudentModel1Input, SchoolUpdateWithoutStudentModel1Input>, SchoolUncheckedUpdateWithoutStudentModel1Input>
  }

  export type SchoolCreateNestedOneWithoutStudentModel2Input = {
    create?: XOR<SchoolCreateWithoutStudentModel2Input, SchoolUncheckedCreateWithoutStudentModel2Input>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentModel2Input
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutStudentModel2NestedInput = {
    create?: XOR<SchoolCreateWithoutStudentModel2Input, SchoolUncheckedCreateWithoutStudentModel2Input>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentModel2Input
    upsert?: SchoolUpsertWithoutStudentModel2Input
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutStudentModel2Input, SchoolUpdateWithoutStudentModel2Input>, SchoolUncheckedUpdateWithoutStudentModel2Input>
  }

  export type SchoolCreateNestedOneWithoutEloquenceEnglishInput = {
    create?: XOR<SchoolCreateWithoutEloquenceEnglishInput, SchoolUncheckedCreateWithoutEloquenceEnglishInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEloquenceEnglishInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutEloquenceEnglishNestedInput = {
    create?: XOR<SchoolCreateWithoutEloquenceEnglishInput, SchoolUncheckedCreateWithoutEloquenceEnglishInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEloquenceEnglishInput
    upsert?: SchoolUpsertWithoutEloquenceEnglishInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutEloquenceEnglishInput, SchoolUpdateWithoutEloquenceEnglishInput>, SchoolUncheckedUpdateWithoutEloquenceEnglishInput>
  }

  export type SchoolCreateNestedOneWithoutEloquenceHindiInput = {
    create?: XOR<SchoolCreateWithoutEloquenceHindiInput, SchoolUncheckedCreateWithoutEloquenceHindiInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEloquenceHindiInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutEloquenceHindiNestedInput = {
    create?: XOR<SchoolCreateWithoutEloquenceHindiInput, SchoolUncheckedCreateWithoutEloquenceHindiInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEloquenceHindiInput
    upsert?: SchoolUpsertWithoutEloquenceHindiInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutEloquenceHindiInput, SchoolUpdateWithoutEloquenceHindiInput>, SchoolUncheckedUpdateWithoutEloquenceHindiInput>
  }

  export type SchoolCreateNestedOneWithoutEloquenceGujaratiInput = {
    create?: XOR<SchoolCreateWithoutEloquenceGujaratiInput, SchoolUncheckedCreateWithoutEloquenceGujaratiInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEloquenceGujaratiInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutEloquenceGujaratiNestedInput = {
    create?: XOR<SchoolCreateWithoutEloquenceGujaratiInput, SchoolUncheckedCreateWithoutEloquenceGujaratiInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEloquenceGujaratiInput
    upsert?: SchoolUpsertWithoutEloquenceGujaratiInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutEloquenceGujaratiInput, SchoolUpdateWithoutEloquenceGujaratiInput>, SchoolUncheckedUpdateWithoutEloquenceGujaratiInput>
  }

  export type SchoolCreateNestedOneWithoutEssayEnglishInput = {
    create?: XOR<SchoolCreateWithoutEssayEnglishInput, SchoolUncheckedCreateWithoutEssayEnglishInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEssayEnglishInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutEssayEnglishNestedInput = {
    create?: XOR<SchoolCreateWithoutEssayEnglishInput, SchoolUncheckedCreateWithoutEssayEnglishInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEssayEnglishInput
    upsert?: SchoolUpsertWithoutEssayEnglishInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutEssayEnglishInput, SchoolUpdateWithoutEssayEnglishInput>, SchoolUncheckedUpdateWithoutEssayEnglishInput>
  }

  export type SchoolCreateNestedOneWithoutEssayHindiInput = {
    create?: XOR<SchoolCreateWithoutEssayHindiInput, SchoolUncheckedCreateWithoutEssayHindiInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEssayHindiInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutEssayHindiNestedInput = {
    create?: XOR<SchoolCreateWithoutEssayHindiInput, SchoolUncheckedCreateWithoutEssayHindiInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEssayHindiInput
    upsert?: SchoolUpsertWithoutEssayHindiInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutEssayHindiInput, SchoolUpdateWithoutEssayHindiInput>, SchoolUncheckedUpdateWithoutEssayHindiInput>
  }

  export type SchoolCreateNestedOneWithoutEssayGujaratiInput = {
    create?: XOR<SchoolCreateWithoutEssayGujaratiInput, SchoolUncheckedCreateWithoutEssayGujaratiInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEssayGujaratiInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutEssayGujaratiNestedInput = {
    create?: XOR<SchoolCreateWithoutEssayGujaratiInput, SchoolUncheckedCreateWithoutEssayGujaratiInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEssayGujaratiInput
    upsert?: SchoolUpsertWithoutEssayGujaratiInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutEssayGujaratiInput, SchoolUpdateWithoutEssayGujaratiInput>, SchoolUncheckedUpdateWithoutEssayGujaratiInput>
  }

  export type SchoolCreateNestedOneWithoutPosterInput = {
    create?: XOR<SchoolCreateWithoutPosterInput, SchoolUncheckedCreateWithoutPosterInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPosterInput
    connect?: SchoolWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type SchoolUpdateOneRequiredWithoutPosterNestedInput = {
    create?: XOR<SchoolCreateWithoutPosterInput, SchoolUncheckedCreateWithoutPosterInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPosterInput
    upsert?: SchoolUpsertWithoutPosterInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutPosterInput, SchoolUpdateWithoutPosterInput>, SchoolUncheckedUpdateWithoutPosterInput>
  }

  export type SchoolCreateNestedOneWithoutSkitInput = {
    create?: XOR<SchoolCreateWithoutSkitInput, SchoolUncheckedCreateWithoutSkitInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSkitInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutSkitNestedInput = {
    create?: XOR<SchoolCreateWithoutSkitInput, SchoolUncheckedCreateWithoutSkitInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSkitInput
    upsert?: SchoolUpsertWithoutSkitInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSkitInput, SchoolUpdateWithoutSkitInput>, SchoolUncheckedUpdateWithoutSkitInput>
  }

  export type SchoolCreateNestedOneWithoutTeacherModelInput = {
    create?: XOR<SchoolCreateWithoutTeacherModelInput, SchoolUncheckedCreateWithoutTeacherModelInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTeacherModelInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutTeacherModelNestedInput = {
    create?: XOR<SchoolCreateWithoutTeacherModelInput, SchoolUncheckedCreateWithoutTeacherModelInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTeacherModelInput
    upsert?: SchoolUpsertWithoutTeacherModelInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutTeacherModelInput, SchoolUpdateWithoutTeacherModelInput>, SchoolUncheckedUpdateWithoutTeacherModelInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type feedbackFormCreateWithoutRatingsInput = {
    institutionName: string
    website: string
    visitDate: Date | string
    staffName: string
    staffEmail: string
    staffMobile: string
    totalStudents: number
    accompanyingStaff: number
    sources?: feedbackFormCreatesourcesInput | string[]
    campuses?: feedbackFormCreatecampusesInput | string[]
    best?: string | null
    worst?: string | null
    suggestions?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbackFormUncheckedCreateWithoutRatingsInput = {
    id?: number
    institutionName: string
    website: string
    visitDate: Date | string
    staffName: string
    staffEmail: string
    staffMobile: string
    totalStudents: number
    accompanyingStaff: number
    sources?: feedbackFormCreatesourcesInput | string[]
    campuses?: feedbackFormCreatecampusesInput | string[]
    best?: string | null
    worst?: string | null
    suggestions?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbackFormCreateOrConnectWithoutRatingsInput = {
    where: feedbackFormWhereUniqueInput
    create: XOR<feedbackFormCreateWithoutRatingsInput, feedbackFormUncheckedCreateWithoutRatingsInput>
  }

  export type feedbackFormUpsertWithoutRatingsInput = {
    update: XOR<feedbackFormUpdateWithoutRatingsInput, feedbackFormUncheckedUpdateWithoutRatingsInput>
    create: XOR<feedbackFormCreateWithoutRatingsInput, feedbackFormUncheckedCreateWithoutRatingsInput>
    where?: feedbackFormWhereInput
  }

  export type feedbackFormUpdateToOneWithWhereWithoutRatingsInput = {
    where?: feedbackFormWhereInput
    data: XOR<feedbackFormUpdateWithoutRatingsInput, feedbackFormUncheckedUpdateWithoutRatingsInput>
  }

  export type feedbackFormUpdateWithoutRatingsInput = {
    institutionName?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffName?: StringFieldUpdateOperationsInput | string
    staffEmail?: StringFieldUpdateOperationsInput | string
    staffMobile?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    accompanyingStaff?: IntFieldUpdateOperationsInput | number
    sources?: feedbackFormUpdatesourcesInput | string[]
    campuses?: feedbackFormUpdatecampusesInput | string[]
    best?: NullableStringFieldUpdateOperationsInput | string | null
    worst?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbackFormUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    institutionName?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    staffName?: StringFieldUpdateOperationsInput | string
    staffEmail?: StringFieldUpdateOperationsInput | string
    staffMobile?: StringFieldUpdateOperationsInput | string
    totalStudents?: IntFieldUpdateOperationsInput | number
    accompanyingStaff?: IntFieldUpdateOperationsInput | number
    sources?: feedbackFormUpdatesourcesInput | string[]
    campuses?: feedbackFormUpdatecampusesInput | string[]
    best?: NullableStringFieldUpdateOperationsInput | string | null
    worst?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingsCreateWithoutFeedbackFormInput = {
    iprRating: number
    fciptRating: number
    knowledge: number
    explanationsIPR: number
    explanationsFCIPT: number
    knowledgeBefore: number
    knowledgeAfter: number
    technicalContents: number
    easeOfUnderstanding: number
  }

  export type RatingsUncheckedCreateWithoutFeedbackFormInput = {
    id?: number
    iprRating: number
    fciptRating: number
    knowledge: number
    explanationsIPR: number
    explanationsFCIPT: number
    knowledgeBefore: number
    knowledgeAfter: number
    technicalContents: number
    easeOfUnderstanding: number
  }

  export type RatingsCreateOrConnectWithoutFeedbackFormInput = {
    where: RatingsWhereUniqueInput
    create: XOR<RatingsCreateWithoutFeedbackFormInput, RatingsUncheckedCreateWithoutFeedbackFormInput>
  }

  export type RatingsUpsertWithoutFeedbackFormInput = {
    update: XOR<RatingsUpdateWithoutFeedbackFormInput, RatingsUncheckedUpdateWithoutFeedbackFormInput>
    create: XOR<RatingsCreateWithoutFeedbackFormInput, RatingsUncheckedCreateWithoutFeedbackFormInput>
    where?: RatingsWhereInput
  }

  export type RatingsUpdateToOneWithWhereWithoutFeedbackFormInput = {
    where?: RatingsWhereInput
    data: XOR<RatingsUpdateWithoutFeedbackFormInput, RatingsUncheckedUpdateWithoutFeedbackFormInput>
  }

  export type RatingsUpdateWithoutFeedbackFormInput = {
    iprRating?: IntFieldUpdateOperationsInput | number
    fciptRating?: IntFieldUpdateOperationsInput | number
    knowledge?: IntFieldUpdateOperationsInput | number
    explanationsIPR?: IntFieldUpdateOperationsInput | number
    explanationsFCIPT?: IntFieldUpdateOperationsInput | number
    knowledgeBefore?: IntFieldUpdateOperationsInput | number
    knowledgeAfter?: IntFieldUpdateOperationsInput | number
    technicalContents?: IntFieldUpdateOperationsInput | number
    easeOfUnderstanding?: IntFieldUpdateOperationsInput | number
  }

  export type RatingsUncheckedUpdateWithoutFeedbackFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    iprRating?: IntFieldUpdateOperationsInput | number
    fciptRating?: IntFieldUpdateOperationsInput | number
    knowledge?: IntFieldUpdateOperationsInput | number
    explanationsIPR?: IntFieldUpdateOperationsInput | number
    explanationsFCIPT?: IntFieldUpdateOperationsInput | number
    knowledgeBefore?: IntFieldUpdateOperationsInput | number
    knowledgeAfter?: IntFieldUpdateOperationsInput | number
    technicalContents?: IntFieldUpdateOperationsInput | number
    easeOfUnderstanding?: IntFieldUpdateOperationsInput | number
  }

  export type AccompanyingTeacherCreateWithoutSchoolInput = {
    name: string
    gender: string
    requiresAccommodation: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccompanyingTeacherUncheckedCreateWithoutSchoolInput = {
    id?: number
    name: string
    gender: string
    requiresAccommodation: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccompanyingTeacherCreateOrConnectWithoutSchoolInput = {
    where: AccompanyingTeacherWhereUniqueInput
    create: XOR<AccompanyingTeacherCreateWithoutSchoolInput, AccompanyingTeacherUncheckedCreateWithoutSchoolInput>
  }

  export type AccompanyingTeacherCreateManySchoolInputEnvelope = {
    data: AccompanyingTeacherCreateManySchoolInput | AccompanyingTeacherCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type CompetitionCreateWithoutSchoolInput = {
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitionUncheckedCreateWithoutSchoolInput = {
    id?: number
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitionCreateOrConnectWithoutSchoolInput = {
    where: CompetitionWhereUniqueInput
    create: XOR<CompetitionCreateWithoutSchoolInput, CompetitionUncheckedCreateWithoutSchoolInput>
  }

  export type CompetitionCreateManySchoolInputEnvelope = {
    data: CompetitionCreateManySchoolInput | CompetitionCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type StudentModel1CreateWithoutSchoolInput = {
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentModel1UncheckedCreateWithoutSchoolInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentModel1CreateOrConnectWithoutSchoolInput = {
    where: StudentModel1WhereUniqueInput
    create: XOR<StudentModel1CreateWithoutSchoolInput, StudentModel1UncheckedCreateWithoutSchoolInput>
  }

  export type StudentModel1CreateManySchoolInputEnvelope = {
    data: StudentModel1CreateManySchoolInput | StudentModel1CreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type StudentModel2CreateWithoutSchoolInput = {
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentModel2UncheckedCreateWithoutSchoolInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentModel2CreateOrConnectWithoutSchoolInput = {
    where: StudentModel2WhereUniqueInput
    create: XOR<StudentModel2CreateWithoutSchoolInput, StudentModel2UncheckedCreateWithoutSchoolInput>
  }

  export type StudentModel2CreateManySchoolInputEnvelope = {
    data: StudentModel2CreateManySchoolInput | StudentModel2CreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type EloquenceEnglishCreateWithoutSchoolInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceEnglishUncheckedCreateWithoutSchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceEnglishCreateOrConnectWithoutSchoolInput = {
    where: EloquenceEnglishWhereUniqueInput
    create: XOR<EloquenceEnglishCreateWithoutSchoolInput, EloquenceEnglishUncheckedCreateWithoutSchoolInput>
  }

  export type EloquenceEnglishCreateManySchoolInputEnvelope = {
    data: EloquenceEnglishCreateManySchoolInput | EloquenceEnglishCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type EloquenceHindiCreateWithoutSchoolInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceHindiUncheckedCreateWithoutSchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceHindiCreateOrConnectWithoutSchoolInput = {
    where: EloquenceHindiWhereUniqueInput
    create: XOR<EloquenceHindiCreateWithoutSchoolInput, EloquenceHindiUncheckedCreateWithoutSchoolInput>
  }

  export type EloquenceHindiCreateManySchoolInputEnvelope = {
    data: EloquenceHindiCreateManySchoolInput | EloquenceHindiCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type EloquenceGujaratiCreateWithoutSchoolInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceGujaratiUncheckedCreateWithoutSchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceGujaratiCreateOrConnectWithoutSchoolInput = {
    where: EloquenceGujaratiWhereUniqueInput
    create: XOR<EloquenceGujaratiCreateWithoutSchoolInput, EloquenceGujaratiUncheckedCreateWithoutSchoolInput>
  }

  export type EloquenceGujaratiCreateManySchoolInputEnvelope = {
    data: EloquenceGujaratiCreateManySchoolInput | EloquenceGujaratiCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type EssayEnglishCreateWithoutSchoolInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayEnglishUncheckedCreateWithoutSchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayEnglishCreateOrConnectWithoutSchoolInput = {
    where: EssayEnglishWhereUniqueInput
    create: XOR<EssayEnglishCreateWithoutSchoolInput, EssayEnglishUncheckedCreateWithoutSchoolInput>
  }

  export type EssayEnglishCreateManySchoolInputEnvelope = {
    data: EssayEnglishCreateManySchoolInput | EssayEnglishCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type EssayHindiCreateWithoutSchoolInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayHindiUncheckedCreateWithoutSchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayHindiCreateOrConnectWithoutSchoolInput = {
    where: EssayHindiWhereUniqueInput
    create: XOR<EssayHindiCreateWithoutSchoolInput, EssayHindiUncheckedCreateWithoutSchoolInput>
  }

  export type EssayHindiCreateManySchoolInputEnvelope = {
    data: EssayHindiCreateManySchoolInput | EssayHindiCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type EssayGujaratiCreateWithoutSchoolInput = {
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayGujaratiUncheckedCreateWithoutSchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayGujaratiCreateOrConnectWithoutSchoolInput = {
    where: EssayGujaratiWhereUniqueInput
    create: XOR<EssayGujaratiCreateWithoutSchoolInput, EssayGujaratiUncheckedCreateWithoutSchoolInput>
  }

  export type EssayGujaratiCreateManySchoolInputEnvelope = {
    data: EssayGujaratiCreateManySchoolInput | EssayGujaratiCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type PosterCreateWithoutSchoolInput = {
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant1Declaration: boolean
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant2Declaration?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosterUncheckedCreateWithoutSchoolInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant1Declaration: boolean
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant2Declaration?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosterCreateOrConnectWithoutSchoolInput = {
    where: PosterWhereUniqueInput
    create: XOR<PosterCreateWithoutSchoolInput, PosterUncheckedCreateWithoutSchoolInput>
  }

  export type PosterCreateManySchoolInputEnvelope = {
    data: PosterCreateManySchoolInput | PosterCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SkitCreateWithoutSchoolInput = {
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant3Name?: string | null
    participant3Gender?: string | null
    participant3Class?: string | null
    participant3Accommodation?: string | null
    participant4Name?: string | null
    participant4Gender?: string | null
    participant4Class?: string | null
    participant4Accommodation?: string | null
    participant5Name?: string | null
    participant5Gender?: string | null
    participant5Class?: string | null
    participant5Accommodation?: string | null
    participant6Name?: string | null
    participant6Gender?: string | null
    participant6Class?: string | null
    participant6Accommodation?: string | null
    additionalRequirements?: string | null
    declaration: boolean
    videoLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkitUncheckedCreateWithoutSchoolInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant3Name?: string | null
    participant3Gender?: string | null
    participant3Class?: string | null
    participant3Accommodation?: string | null
    participant4Name?: string | null
    participant4Gender?: string | null
    participant4Class?: string | null
    participant4Accommodation?: string | null
    participant5Name?: string | null
    participant5Gender?: string | null
    participant5Class?: string | null
    participant5Accommodation?: string | null
    participant6Name?: string | null
    participant6Gender?: string | null
    participant6Class?: string | null
    participant6Accommodation?: string | null
    additionalRequirements?: string | null
    declaration: boolean
    videoLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkitCreateOrConnectWithoutSchoolInput = {
    where: SkitWhereUniqueInput
    create: XOR<SkitCreateWithoutSchoolInput, SkitUncheckedCreateWithoutSchoolInput>
  }

  export type SkitCreateManySchoolInputEnvelope = {
    data: SkitCreateManySchoolInput | SkitCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type TeacherModelCreateWithoutSchoolInput = {
    teacherName: string
    teacherGender: string
    accommodationRequired: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherModelUncheckedCreateWithoutSchoolInput = {
    id?: number
    teacherName: string
    teacherGender: string
    accommodationRequired: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherModelCreateOrConnectWithoutSchoolInput = {
    where: TeacherModelWhereUniqueInput
    create: XOR<TeacherModelCreateWithoutSchoolInput, TeacherModelUncheckedCreateWithoutSchoolInput>
  }

  export type TeacherModelCreateManySchoolInputEnvelope = {
    data: TeacherModelCreateManySchoolInput | TeacherModelCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type AccompanyingTeacherUpsertWithWhereUniqueWithoutSchoolInput = {
    where: AccompanyingTeacherWhereUniqueInput
    update: XOR<AccompanyingTeacherUpdateWithoutSchoolInput, AccompanyingTeacherUncheckedUpdateWithoutSchoolInput>
    create: XOR<AccompanyingTeacherCreateWithoutSchoolInput, AccompanyingTeacherUncheckedCreateWithoutSchoolInput>
  }

  export type AccompanyingTeacherUpdateWithWhereUniqueWithoutSchoolInput = {
    where: AccompanyingTeacherWhereUniqueInput
    data: XOR<AccompanyingTeacherUpdateWithoutSchoolInput, AccompanyingTeacherUncheckedUpdateWithoutSchoolInput>
  }

  export type AccompanyingTeacherUpdateManyWithWhereWithoutSchoolInput = {
    where: AccompanyingTeacherScalarWhereInput
    data: XOR<AccompanyingTeacherUpdateManyMutationInput, AccompanyingTeacherUncheckedUpdateManyWithoutSchoolInput>
  }

  export type AccompanyingTeacherScalarWhereInput = {
    AND?: AccompanyingTeacherScalarWhereInput | AccompanyingTeacherScalarWhereInput[]
    OR?: AccompanyingTeacherScalarWhereInput[]
    NOT?: AccompanyingTeacherScalarWhereInput | AccompanyingTeacherScalarWhereInput[]
    id?: IntFilter<"AccompanyingTeacher"> | number
    name?: StringFilter<"AccompanyingTeacher"> | string
    gender?: StringFilter<"AccompanyingTeacher"> | string
    requiresAccommodation?: BoolFilter<"AccompanyingTeacher"> | boolean
    schoolId?: IntFilter<"AccompanyingTeacher"> | number
    createdAt?: DateTimeFilter<"AccompanyingTeacher"> | Date | string
    updatedAt?: DateTimeFilter<"AccompanyingTeacher"> | Date | string
  }

  export type CompetitionUpsertWithWhereUniqueWithoutSchoolInput = {
    where: CompetitionWhereUniqueInput
    update: XOR<CompetitionUpdateWithoutSchoolInput, CompetitionUncheckedUpdateWithoutSchoolInput>
    create: XOR<CompetitionCreateWithoutSchoolInput, CompetitionUncheckedCreateWithoutSchoolInput>
  }

  export type CompetitionUpdateWithWhereUniqueWithoutSchoolInput = {
    where: CompetitionWhereUniqueInput
    data: XOR<CompetitionUpdateWithoutSchoolInput, CompetitionUncheckedUpdateWithoutSchoolInput>
  }

  export type CompetitionUpdateManyWithWhereWithoutSchoolInput = {
    where: CompetitionScalarWhereInput
    data: XOR<CompetitionUpdateManyMutationInput, CompetitionUncheckedUpdateManyWithoutSchoolInput>
  }

  export type CompetitionScalarWhereInput = {
    AND?: CompetitionScalarWhereInput | CompetitionScalarWhereInput[]
    OR?: CompetitionScalarWhereInput[]
    NOT?: CompetitionScalarWhereInput | CompetitionScalarWhereInput[]
    id?: IntFilter<"Competition"> | number
    title?: StringFilter<"Competition"> | string
    schoolId?: IntFilter<"Competition"> | number
    createdAt?: DateTimeFilter<"Competition"> | Date | string
    updatedAt?: DateTimeFilter<"Competition"> | Date | string
  }

  export type StudentModel1UpsertWithWhereUniqueWithoutSchoolInput = {
    where: StudentModel1WhereUniqueInput
    update: XOR<StudentModel1UpdateWithoutSchoolInput, StudentModel1UncheckedUpdateWithoutSchoolInput>
    create: XOR<StudentModel1CreateWithoutSchoolInput, StudentModel1UncheckedCreateWithoutSchoolInput>
  }

  export type StudentModel1UpdateWithWhereUniqueWithoutSchoolInput = {
    where: StudentModel1WhereUniqueInput
    data: XOR<StudentModel1UpdateWithoutSchoolInput, StudentModel1UncheckedUpdateWithoutSchoolInput>
  }

  export type StudentModel1UpdateManyWithWhereWithoutSchoolInput = {
    where: StudentModel1ScalarWhereInput
    data: XOR<StudentModel1UpdateManyMutationInput, StudentModel1UncheckedUpdateManyWithoutSchoolInput>
  }

  export type StudentModel1ScalarWhereInput = {
    AND?: StudentModel1ScalarWhereInput | StudentModel1ScalarWhereInput[]
    OR?: StudentModel1ScalarWhereInput[]
    NOT?: StudentModel1ScalarWhereInput | StudentModel1ScalarWhereInput[]
    id?: IntFilter<"StudentModel1"> | number
    participant1Name?: StringFilter<"StudentModel1"> | string
    participant1Gender?: StringFilter<"StudentModel1"> | string
    participant1Class?: StringFilter<"StudentModel1"> | string
    participant1Accommodation?: StringFilter<"StudentModel1"> | string
    participant2Name?: StringFilter<"StudentModel1"> | string
    participant2Gender?: StringFilter<"StudentModel1"> | string
    participant2Class?: StringFilter<"StudentModel1"> | string
    participant2Accommodation?: StringFilter<"StudentModel1"> | string
    additionalRequirements?: StringNullableFilter<"StudentModel1"> | string | null
    declaration?: BoolFilter<"StudentModel1"> | boolean
    writeup?: StringFilter<"StudentModel1"> | string
    schoolId?: IntFilter<"StudentModel1"> | number
    createdAt?: DateTimeFilter<"StudentModel1"> | Date | string
    updatedAt?: DateTimeFilter<"StudentModel1"> | Date | string
  }

  export type StudentModel2UpsertWithWhereUniqueWithoutSchoolInput = {
    where: StudentModel2WhereUniqueInput
    update: XOR<StudentModel2UpdateWithoutSchoolInput, StudentModel2UncheckedUpdateWithoutSchoolInput>
    create: XOR<StudentModel2CreateWithoutSchoolInput, StudentModel2UncheckedCreateWithoutSchoolInput>
  }

  export type StudentModel2UpdateWithWhereUniqueWithoutSchoolInput = {
    where: StudentModel2WhereUniqueInput
    data: XOR<StudentModel2UpdateWithoutSchoolInput, StudentModel2UncheckedUpdateWithoutSchoolInput>
  }

  export type StudentModel2UpdateManyWithWhereWithoutSchoolInput = {
    where: StudentModel2ScalarWhereInput
    data: XOR<StudentModel2UpdateManyMutationInput, StudentModel2UncheckedUpdateManyWithoutSchoolInput>
  }

  export type StudentModel2ScalarWhereInput = {
    AND?: StudentModel2ScalarWhereInput | StudentModel2ScalarWhereInput[]
    OR?: StudentModel2ScalarWhereInput[]
    NOT?: StudentModel2ScalarWhereInput | StudentModel2ScalarWhereInput[]
    id?: IntFilter<"StudentModel2"> | number
    participant1Name?: StringFilter<"StudentModel2"> | string
    participant1Gender?: StringFilter<"StudentModel2"> | string
    participant1Class?: StringFilter<"StudentModel2"> | string
    participant1Accommodation?: StringFilter<"StudentModel2"> | string
    participant2Name?: StringFilter<"StudentModel2"> | string
    participant2Gender?: StringFilter<"StudentModel2"> | string
    participant2Class?: StringFilter<"StudentModel2"> | string
    participant2Accommodation?: StringFilter<"StudentModel2"> | string
    additionalRequirements?: StringNullableFilter<"StudentModel2"> | string | null
    declaration?: BoolFilter<"StudentModel2"> | boolean
    writeup?: StringFilter<"StudentModel2"> | string
    schoolId?: IntFilter<"StudentModel2"> | number
    createdAt?: DateTimeFilter<"StudentModel2"> | Date | string
    updatedAt?: DateTimeFilter<"StudentModel2"> | Date | string
  }

  export type EloquenceEnglishUpsertWithWhereUniqueWithoutSchoolInput = {
    where: EloquenceEnglishWhereUniqueInput
    update: XOR<EloquenceEnglishUpdateWithoutSchoolInput, EloquenceEnglishUncheckedUpdateWithoutSchoolInput>
    create: XOR<EloquenceEnglishCreateWithoutSchoolInput, EloquenceEnglishUncheckedCreateWithoutSchoolInput>
  }

  export type EloquenceEnglishUpdateWithWhereUniqueWithoutSchoolInput = {
    where: EloquenceEnglishWhereUniqueInput
    data: XOR<EloquenceEnglishUpdateWithoutSchoolInput, EloquenceEnglishUncheckedUpdateWithoutSchoolInput>
  }

  export type EloquenceEnglishUpdateManyWithWhereWithoutSchoolInput = {
    where: EloquenceEnglishScalarWhereInput
    data: XOR<EloquenceEnglishUpdateManyMutationInput, EloquenceEnglishUncheckedUpdateManyWithoutSchoolInput>
  }

  export type EloquenceEnglishScalarWhereInput = {
    AND?: EloquenceEnglishScalarWhereInput | EloquenceEnglishScalarWhereInput[]
    OR?: EloquenceEnglishScalarWhereInput[]
    NOT?: EloquenceEnglishScalarWhereInput | EloquenceEnglishScalarWhereInput[]
    id?: IntFilter<"EloquenceEnglish"> | number
    participantName?: StringFilter<"EloquenceEnglish"> | string
    participantGender?: StringFilter<"EloquenceEnglish"> | string
    participantClass?: StringFilter<"EloquenceEnglish"> | string
    accommodationRequired?: StringFilter<"EloquenceEnglish"> | string
    declaration?: BoolFilter<"EloquenceEnglish"> | boolean
    schoolId?: IntFilter<"EloquenceEnglish"> | number
    createdAt?: DateTimeFilter<"EloquenceEnglish"> | Date | string
    updatedAt?: DateTimeFilter<"EloquenceEnglish"> | Date | string
  }

  export type EloquenceHindiUpsertWithWhereUniqueWithoutSchoolInput = {
    where: EloquenceHindiWhereUniqueInput
    update: XOR<EloquenceHindiUpdateWithoutSchoolInput, EloquenceHindiUncheckedUpdateWithoutSchoolInput>
    create: XOR<EloquenceHindiCreateWithoutSchoolInput, EloquenceHindiUncheckedCreateWithoutSchoolInput>
  }

  export type EloquenceHindiUpdateWithWhereUniqueWithoutSchoolInput = {
    where: EloquenceHindiWhereUniqueInput
    data: XOR<EloquenceHindiUpdateWithoutSchoolInput, EloquenceHindiUncheckedUpdateWithoutSchoolInput>
  }

  export type EloquenceHindiUpdateManyWithWhereWithoutSchoolInput = {
    where: EloquenceHindiScalarWhereInput
    data: XOR<EloquenceHindiUpdateManyMutationInput, EloquenceHindiUncheckedUpdateManyWithoutSchoolInput>
  }

  export type EloquenceHindiScalarWhereInput = {
    AND?: EloquenceHindiScalarWhereInput | EloquenceHindiScalarWhereInput[]
    OR?: EloquenceHindiScalarWhereInput[]
    NOT?: EloquenceHindiScalarWhereInput | EloquenceHindiScalarWhereInput[]
    id?: IntFilter<"EloquenceHindi"> | number
    participantName?: StringFilter<"EloquenceHindi"> | string
    participantGender?: StringFilter<"EloquenceHindi"> | string
    participantClass?: StringFilter<"EloquenceHindi"> | string
    accommodationRequired?: StringFilter<"EloquenceHindi"> | string
    declaration?: BoolFilter<"EloquenceHindi"> | boolean
    schoolId?: IntFilter<"EloquenceHindi"> | number
    createdAt?: DateTimeFilter<"EloquenceHindi"> | Date | string
    updatedAt?: DateTimeFilter<"EloquenceHindi"> | Date | string
  }

  export type EloquenceGujaratiUpsertWithWhereUniqueWithoutSchoolInput = {
    where: EloquenceGujaratiWhereUniqueInput
    update: XOR<EloquenceGujaratiUpdateWithoutSchoolInput, EloquenceGujaratiUncheckedUpdateWithoutSchoolInput>
    create: XOR<EloquenceGujaratiCreateWithoutSchoolInput, EloquenceGujaratiUncheckedCreateWithoutSchoolInput>
  }

  export type EloquenceGujaratiUpdateWithWhereUniqueWithoutSchoolInput = {
    where: EloquenceGujaratiWhereUniqueInput
    data: XOR<EloquenceGujaratiUpdateWithoutSchoolInput, EloquenceGujaratiUncheckedUpdateWithoutSchoolInput>
  }

  export type EloquenceGujaratiUpdateManyWithWhereWithoutSchoolInput = {
    where: EloquenceGujaratiScalarWhereInput
    data: XOR<EloquenceGujaratiUpdateManyMutationInput, EloquenceGujaratiUncheckedUpdateManyWithoutSchoolInput>
  }

  export type EloquenceGujaratiScalarWhereInput = {
    AND?: EloquenceGujaratiScalarWhereInput | EloquenceGujaratiScalarWhereInput[]
    OR?: EloquenceGujaratiScalarWhereInput[]
    NOT?: EloquenceGujaratiScalarWhereInput | EloquenceGujaratiScalarWhereInput[]
    id?: IntFilter<"EloquenceGujarati"> | number
    participantName?: StringFilter<"EloquenceGujarati"> | string
    participantGender?: StringFilter<"EloquenceGujarati"> | string
    participantClass?: StringFilter<"EloquenceGujarati"> | string
    accommodationRequired?: StringFilter<"EloquenceGujarati"> | string
    declaration?: BoolFilter<"EloquenceGujarati"> | boolean
    schoolId?: IntFilter<"EloquenceGujarati"> | number
    createdAt?: DateTimeFilter<"EloquenceGujarati"> | Date | string
    updatedAt?: DateTimeFilter<"EloquenceGujarati"> | Date | string
  }

  export type EssayEnglishUpsertWithWhereUniqueWithoutSchoolInput = {
    where: EssayEnglishWhereUniqueInput
    update: XOR<EssayEnglishUpdateWithoutSchoolInput, EssayEnglishUncheckedUpdateWithoutSchoolInput>
    create: XOR<EssayEnglishCreateWithoutSchoolInput, EssayEnglishUncheckedCreateWithoutSchoolInput>
  }

  export type EssayEnglishUpdateWithWhereUniqueWithoutSchoolInput = {
    where: EssayEnglishWhereUniqueInput
    data: XOR<EssayEnglishUpdateWithoutSchoolInput, EssayEnglishUncheckedUpdateWithoutSchoolInput>
  }

  export type EssayEnglishUpdateManyWithWhereWithoutSchoolInput = {
    where: EssayEnglishScalarWhereInput
    data: XOR<EssayEnglishUpdateManyMutationInput, EssayEnglishUncheckedUpdateManyWithoutSchoolInput>
  }

  export type EssayEnglishScalarWhereInput = {
    AND?: EssayEnglishScalarWhereInput | EssayEnglishScalarWhereInput[]
    OR?: EssayEnglishScalarWhereInput[]
    NOT?: EssayEnglishScalarWhereInput | EssayEnglishScalarWhereInput[]
    id?: IntFilter<"EssayEnglish"> | number
    participantName?: StringFilter<"EssayEnglish"> | string
    participantGender?: StringFilter<"EssayEnglish"> | string
    participantClass?: StringFilter<"EssayEnglish"> | string
    accommodationRequired?: StringFilter<"EssayEnglish"> | string
    essayFileUrl?: StringFilter<"EssayEnglish"> | string
    declaration?: BoolFilter<"EssayEnglish"> | boolean
    schoolId?: IntFilter<"EssayEnglish"> | number
    createdAt?: DateTimeFilter<"EssayEnglish"> | Date | string
    updatedAt?: DateTimeFilter<"EssayEnglish"> | Date | string
  }

  export type EssayHindiUpsertWithWhereUniqueWithoutSchoolInput = {
    where: EssayHindiWhereUniqueInput
    update: XOR<EssayHindiUpdateWithoutSchoolInput, EssayHindiUncheckedUpdateWithoutSchoolInput>
    create: XOR<EssayHindiCreateWithoutSchoolInput, EssayHindiUncheckedCreateWithoutSchoolInput>
  }

  export type EssayHindiUpdateWithWhereUniqueWithoutSchoolInput = {
    where: EssayHindiWhereUniqueInput
    data: XOR<EssayHindiUpdateWithoutSchoolInput, EssayHindiUncheckedUpdateWithoutSchoolInput>
  }

  export type EssayHindiUpdateManyWithWhereWithoutSchoolInput = {
    where: EssayHindiScalarWhereInput
    data: XOR<EssayHindiUpdateManyMutationInput, EssayHindiUncheckedUpdateManyWithoutSchoolInput>
  }

  export type EssayHindiScalarWhereInput = {
    AND?: EssayHindiScalarWhereInput | EssayHindiScalarWhereInput[]
    OR?: EssayHindiScalarWhereInput[]
    NOT?: EssayHindiScalarWhereInput | EssayHindiScalarWhereInput[]
    id?: IntFilter<"EssayHindi"> | number
    participantName?: StringFilter<"EssayHindi"> | string
    participantGender?: StringFilter<"EssayHindi"> | string
    participantClass?: StringFilter<"EssayHindi"> | string
    accommodationRequired?: StringFilter<"EssayHindi"> | string
    essayFileUrl?: StringFilter<"EssayHindi"> | string
    declaration?: BoolFilter<"EssayHindi"> | boolean
    schoolId?: IntFilter<"EssayHindi"> | number
    createdAt?: DateTimeFilter<"EssayHindi"> | Date | string
    updatedAt?: DateTimeFilter<"EssayHindi"> | Date | string
  }

  export type EssayGujaratiUpsertWithWhereUniqueWithoutSchoolInput = {
    where: EssayGujaratiWhereUniqueInput
    update: XOR<EssayGujaratiUpdateWithoutSchoolInput, EssayGujaratiUncheckedUpdateWithoutSchoolInput>
    create: XOR<EssayGujaratiCreateWithoutSchoolInput, EssayGujaratiUncheckedCreateWithoutSchoolInput>
  }

  export type EssayGujaratiUpdateWithWhereUniqueWithoutSchoolInput = {
    where: EssayGujaratiWhereUniqueInput
    data: XOR<EssayGujaratiUpdateWithoutSchoolInput, EssayGujaratiUncheckedUpdateWithoutSchoolInput>
  }

  export type EssayGujaratiUpdateManyWithWhereWithoutSchoolInput = {
    where: EssayGujaratiScalarWhereInput
    data: XOR<EssayGujaratiUpdateManyMutationInput, EssayGujaratiUncheckedUpdateManyWithoutSchoolInput>
  }

  export type EssayGujaratiScalarWhereInput = {
    AND?: EssayGujaratiScalarWhereInput | EssayGujaratiScalarWhereInput[]
    OR?: EssayGujaratiScalarWhereInput[]
    NOT?: EssayGujaratiScalarWhereInput | EssayGujaratiScalarWhereInput[]
    id?: IntFilter<"EssayGujarati"> | number
    participantName?: StringFilter<"EssayGujarati"> | string
    participantGender?: StringFilter<"EssayGujarati"> | string
    participantClass?: StringFilter<"EssayGujarati"> | string
    accommodationRequired?: StringFilter<"EssayGujarati"> | string
    essayFileUrl?: StringFilter<"EssayGujarati"> | string
    declaration?: BoolFilter<"EssayGujarati"> | boolean
    schoolId?: IntFilter<"EssayGujarati"> | number
    createdAt?: DateTimeFilter<"EssayGujarati"> | Date | string
    updatedAt?: DateTimeFilter<"EssayGujarati"> | Date | string
  }

  export type PosterUpsertWithWhereUniqueWithoutSchoolInput = {
    where: PosterWhereUniqueInput
    update: XOR<PosterUpdateWithoutSchoolInput, PosterUncheckedUpdateWithoutSchoolInput>
    create: XOR<PosterCreateWithoutSchoolInput, PosterUncheckedCreateWithoutSchoolInput>
  }

  export type PosterUpdateWithWhereUniqueWithoutSchoolInput = {
    where: PosterWhereUniqueInput
    data: XOR<PosterUpdateWithoutSchoolInput, PosterUncheckedUpdateWithoutSchoolInput>
  }

  export type PosterUpdateManyWithWhereWithoutSchoolInput = {
    where: PosterScalarWhereInput
    data: XOR<PosterUpdateManyMutationInput, PosterUncheckedUpdateManyWithoutSchoolInput>
  }

  export type PosterScalarWhereInput = {
    AND?: PosterScalarWhereInput | PosterScalarWhereInput[]
    OR?: PosterScalarWhereInput[]
    NOT?: PosterScalarWhereInput | PosterScalarWhereInput[]
    id?: IntFilter<"Poster"> | number
    participant1Name?: StringFilter<"Poster"> | string
    participant1Gender?: StringFilter<"Poster"> | string
    participant1Class?: StringFilter<"Poster"> | string
    participant1Accommodation?: StringFilter<"Poster"> | string
    participant1Declaration?: BoolFilter<"Poster"> | boolean
    participant2Name?: StringNullableFilter<"Poster"> | string | null
    participant2Gender?: StringNullableFilter<"Poster"> | string | null
    participant2Class?: StringNullableFilter<"Poster"> | string | null
    participant2Accommodation?: StringNullableFilter<"Poster"> | string | null
    participant2Declaration?: BoolNullableFilter<"Poster"> | boolean | null
    schoolId?: IntFilter<"Poster"> | number
    createdAt?: DateTimeFilter<"Poster"> | Date | string
    updatedAt?: DateTimeFilter<"Poster"> | Date | string
  }

  export type SkitUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SkitWhereUniqueInput
    update: XOR<SkitUpdateWithoutSchoolInput, SkitUncheckedUpdateWithoutSchoolInput>
    create: XOR<SkitCreateWithoutSchoolInput, SkitUncheckedCreateWithoutSchoolInput>
  }

  export type SkitUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SkitWhereUniqueInput
    data: XOR<SkitUpdateWithoutSchoolInput, SkitUncheckedUpdateWithoutSchoolInput>
  }

  export type SkitUpdateManyWithWhereWithoutSchoolInput = {
    where: SkitScalarWhereInput
    data: XOR<SkitUpdateManyMutationInput, SkitUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SkitScalarWhereInput = {
    AND?: SkitScalarWhereInput | SkitScalarWhereInput[]
    OR?: SkitScalarWhereInput[]
    NOT?: SkitScalarWhereInput | SkitScalarWhereInput[]
    id?: IntFilter<"Skit"> | number
    participant1Name?: StringFilter<"Skit"> | string
    participant1Gender?: StringFilter<"Skit"> | string
    participant1Class?: StringFilter<"Skit"> | string
    participant1Accommodation?: StringFilter<"Skit"> | string
    participant2Name?: StringNullableFilter<"Skit"> | string | null
    participant2Gender?: StringNullableFilter<"Skit"> | string | null
    participant2Class?: StringNullableFilter<"Skit"> | string | null
    participant2Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant3Name?: StringNullableFilter<"Skit"> | string | null
    participant3Gender?: StringNullableFilter<"Skit"> | string | null
    participant3Class?: StringNullableFilter<"Skit"> | string | null
    participant3Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant4Name?: StringNullableFilter<"Skit"> | string | null
    participant4Gender?: StringNullableFilter<"Skit"> | string | null
    participant4Class?: StringNullableFilter<"Skit"> | string | null
    participant4Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant5Name?: StringNullableFilter<"Skit"> | string | null
    participant5Gender?: StringNullableFilter<"Skit"> | string | null
    participant5Class?: StringNullableFilter<"Skit"> | string | null
    participant5Accommodation?: StringNullableFilter<"Skit"> | string | null
    participant6Name?: StringNullableFilter<"Skit"> | string | null
    participant6Gender?: StringNullableFilter<"Skit"> | string | null
    participant6Class?: StringNullableFilter<"Skit"> | string | null
    participant6Accommodation?: StringNullableFilter<"Skit"> | string | null
    additionalRequirements?: StringNullableFilter<"Skit"> | string | null
    declaration?: BoolFilter<"Skit"> | boolean
    videoLink?: StringFilter<"Skit"> | string
    schoolId?: IntFilter<"Skit"> | number
    createdAt?: DateTimeFilter<"Skit"> | Date | string
    updatedAt?: DateTimeFilter<"Skit"> | Date | string
  }

  export type TeacherModelUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TeacherModelWhereUniqueInput
    update: XOR<TeacherModelUpdateWithoutSchoolInput, TeacherModelUncheckedUpdateWithoutSchoolInput>
    create: XOR<TeacherModelCreateWithoutSchoolInput, TeacherModelUncheckedCreateWithoutSchoolInput>
  }

  export type TeacherModelUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TeacherModelWhereUniqueInput
    data: XOR<TeacherModelUpdateWithoutSchoolInput, TeacherModelUncheckedUpdateWithoutSchoolInput>
  }

  export type TeacherModelUpdateManyWithWhereWithoutSchoolInput = {
    where: TeacherModelScalarWhereInput
    data: XOR<TeacherModelUpdateManyMutationInput, TeacherModelUncheckedUpdateManyWithoutSchoolInput>
  }

  export type TeacherModelScalarWhereInput = {
    AND?: TeacherModelScalarWhereInput | TeacherModelScalarWhereInput[]
    OR?: TeacherModelScalarWhereInput[]
    NOT?: TeacherModelScalarWhereInput | TeacherModelScalarWhereInput[]
    id?: IntFilter<"TeacherModel"> | number
    teacherName?: StringFilter<"TeacherModel"> | string
    teacherGender?: StringFilter<"TeacherModel"> | string
    accommodationRequired?: StringFilter<"TeacherModel"> | string
    additionalRequirements?: StringNullableFilter<"TeacherModel"> | string | null
    declaration?: BoolFilter<"TeacherModel"> | boolean
    writeup?: StringFilter<"TeacherModel"> | string
    schoolId?: IntFilter<"TeacherModel"> | number
    createdAt?: DateTimeFilter<"TeacherModel"> | Date | string
    updatedAt?: DateTimeFilter<"TeacherModel"> | Date | string
  }

  export type SchoolCreateWithoutAccompanyingTeachersInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutAccompanyingTeachersInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutAccompanyingTeachersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAccompanyingTeachersInput, SchoolUncheckedCreateWithoutAccompanyingTeachersInput>
  }

  export type SchoolUpsertWithoutAccompanyingTeachersInput = {
    update: XOR<SchoolUpdateWithoutAccompanyingTeachersInput, SchoolUncheckedUpdateWithoutAccompanyingTeachersInput>
    create: XOR<SchoolCreateWithoutAccompanyingTeachersInput, SchoolUncheckedCreateWithoutAccompanyingTeachersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutAccompanyingTeachersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutAccompanyingTeachersInput, SchoolUncheckedUpdateWithoutAccompanyingTeachersInput>
  }

  export type SchoolUpdateWithoutAccompanyingTeachersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutAccompanyingTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutCompetitionsInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutCompetitionsInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutCompetitionsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutCompetitionsInput, SchoolUncheckedCreateWithoutCompetitionsInput>
  }

  export type SchoolUpsertWithoutCompetitionsInput = {
    update: XOR<SchoolUpdateWithoutCompetitionsInput, SchoolUncheckedUpdateWithoutCompetitionsInput>
    create: XOR<SchoolCreateWithoutCompetitionsInput, SchoolUncheckedCreateWithoutCompetitionsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutCompetitionsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutCompetitionsInput, SchoolUncheckedUpdateWithoutCompetitionsInput>
  }

  export type SchoolUpdateWithoutCompetitionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutCompetitionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutStudentModel1Input = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutStudentModel1Input = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutStudentModel1Input = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutStudentModel1Input, SchoolUncheckedCreateWithoutStudentModel1Input>
  }

  export type SchoolUpsertWithoutStudentModel1Input = {
    update: XOR<SchoolUpdateWithoutStudentModel1Input, SchoolUncheckedUpdateWithoutStudentModel1Input>
    create: XOR<SchoolCreateWithoutStudentModel1Input, SchoolUncheckedCreateWithoutStudentModel1Input>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutStudentModel1Input = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutStudentModel1Input, SchoolUncheckedUpdateWithoutStudentModel1Input>
  }

  export type SchoolUpdateWithoutStudentModel1Input = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutStudentModel1Input = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutStudentModel2Input = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutStudentModel2Input = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutStudentModel2Input = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutStudentModel2Input, SchoolUncheckedCreateWithoutStudentModel2Input>
  }

  export type SchoolUpsertWithoutStudentModel2Input = {
    update: XOR<SchoolUpdateWithoutStudentModel2Input, SchoolUncheckedUpdateWithoutStudentModel2Input>
    create: XOR<SchoolCreateWithoutStudentModel2Input, SchoolUncheckedCreateWithoutStudentModel2Input>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutStudentModel2Input = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutStudentModel2Input, SchoolUncheckedUpdateWithoutStudentModel2Input>
  }

  export type SchoolUpdateWithoutStudentModel2Input = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutStudentModel2Input = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutEloquenceEnglishInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutEloquenceEnglishInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutEloquenceEnglishInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutEloquenceEnglishInput, SchoolUncheckedCreateWithoutEloquenceEnglishInput>
  }

  export type SchoolUpsertWithoutEloquenceEnglishInput = {
    update: XOR<SchoolUpdateWithoutEloquenceEnglishInput, SchoolUncheckedUpdateWithoutEloquenceEnglishInput>
    create: XOR<SchoolCreateWithoutEloquenceEnglishInput, SchoolUncheckedCreateWithoutEloquenceEnglishInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutEloquenceEnglishInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutEloquenceEnglishInput, SchoolUncheckedUpdateWithoutEloquenceEnglishInput>
  }

  export type SchoolUpdateWithoutEloquenceEnglishInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutEloquenceEnglishInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutEloquenceHindiInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutEloquenceHindiInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutEloquenceHindiInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutEloquenceHindiInput, SchoolUncheckedCreateWithoutEloquenceHindiInput>
  }

  export type SchoolUpsertWithoutEloquenceHindiInput = {
    update: XOR<SchoolUpdateWithoutEloquenceHindiInput, SchoolUncheckedUpdateWithoutEloquenceHindiInput>
    create: XOR<SchoolCreateWithoutEloquenceHindiInput, SchoolUncheckedCreateWithoutEloquenceHindiInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutEloquenceHindiInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutEloquenceHindiInput, SchoolUncheckedUpdateWithoutEloquenceHindiInput>
  }

  export type SchoolUpdateWithoutEloquenceHindiInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutEloquenceHindiInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutEloquenceGujaratiInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutEloquenceGujaratiInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutEloquenceGujaratiInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutEloquenceGujaratiInput, SchoolUncheckedCreateWithoutEloquenceGujaratiInput>
  }

  export type SchoolUpsertWithoutEloquenceGujaratiInput = {
    update: XOR<SchoolUpdateWithoutEloquenceGujaratiInput, SchoolUncheckedUpdateWithoutEloquenceGujaratiInput>
    create: XOR<SchoolCreateWithoutEloquenceGujaratiInput, SchoolUncheckedCreateWithoutEloquenceGujaratiInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutEloquenceGujaratiInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutEloquenceGujaratiInput, SchoolUncheckedUpdateWithoutEloquenceGujaratiInput>
  }

  export type SchoolUpdateWithoutEloquenceGujaratiInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutEloquenceGujaratiInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutEssayEnglishInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutEssayEnglishInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutEssayEnglishInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutEssayEnglishInput, SchoolUncheckedCreateWithoutEssayEnglishInput>
  }

  export type SchoolUpsertWithoutEssayEnglishInput = {
    update: XOR<SchoolUpdateWithoutEssayEnglishInput, SchoolUncheckedUpdateWithoutEssayEnglishInput>
    create: XOR<SchoolCreateWithoutEssayEnglishInput, SchoolUncheckedCreateWithoutEssayEnglishInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutEssayEnglishInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutEssayEnglishInput, SchoolUncheckedUpdateWithoutEssayEnglishInput>
  }

  export type SchoolUpdateWithoutEssayEnglishInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutEssayEnglishInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutEssayHindiInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutEssayHindiInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutEssayHindiInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutEssayHindiInput, SchoolUncheckedCreateWithoutEssayHindiInput>
  }

  export type SchoolUpsertWithoutEssayHindiInput = {
    update: XOR<SchoolUpdateWithoutEssayHindiInput, SchoolUncheckedUpdateWithoutEssayHindiInput>
    create: XOR<SchoolCreateWithoutEssayHindiInput, SchoolUncheckedCreateWithoutEssayHindiInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutEssayHindiInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutEssayHindiInput, SchoolUncheckedUpdateWithoutEssayHindiInput>
  }

  export type SchoolUpdateWithoutEssayHindiInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutEssayHindiInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutEssayGujaratiInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutEssayGujaratiInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutEssayGujaratiInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutEssayGujaratiInput, SchoolUncheckedCreateWithoutEssayGujaratiInput>
  }

  export type SchoolUpsertWithoutEssayGujaratiInput = {
    update: XOR<SchoolUpdateWithoutEssayGujaratiInput, SchoolUncheckedUpdateWithoutEssayGujaratiInput>
    create: XOR<SchoolCreateWithoutEssayGujaratiInput, SchoolUncheckedCreateWithoutEssayGujaratiInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutEssayGujaratiInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutEssayGujaratiInput, SchoolUncheckedUpdateWithoutEssayGujaratiInput>
  }

  export type SchoolUpdateWithoutEssayGujaratiInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutEssayGujaratiInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutPosterInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutPosterInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutPosterInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutPosterInput, SchoolUncheckedCreateWithoutPosterInput>
  }

  export type SchoolUpsertWithoutPosterInput = {
    update: XOR<SchoolUpdateWithoutPosterInput, SchoolUncheckedUpdateWithoutPosterInput>
    create: XOR<SchoolCreateWithoutPosterInput, SchoolUncheckedCreateWithoutPosterInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutPosterInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutPosterInput, SchoolUncheckedUpdateWithoutPosterInput>
  }

  export type SchoolUpdateWithoutPosterInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutPosterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutSkitInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSkitInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    TeacherModel?: TeacherModelUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSkitInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSkitInput, SchoolUncheckedCreateWithoutSkitInput>
  }

  export type SchoolUpsertWithoutSkitInput = {
    update: XOR<SchoolUpdateWithoutSkitInput, SchoolUncheckedUpdateWithoutSkitInput>
    create: XOR<SchoolCreateWithoutSkitInput, SchoolUncheckedCreateWithoutSkitInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSkitInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSkitInput, SchoolUncheckedUpdateWithoutSkitInput>
  }

  export type SchoolUpdateWithoutSkitInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSkitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    TeacherModel?: TeacherModelUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutTeacherModelInput = {
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1CreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2CreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiCreateNestedManyWithoutSchoolInput
    Poster?: PosterCreateNestedManyWithoutSchoolInput
    Skit?: SkitCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutTeacherModelInput = {
    id?: number
    name: string
    address: string
    city: string
    pincode: string
    affiliationNumber: string
    coordinatorTeacherName: string
    coordinatorTeacherMobile: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedCreateNestedManyWithoutSchoolInput
    competitions?: CompetitionUncheckedCreateNestedManyWithoutSchoolInput
    StudentModel1?: StudentModel1UncheckedCreateNestedManyWithoutSchoolInput
    StudentModel2?: StudentModel2UncheckedCreateNestedManyWithoutSchoolInput
    EloquenceEnglish?: EloquenceEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceHindi?: EloquenceHindiUncheckedCreateNestedManyWithoutSchoolInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    EssayEnglish?: EssayEnglishUncheckedCreateNestedManyWithoutSchoolInput
    EssayHindi?: EssayHindiUncheckedCreateNestedManyWithoutSchoolInput
    EssayGujarati?: EssayGujaratiUncheckedCreateNestedManyWithoutSchoolInput
    Poster?: PosterUncheckedCreateNestedManyWithoutSchoolInput
    Skit?: SkitUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutTeacherModelInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutTeacherModelInput, SchoolUncheckedCreateWithoutTeacherModelInput>
  }

  export type SchoolUpsertWithoutTeacherModelInput = {
    update: XOR<SchoolUpdateWithoutTeacherModelInput, SchoolUncheckedUpdateWithoutTeacherModelInput>
    create: XOR<SchoolCreateWithoutTeacherModelInput, SchoolUncheckedCreateWithoutTeacherModelInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutTeacherModelInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutTeacherModelInput, SchoolUncheckedUpdateWithoutTeacherModelInput>
  }

  export type SchoolUpdateWithoutTeacherModelInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutTeacherModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    affiliationNumber?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherName?: StringFieldUpdateOperationsInput | string
    coordinatorTeacherMobile?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompanyingTeachers?: AccompanyingTeacherUncheckedUpdateManyWithoutSchoolNestedInput
    competitions?: CompetitionUncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel1?: StudentModel1UncheckedUpdateManyWithoutSchoolNestedInput
    StudentModel2?: StudentModel2UncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceEnglish?: EloquenceEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceHindi?: EloquenceHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EloquenceGujarati?: EloquenceGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayEnglish?: EssayEnglishUncheckedUpdateManyWithoutSchoolNestedInput
    EssayHindi?: EssayHindiUncheckedUpdateManyWithoutSchoolNestedInput
    EssayGujarati?: EssayGujaratiUncheckedUpdateManyWithoutSchoolNestedInput
    Poster?: PosterUncheckedUpdateManyWithoutSchoolNestedInput
    Skit?: SkitUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type AccompanyingTeacherCreateManySchoolInput = {
    id?: number
    name: string
    gender: string
    requiresAccommodation: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitionCreateManySchoolInput = {
    id?: number
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentModel1CreateManySchoolInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentModel2CreateManySchoolInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name: string
    participant2Gender: string
    participant2Class: string
    participant2Accommodation: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceEnglishCreateManySchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceHindiCreateManySchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EloquenceGujaratiCreateManySchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayEnglishCreateManySchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayHindiCreateManySchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EssayGujaratiCreateManySchoolInput = {
    id?: number
    participantName: string
    participantGender: string
    participantClass: string
    accommodationRequired: string
    essayFileUrl: string
    declaration: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosterCreateManySchoolInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant1Declaration: boolean
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant2Declaration?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkitCreateManySchoolInput = {
    id?: number
    participant1Name: string
    participant1Gender: string
    participant1Class: string
    participant1Accommodation: string
    participant2Name?: string | null
    participant2Gender?: string | null
    participant2Class?: string | null
    participant2Accommodation?: string | null
    participant3Name?: string | null
    participant3Gender?: string | null
    participant3Class?: string | null
    participant3Accommodation?: string | null
    participant4Name?: string | null
    participant4Gender?: string | null
    participant4Class?: string | null
    participant4Accommodation?: string | null
    participant5Name?: string | null
    participant5Gender?: string | null
    participant5Class?: string | null
    participant5Accommodation?: string | null
    participant6Name?: string | null
    participant6Gender?: string | null
    participant6Class?: string | null
    participant6Accommodation?: string | null
    additionalRequirements?: string | null
    declaration: boolean
    videoLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherModelCreateManySchoolInput = {
    id?: number
    teacherName: string
    teacherGender: string
    accommodationRequired: string
    additionalRequirements?: string | null
    declaration: boolean
    writeup: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccompanyingTeacherUpdateWithoutSchoolInput = {
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    requiresAccommodation?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanyingTeacherUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    requiresAccommodation?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanyingTeacherUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    requiresAccommodation?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitionUpdateWithoutSchoolInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitionUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitionUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel1UpdateWithoutSchoolInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel1UncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel1UncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel2UpdateWithoutSchoolInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel2UncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentModel2UncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: StringFieldUpdateOperationsInput | string
    participant2Gender?: StringFieldUpdateOperationsInput | string
    participant2Class?: StringFieldUpdateOperationsInput | string
    participant2Accommodation?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceEnglishUpdateWithoutSchoolInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceEnglishUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceEnglishUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceHindiUpdateWithoutSchoolInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceHindiUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceHindiUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceGujaratiUpdateWithoutSchoolInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceGujaratiUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EloquenceGujaratiUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayEnglishUpdateWithoutSchoolInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayEnglishUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayEnglishUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayHindiUpdateWithoutSchoolInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayHindiUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayHindiUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayGujaratiUpdateWithoutSchoolInput = {
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayGujaratiUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EssayGujaratiUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participantName?: StringFieldUpdateOperationsInput | string
    participantGender?: StringFieldUpdateOperationsInput | string
    participantClass?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    essayFileUrl?: StringFieldUpdateOperationsInput | string
    declaration?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosterUpdateWithoutSchoolInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant1Declaration?: BoolFieldUpdateOperationsInput | boolean
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Declaration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosterUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant1Declaration?: BoolFieldUpdateOperationsInput | boolean
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Declaration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosterUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant1Declaration?: BoolFieldUpdateOperationsInput | boolean
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Declaration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkitUpdateWithoutSchoolInput = {
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    videoLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkitUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    videoLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkitUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    participant1Name?: StringFieldUpdateOperationsInput | string
    participant1Gender?: StringFieldUpdateOperationsInput | string
    participant1Class?: StringFieldUpdateOperationsInput | string
    participant1Accommodation?: StringFieldUpdateOperationsInput | string
    participant2Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant2Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant3Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant4Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant5Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Name?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Gender?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Class?: NullableStringFieldUpdateOperationsInput | string | null
    participant6Accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    videoLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherModelUpdateWithoutSchoolInput = {
    teacherName?: StringFieldUpdateOperationsInput | string
    teacherGender?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherModelUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherName?: StringFieldUpdateOperationsInput | string
    teacherGender?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherModelUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherName?: StringFieldUpdateOperationsInput | string
    teacherGender?: StringFieldUpdateOperationsInput | string
    accommodationRequired?: StringFieldUpdateOperationsInput | string
    additionalRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    declaration?: BoolFieldUpdateOperationsInput | boolean
    writeup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SchoolCountOutputTypeDefaultArgs instead
     */
    export type SchoolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RatingsDefaultArgs instead
     */
    export type RatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RatingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use feedbackFormDefaultArgs instead
     */
    export type feedbackFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = feedbackFormDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitorDefaultArgs instead
     */
    export type VisitorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolDefaultArgs instead
     */
    export type SchoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccompanyingTeacherDefaultArgs instead
     */
    export type AccompanyingTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccompanyingTeacherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompetitionDefaultArgs instead
     */
    export type CompetitionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompetitionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentModel1DefaultArgs instead
     */
    export type StudentModel1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentModel1DefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentModel2DefaultArgs instead
     */
    export type StudentModel2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentModel2DefaultArgs<ExtArgs>
    /**
     * @deprecated Use EloquenceEnglishDefaultArgs instead
     */
    export type EloquenceEnglishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EloquenceEnglishDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EloquenceHindiDefaultArgs instead
     */
    export type EloquenceHindiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EloquenceHindiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EloquenceGujaratiDefaultArgs instead
     */
    export type EloquenceGujaratiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EloquenceGujaratiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EssayEnglishDefaultArgs instead
     */
    export type EssayEnglishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EssayEnglishDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EssayHindiDefaultArgs instead
     */
    export type EssayHindiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EssayHindiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EssayGujaratiDefaultArgs instead
     */
    export type EssayGujaratiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EssayGujaratiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PosterDefaultArgs instead
     */
    export type PosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PosterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkitDefaultArgs instead
     */
    export type SkitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherModelDefaultArgs instead
     */
    export type TeacherModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IPRExhibitionFormDefaultArgs instead
     */
    export type IPRExhibitionFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IPRExhibitionFormDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}